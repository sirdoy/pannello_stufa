---
phase: 61-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["61-01"]
files_modified:
  - app/api/fritzbox/health/route.ts
  - app/api/fritzbox/devices/route.ts
  - app/api/fritzbox/bandwidth/route.ts
  - app/api/fritzbox/wan/route.ts
  - app/api/fritzbox/health/__tests__/route.test.ts
  - app/api/fritzbox/devices/__tests__/route.test.ts
  - app/api/fritzbox/bandwidth/__tests__/route.test.ts
  - app/api/fritzbox/wan/__tests__/route.test.ts
autonomous: true
user_setup:
  - service: fritzbox
    why: "Fritz!Box router API access for network monitoring"
    env_vars:
      - name: FRITZBOX_URL
        source: "Your Fritz!Box URL (e.g., http://fritz.box or https://myfritz.net/xxxxx)"
      - name: FRITZBOX_USER
        source: "Fritz!Box admin username"
      - name: FRITZBOX_PASSWORD
        source: "Fritz!Box admin password"
    dashboard_config:
      - task: "Enable TR-064 API access"
        location: "Fritz!Box admin > Home Network > Network > Network Settings > Allow access for applications"
      - task: "Enable UPnP status"
        location: "Fritz!Box admin > Home Network > Network > Network Settings > Transmit status information over UPnP"
must_haves:
  truths:
    - "GET /api/fritzbox/health returns connected status or specific TR064_NOT_ENABLED error with setup guide"
    - "GET /api/fritzbox/devices returns device list from Fritz!Box via cached proxy"
    - "GET /api/fritzbox/bandwidth returns bandwidth stats via cached proxy"
    - "GET /api/fritzbox/wan returns WAN connection status via cached proxy"
    - "All routes require Auth0 authentication (401 without session)"
    - "All routes enforce 10 req/min rate limit (429 when exceeded)"
    - "All routes return RFC 9457 error responses with specific error codes"
  artifacts:
    - path: "app/api/fritzbox/health/route.ts"
      provides: "TR-064 connectivity check endpoint"
      exports: ["GET"]
    - path: "app/api/fritzbox/devices/route.ts"
      provides: "Network device list proxy with cache and rate limiting"
      exports: ["GET"]
    - path: "app/api/fritzbox/bandwidth/route.ts"
      provides: "Bandwidth stats proxy with cache and rate limiting"
      exports: ["GET"]
    - path: "app/api/fritzbox/wan/route.ts"
      provides: "WAN status proxy with cache and rate limiting"
      exports: ["GET"]
  key_links:
    - from: "app/api/fritzbox/devices/route.ts"
      to: "lib/fritzbox/fritzboxClient.ts"
      via: "fritzboxClient.getDevices()"
      pattern: "fritzboxClient\\.getDevices"
    - from: "app/api/fritzbox/devices/route.ts"
      to: "lib/fritzbox/fritzboxCache.ts"
      via: "getCachedData wrapping fritzboxClient call"
      pattern: "getCachedData"
    - from: "app/api/fritzbox/devices/route.ts"
      to: "lib/fritzbox/fritzboxRateLimiter.ts"
      via: "checkRateLimitFritzBox before data fetch"
      pattern: "checkRateLimitFritzBox"
    - from: "app/api/fritzbox/health/route.ts"
      to: "lib/fritzbox/fritzboxClient.ts"
      via: "fritzboxClient.ping() for health check"
      pattern: "fritzboxClient\\.ping"
---

<objective>
Create all 4 Fritz!Box API proxy routes (health, devices, bandwidth, wan) with authentication, rate limiting, caching, and RFC 9457 error handling. Each route follows the established Netatmo/Hue proxy pattern.

Purpose: These routes expose Fritz!Box data to the client while keeping credentials server-side. The health endpoint specifically detects TR-064 disabled and returns actionable setup guidance. Data endpoints use 60s cache to respect the 10 req/min rate limit.

Output: 4 API route files + 4 test files covering auth, rate limiting, caching, and error scenarios.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/61-foundation-infrastructure/61-RESEARCH.md
@.planning/phases/61-foundation-infrastructure/61-01-SUMMARY.md

@app/api/netatmo/homesdata/route.ts
@lib/core/middleware.ts
@lib/core/apiResponse.ts
@lib/core/index.ts
@lib/fritzbox/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Health check and data proxy routes</name>
  <files>
    app/api/fritzbox/health/route.ts
    app/api/fritzbox/devices/route.ts
    app/api/fritzbox/bandwidth/route.ts
    app/api/fritzbox/wan/route.ts
  </files>
  <action>
All routes follow the same structure. Use `app/api/netatmo/homesdata/route.ts` as the canonical pattern reference.

**1. Create `app/api/fritzbox/health/route.ts`** - TR-064 connectivity check:
```
export const dynamic = 'force-dynamic';

export const GET = withAuthAndErrorHandler(async () => {
  // No rate limit check on health (lightweight, no data fetch)
  // No cache (always check real connectivity)
  // Call fritzboxClient.ping() (10s timeout)
  // On success: return success({ status: 'connected', tr064Enabled: true })
  // Errors propagate through withAuthAndErrorHandler:
  //   - TR064_NOT_ENABLED -> 403 with setupGuideUrl
  //   - FRITZBOX_TIMEOUT -> 504
  //   - FRITZBOX_NOT_CONFIGURED -> 500
}, 'FritzBox/Health');
```
NOTE: Do NOT apply rate limiting to health check. It's lightweight (ping) and needed before any other route to verify connectivity.

**2. Create `app/api/fritzbox/devices/route.ts`** - Network device list:
```
export const dynamic = 'force-dynamic';

export const GET = withAuthAndErrorHandler(async (request, context, session) => {
  // 1. Rate limit check
  const rateLimitResult = await checkRateLimitFritzBox(session.user.sub, 'devices');
  if (!rateLimitResult.allowed) {
    throw new ApiError(
      ERROR_CODES.RATE_LIMITED,
      `Troppe richieste. Riprova tra ${rateLimitResult.nextAllowedIn}s`,
      HTTP_STATUS.TOO_MANY_REQUESTS,
      { retryAfter: rateLimitResult.nextAllowedIn }
    );
  }

  // 2. Fetch with cache (60s TTL)
  const devices = await getCachedData('devices', () => fritzboxClient.getDevices());

  // 3. Return data
  return success({ devices });
}, 'FritzBox/Devices');
```

**3. Create `app/api/fritzbox/bandwidth/route.ts`** - Bandwidth stats:
Same pattern as devices route but:
- Rate limit endpoint: `'bandwidth'`
- Cache key: `'bandwidth'`
- Client call: `fritzboxClient.getBandwidth()`
- Return: `success({ bandwidth })`
- Log context: `'FritzBox/Bandwidth'`

**4. Create `app/api/fritzbox/wan/route.ts`** - WAN connection status:
Same pattern as devices route but:
- Rate limit endpoint: `'wan'`
- Cache key: `'wan'`
- Client call: `fritzboxClient.getWanStatus()`
- Return: `success({ wan })`
- Log context: `'FritzBox/WAN'`

**Imports for data routes (devices, bandwidth, wan):**
```typescript
import { withAuthAndErrorHandler, success, ApiError, ERROR_CODES, HTTP_STATUS } from '@/lib/core';
import { fritzboxClient, getCachedData, checkRateLimitFritzBox } from '@/lib/fritzbox';
```

**Imports for health route:**
```typescript
import { withAuthAndErrorHandler, success } from '@/lib/core';
import { fritzboxClient } from '@/lib/fritzbox';
```

All error messages in Italian, matching existing convention (e.g., `'Troppe richieste. Riprova tra ${rateLimitResult.nextAllowedIn}s'`).
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -20` to confirm zero type errors. Verify each route exports `GET` and `dynamic = 'force-dynamic'`. Verify health route does NOT import rate limiter or cache.
  </verify>
  <done>
All 4 API proxy routes created following established patterns. Health endpoint checks TR-064 connectivity without rate limiting. Data endpoints (devices, bandwidth, wan) use rate limiting + caching. All routes use withAuthAndErrorHandler for auth and RFC 9457 error responses.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unit tests for all API routes</name>
  <files>
    app/api/fritzbox/health/__tests__/route.test.ts
    app/api/fritzbox/devices/__tests__/route.test.ts
    app/api/fritzbox/bandwidth/__tests__/route.test.ts
    app/api/fritzbox/wan/__tests__/route.test.ts
  </files>
  <action>
Create unit tests for all 4 routes. Follow the existing test patterns from the codebase (mock middleware, mock lib modules).

**Common test setup for all route tests:**
- Mock `@/lib/auth0` to return session with `user: { sub: 'test-user-id' }`
- Mock `@/lib/fritzbox` (fritzboxClient, getCachedData, checkRateLimitFritzBox)
- Mock console.error/console.warn to suppress output
- Use `jest.mocked()` for type-safe mock access

**1. Create `app/api/fritzbox/health/__tests__/route.test.ts`:**
- Test: Returns 200 with `{ status: 'connected', tr064Enabled: true }` on successful ping
- Test: Returns 401 when no session (withAuthAndErrorHandler blocks)
- Test: Returns 403 with TR064_NOT_ENABLED code and setupGuideUrl when ping throws tr064 error
- Test: Returns 504 with FRITZBOX_TIMEOUT code when ping times out
- Test: Returns 500 with FRITZBOX_NOT_CONFIGURED when env vars missing
- Verify: health does NOT call rate limiter or cache

**2. Create `app/api/fritzbox/devices/__tests__/route.test.ts`:**
- Test: Returns 200 with devices data when rate limit allows and cache provides data
- Test: Returns 429 with RATE_LIMITED code and retryAfter when rate limit exceeded
- Test: Returns 401 when no session
- Test: getCachedData called with 'devices' key and fritzboxClient.getDevices as fetch function
- Test: Error from fritzboxClient propagates as appropriate API error

**3. Create `app/api/fritzbox/bandwidth/__tests__/route.test.ts`:**
- Same pattern as devices tests but for bandwidth endpoint
- Verify cache key is 'bandwidth' and client call is getBandwidth()

**4. Create `app/api/fritzbox/wan/__tests__/route.test.ts`:**
- Same pattern as devices tests but for wan endpoint
- Verify cache key is 'wan' and client call is getWanStatus()

**Testing the middleware chain:**
The `withAuthAndErrorHandler` is tested in its own tests. Route tests should mock it to pass through, OR test the full chain. Recommended: test the exported GET handler directly, which exercises the full middleware chain. Mock `auth0.getSession` to control auth, and mock `@/lib/fritzbox` to control data/errors.

Pattern reference: Check if `app/api/hue/discover/__tests__/route.test.ts` exists for a similar test pattern.
  </action>
  <verify>
Run `npm test -- app/api/fritzbox` — all tests pass. Verify at least 15 test cases across all 4 files. Run `npm test -- --passWithNoTests` to confirm no regressions.
  </verify>
  <done>
All 4 API routes have comprehensive unit tests covering: auth (401), rate limiting (429), cache integration, success responses, and error propagation (403 TR-064, 504 timeout, 500 not configured). Zero test regressions.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — zero errors
2. `npm test -- app/api/fritzbox` — all route tests pass
3. `npm test -- lib/fritzbox` — all foundation tests still pass
4. `curl` simulation (mental model):
   - `GET /api/fritzbox/health` without session -> 401
   - `GET /api/fritzbox/health` with session -> 200 `{ status: 'connected' }` or 403/504 error
   - `GET /api/fritzbox/devices` with session -> 200 `{ devices: [...] }` or 429 rate limited
   - All errors follow RFC 9457: `{ error: string, code: string, details?: object }`
5. Verify no Fritz!Box credentials appear in any route response or client-accessible code
</verification>

<success_criteria>
- 4 API routes under app/api/fritzbox/ (health, devices, bandwidth, wan)
- Health endpoint detects TR-064 disabled with setup guide link in error details
- Data endpoints enforce 10 req/min rate limit with 429 responses
- Data endpoints use 60s cache via getCachedData
- All routes require Auth0 authentication
- All errors follow RFC 9457 format with specific error codes
- 4 test files with 15+ total test cases
- Zero tsc errors, all tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/61-foundation-infrastructure/61-02-SUMMARY.md`
</output>
