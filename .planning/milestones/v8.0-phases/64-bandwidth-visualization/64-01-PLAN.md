---
phase: 64-bandwidth-visualization
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - app/components/devices/network/types.ts
  - app/network/hooks/useBandwidthHistory.ts
  - lib/utils/decimateLTTB.ts
  - lib/utils/__tests__/decimateLTTB.test.ts
  - app/network/hooks/__tests__/useBandwidthHistory.test.ts
autonomous: true

must_haves:
  truths:
    - "LTTB decimation reduces 10080 points to 500 while preserving visual peaks and valleys"
    - "useBandwidthHistory accumulates bandwidth data points up to 7-day buffer (10080 max)"
    - "Time range filter returns only points within selected range (1h, 24h, 7d)"
    - "Data >500 points is automatically decimated via LTTB before returning"
    - "Hook reuses useNetworkData bandwidth updates (no duplicate polling)"
  artifacts:
    - path: "lib/utils/decimateLTTB.ts"
      provides: "LTTB decimation algorithm for time-series data"
      exports: ["decimateLTTB"]
    - path: "app/network/hooks/useBandwidthHistory.ts"
      provides: "Bandwidth history buffering with time range and decimation"
      exports: ["useBandwidthHistory"]
    - path: "app/components/devices/network/types.ts"
      provides: "Extended types for bandwidth history"
      contains: "BandwidthHistoryPoint"
    - path: "lib/utils/__tests__/decimateLTTB.test.ts"
      provides: "LTTB algorithm unit tests"
      min_lines: 60
    - path: "app/network/hooks/__tests__/useBandwidthHistory.test.ts"
      provides: "Hook unit tests"
      min_lines: 80
  key_links:
    - from: "app/network/hooks/useBandwidthHistory.ts"
      to: "lib/utils/decimateLTTB.ts"
      via: "import decimateLTTB"
      pattern: "import.*decimateLTTB.*from"
    - from: "app/network/hooks/useBandwidthHistory.ts"
      to: "app/components/devices/network/types.ts"
      via: "import types"
      pattern: "import.*BandwidthHistoryPoint.*from"
---

<objective>
Create the data layer for bandwidth visualization: LTTB decimation algorithm and useBandwidthHistory hook that buffers bandwidth data points, filters by time range, and decimates large datasets.

Purpose: Provide a performant data pipeline that transforms raw polling data into chart-ready datasets. The LTTB algorithm is the critical performance gate — without it, 7-day views with 10080 data points will crash mobile browsers.

Output: Tested decimation utility + history hook ready for BandwidthChart in Plan 02.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-bandwidth-visualization/64-RESEARCH.md
@app/components/devices/network/types.ts
@app/components/devices/network/hooks/useNetworkData.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LTTB decimation algorithm with TDD</name>
  <files>
    lib/utils/decimateLTTB.ts
    lib/utils/__tests__/decimateLTTB.test.ts
    app/components/devices/network/types.ts
  </files>
  <action>
**RED phase — Write tests first:**

Create `lib/utils/__tests__/decimateLTTB.test.ts` with these test cases:

1. Returns data unchanged when length <= threshold (pass-through for small datasets)
2. Reduces 1000 points to 500 (exact output length = threshold)
3. Always keeps first and last point (boundary preservation)
4. Preserves peak values (create dataset with known spike, verify spike point retained)
5. Preserves valley values (create dataset with known dip, verify dip point retained)
6. Handles threshold of 2 (returns only first and last)
7. Handles empty array (returns empty)
8. Handles single point (returns single point)
9. Reduces 10080 points to 500 (7-day simulation, verify output.length === 500)

Test interface:
```typescript
import { decimateLTTB } from '@/lib/utils/decimateLTTB';

interface TimeSeriesPoint {
  time: number;
  value: number;
}

// decimateLTTB(data: TimeSeriesPoint[], threshold: number): TimeSeriesPoint[]
```

Run tests — they MUST fail (RED).

**GREEN phase — Implement:**

Create `lib/utils/decimateLTTB.ts`:

```typescript
export interface TimeSeriesPoint {
  time: number;
  value: number;
}

export function decimateLTTB(data: TimeSeriesPoint[], threshold: number): TimeSeriesPoint[]
```

Implement the Largest Triangle Three Buckets algorithm:
1. If data.length <= threshold, return data as-is
2. Always keep first point
3. Divide remaining data (excluding first and last) into (threshold - 2) buckets
4. For each bucket: compute average of NEXT bucket, find point in CURRENT bucket with largest triangle area formed by (previous selected point, candidate point, next bucket average)
5. Always keep last point

Use the reference implementation from 64-RESEARCH.md. Key: the "triangle area" formula is `0.5 * |((ax - cx)(by - ay)) - ((ax - bx)(cy - ay))|` where a=previous selected, b=candidate, c=next bucket average.

Run tests — they MUST pass (GREEN).

**Also extend types:**

Add to `app/components/devices/network/types.ts`:

```typescript
// Bandwidth history point for chart data
export interface BandwidthHistoryPoint {
  time: number;      // Unix timestamp ms
  download: number;  // Mbps
  upload: number;    // Mbps
}

// Time range options for bandwidth chart
export type BandwidthTimeRange = '1h' | '24h' | '7d';

// useBandwidthHistory return type
export interface UseBandwidthHistoryReturn {
  chartData: BandwidthHistoryPoint[];
  timeRange: BandwidthTimeRange;
  setTimeRange: (range: BandwidthTimeRange) => void;
  pointCount: number;          // Raw points in buffer before decimation
  isEmpty: boolean;            // No data collected yet
  isCollecting: boolean;       // < 10 points (chart not yet meaningful)
}
```
  </action>
  <verify>
Run `npx jest lib/utils/__tests__/decimateLTTB.test.ts --passWithNoTests` — all tests pass.
Run `npx tsc --noEmit` — no new TypeScript errors from these files.
  </verify>
  <done>
LTTB algorithm correctly decimates 10080 points to 500, preserves first/last/peak/valley points, passes all 9+ test cases. Types extended with BandwidthHistoryPoint, BandwidthTimeRange, UseBandwidthHistoryReturn.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useBandwidthHistory hook with TDD</name>
  <files>
    app/network/hooks/useBandwidthHistory.ts
    app/network/hooks/__tests__/useBandwidthHistory.test.ts
  </files>
  <action>
**RED phase — Write tests first:**

Create `app/network/hooks/__tests__/useBandwidthHistory.test.ts` using `@testing-library/react` renderHook:

1. Returns empty chartData initially (isEmpty=true, isCollecting=false)
2. Accumulates data points via addDataPoint callback
3. After adding 5 points, isCollecting=true (< 10 points, chart not meaningful)
4. After adding 15 points, isCollecting=false (enough for chart)
5. Filters data by time range '1h' (only last 60 minutes)
6. Filters data by time range '24h' (only last 24 hours)
7. Filters data by time range '7d' (full 7-day buffer)
8. Decimates data when filtered result exceeds 500 points (mock 600+ points, verify output.length <= 500)
9. Does NOT decimate when filtered result <= 500 points
10. Buffer caps at 10080 points (oldest points dropped)
11. setTimeRange updates the active time range
12. Default time range is '24h'

Mock `decimateLTTB` from `@/lib/utils/decimateLTTB` to verify it gets called with correct threshold (500).

Test interface:
```typescript
import { useBandwidthHistory } from '../useBandwidthHistory';
import type { BandwidthData } from '@/app/components/devices/network/types';

// Hook returns: { chartData, timeRange, setTimeRange, addDataPoint, pointCount, isEmpty, isCollecting }
```

Run tests — they MUST fail (RED).

**GREEN phase — Implement:**

Create `app/network/hooks/useBandwidthHistory.ts`:

```typescript
'use client';

import { useState, useCallback, useMemo } from 'react';
import { decimateLTTB } from '@/lib/utils/decimateLTTB';
import type {
  BandwidthData,
  BandwidthHistoryPoint,
  BandwidthTimeRange,
  UseBandwidthHistoryReturn,
} from '@/app/components/devices/network/types';
```

Implementation:
1. `useState<BandwidthHistoryPoint[]>([])` for the history buffer
2. `useState<BandwidthTimeRange>('24h')` for time range (default 24h per research recommendation)
3. `addDataPoint(bandwidth: BandwidthData)` callback: appends `{ time: bandwidth.timestamp, download: bandwidth.download, upload: bandwidth.upload }`, caps at 10080 points via `.slice(-MAX_POINTS)`
4. `chartData` via useMemo: filter by time range cutoff, then decimate BOTH download and upload series if filtered.length > 500
   - Time range cutoffs: 1h = 3600000ms, 24h = 86400000ms, 7d = 604800000ms
   - Decimation: map to TimeSeriesPoint for each series, decimate separately, recombine into BandwidthHistoryPoint[]
   - IMPORTANT: Decimate download and upload independently (they share the same time axis, but LTTB picks different representative points per series). After decimation, merge back by using the download series timestamps as authoritative and interpolating upload values at those timestamps. Simpler approach: decimate the combined array using download as the value, then map upload from the original data at the same indices.
   - SIMPLEST approach (recommended): Decimate using download Mbps as the selection criterion (download is typically the user-relevant metric). Keep both download and upload values at the selected time indices.
5. Derived: `pointCount = history.length`, `isEmpty = history.length === 0`, `isCollecting = history.length > 0 && history.length < 10`

The hook does NOT do its own polling. It exposes `addDataPoint` which the page orchestrator calls with data from `useNetworkData().bandwidth`. This avoids duplicate polling (Pitfall 4 from research).

Run tests — they MUST pass (GREEN).
  </action>
  <verify>
Run `npx jest app/network/hooks/__tests__/useBandwidthHistory.test.ts --passWithNoTests` — all tests pass.
Run `npx tsc --noEmit` — no new TypeScript errors.
  </verify>
  <done>
useBandwidthHistory hook accumulates bandwidth data, filters by 1h/24h/7d time ranges, decimates to 500 points when needed, defaults to 24h. All 11+ tests pass. No duplicate polling — data fed via addDataPoint from page orchestrator.
  </done>
</task>

</tasks>

<verification>
1. `npx jest lib/utils/__tests__/decimateLTTB.test.ts app/network/hooks/__tests__/useBandwidthHistory.test.ts --passWithNoTests` — all tests pass
2. `npx tsc --noEmit` — no new TypeScript errors from added files
3. LTTB correctly reduces 10080 → 500 points with first/last/peak preservation
4. Hook defaults to '24h' time range, exposes addDataPoint for external data feeding
5. No new fetch() calls or polling logic (hook is passive data accumulator)
</verification>

<success_criteria>
- LTTB algorithm passes all edge cases (empty, single, threshold=2, 10080→500)
- useBandwidthHistory buffers up to 10080 points with time range filtering
- Decimation applied only when filtered data exceeds 500 points
- Hook interface matches UseBandwidthHistoryReturn type
- All tests green, TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/64-bandwidth-visualization/64-01-SUMMARY.md`
</output>
