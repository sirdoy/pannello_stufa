---
phase: 65-device-history-timeline
plan: 02
type: execute
wave: 2
depends_on: ["65-01"]
files_modified:
  - app/api/fritzbox/devices/route.ts
  - app/api/fritzbox/history/route.ts
  - app/api/fritzbox/__tests__/devices-events.test.ts
  - app/api/fritzbox/__tests__/history.test.ts
autonomous: true

must_haves:
  truths:
    - "Device state changes are detected and logged on each poll of /api/fritzbox/devices"
    - "Event logging failure does not break the devices endpoint response"
    - "History endpoint returns filtered events for a given time range"
    - "History endpoint supports optional device MAC filter"
  artifacts:
    - path: "app/api/fritzbox/devices/route.ts"
      provides: "Device polling with event detection side-effect"
      exports: ["GET"]
    - path: "app/api/fritzbox/history/route.ts"
      provides: "History query endpoint with time range and device filter"
      exports: ["GET", "dynamic"]
    - path: "app/api/fritzbox/__tests__/history.test.ts"
      provides: "Tests for history API endpoint"
      min_lines: 50
  key_links:
    - from: "app/api/fritzbox/devices/route.ts"
      to: "lib/fritzbox/deviceEventLogger.ts"
      via: "logDeviceEvent, getDeviceStates, updateDeviceStates imports"
      pattern: "logDeviceEvent|getDeviceStates|updateDeviceStates"
    - from: "app/api/fritzbox/history/route.ts"
      to: "lib/fritzbox/deviceEventLogger.ts"
      via: "getDeviceEvents import"
      pattern: "getDeviceEvents"
---

<objective>
Integrate event detection into the existing devices endpoint and create the history query API endpoint.

Purpose: The devices endpoint already polls Fritz!Box for device list. By adding state comparison logic, we detect connections/disconnections as a side-effect of existing polling. The history endpoint provides filtered access to logged events for the timeline UI.

Output: Modified `/api/fritzbox/devices/route.ts` with event detection, new `/api/fritzbox/history/route.ts` endpoint, and tests for both.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/65-device-history-timeline/65-RESEARCH.md
@.planning/phases/65-device-history-timeline/65-01-SUMMARY.md

@app/api/fritzbox/devices/route.ts
@lib/fritzbox/index.ts
@lib/fritzbox/deviceEventLogger.ts
@lib/core/apiErrors.ts
@app/components/devices/network/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add event detection to /api/fritzbox/devices endpoint</name>
  <files>
    app/api/fritzbox/devices/route.ts
    app/api/fritzbox/__tests__/devices-events.test.ts
  </files>
  <action>
    Modify the existing GET handler in `app/api/fritzbox/devices/route.ts` to detect device state changes and log events. The event detection is a **fire-and-forget side-effect** that must NEVER break the primary device list response.

    After the existing `getCachedData` call returns `devices`:

    1. Wrap event detection in a try/catch that logs errors but does NOT rethrow
    2. Call `getDeviceStates()` to get previous states from Firebase
    3. Build `currentStates` Map from current device list: `Map<string, { active: boolean; lastSeen: number }>`
    4. For each device, compare `prev.active` vs `curr.active`:
       - If no previous state exists and device is active: log `connected` event (new device)
       - If previous state exists and `prev.active !== curr.active`: log appropriate event
       - If no state change: skip (do NOT log)
    5. Call `updateDeviceStates(currentStates)` to persist current states for next poll
    6. Return existing `success({ devices })` response unchanged

    Import from `@/lib/fritzbox`: `logDeviceEvent`, `getDeviceStates`, `updateDeviceStates`

    The existing rate limit check and cache logic remain UNTOUCHED. Event detection runs AFTER cache returns devices.

    Create test file `app/api/fritzbox/__tests__/devices-events.test.ts`:
    - Mock `@/lib/fritzbox` module (fritzboxClient, getCachedData, checkRateLimitFritzBox, getDeviceStates, updateDeviceStates, logDeviceEvent)
    - Mock `@/lib/core` module (withAuthAndErrorHandler wraps handler, success returns JSON)
    - Test: new device appears -> logs `connected` event
    - Test: device goes offline -> logs `disconnected` event
    - Test: device comes online -> logs `connected` event
    - Test: no state change -> does NOT call logDeviceEvent
    - Test: event logging throws error -> devices response still returns successfully
    - Test: getDeviceStates returns empty Map -> all active devices get `connected` events
  </action>
  <verify>
    ```bash
    npx jest app/api/fritzbox/__tests__/devices-events.test.ts --verbose
    npx tsc --noEmit --project tsconfig.json 2>&1 | head -20
    ```
  </verify>
  <done>
    Device state changes detected during polling and logged to Firebase. Event detection failure never breaks device list response. Tests confirm all state transition scenarios.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /api/fritzbox/history endpoint</name>
  <files>
    app/api/fritzbox/history/route.ts
    app/api/fritzbox/__tests__/history.test.ts
  </files>
  <action>
    Create new API endpoint `app/api/fritzbox/history/route.ts`:

    ```typescript
    export const dynamic = 'force-dynamic';
    ```

    Use `withAuthAndErrorHandler` wrapper (same as other Fritz!Box endpoints).

    GET handler:
    1. Parse query params from `request.url`:
       - `range`: `'1h' | '24h' | '7d'` (default: `'24h'`)
       - `device`: optional MAC address string for filtering
    2. Calculate time window:
       - `endTime = Date.now()`
       - `startTime = endTime - getTimeRangeMs(range)`
       - Helper `getTimeRangeMs`: `'1h'` -> 3600000, `'24h'` -> 86400000, `'7d'` -> 604800000
    3. Call `getDeviceEvents(startTime, endTime)` from `@/lib/fritzbox`
    4. If `device` param provided, filter: `events.filter(e => e.deviceMac === device)`
    5. Return `success({ events, range, totalCount: events.length })`

    The endpoint label for error handler is `'FritzBox/History'`.

    Create test file `app/api/fritzbox/__tests__/history.test.ts`:
    - Mock `@/lib/fritzbox` (getDeviceEvents)
    - Mock `@/lib/core` (withAuthAndErrorHandler, success)
    - Test: default range (24h) returns events within 24h window
    - Test: range=7d calculates correct startTime
    - Test: range=1h calculates correct startTime
    - Test: device filter returns only events for that MAC
    - Test: no events returns empty array with totalCount 0
    - Test: invalid range defaults to 24h
  </action>
  <verify>
    ```bash
    npx jest app/api/fritzbox/__tests__/history.test.ts --verbose
    npx tsc --noEmit --project tsconfig.json 2>&1 | head -20
    ```
  </verify>
  <done>
    History endpoint returns device events filtered by time range and optional device MAC. Tests confirm all query parameter combinations. Response includes events array, range, and totalCount.
  </done>
</task>

</tasks>

<verification>
```bash
npx jest app/api/fritzbox/__tests__/devices-events.test.ts app/api/fritzbox/__tests__/history.test.ts --verbose
npx tsc --noEmit --project tsconfig.json 2>&1 | head -20
```
</verification>

<success_criteria>
- /api/fritzbox/devices detects and logs state changes without breaking existing functionality
- /api/fritzbox/history returns filtered events with time range and device filter support
- All tests pass
- Zero TypeScript compilation errors
- Event logging errors are caught and logged, never propagated
</success_criteria>

<output>
After completion, create `.planning/phases/65-device-history-timeline/65-02-SUMMARY.md`
</output>
