---
phase: 66-device-categorization
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - types/firebase/network.ts
  - lib/network/deviceCategories.ts
  - lib/network/vendorCache.ts
  - lib/network/__tests__/deviceCategories.test.ts
  - lib/network/__tests__/vendorCache.test.ts
autonomous: true

must_haves:
  truths:
    - "categorizeByVendor maps known vendor names to correct categories"
    - "categorizeByVendor returns 'unknown' for unrecognized vendors"
    - "Keyword matching is case-insensitive and handles partial matches"
    - "Manual override takes priority over auto-categorized result"
    - "Vendor cache stores vendor+category with 7-day TTL"
    - "MAC addresses normalized to lowercase-underscore format for Firebase keys"
  artifacts:
    - path: "types/firebase/network.ts"
      provides: "DeviceCategory type and CategoryOverride interface"
      contains: "DeviceCategory"
    - path: "lib/network/deviceCategories.ts"
      provides: "categorizeByVendor, saveCategoryOverride, getCategoryOverride, getDeviceCategory, normalizeMacForFirebase"
      exports: ["categorizeByVendor", "saveCategoryOverride", "getCategoryOverride", "getDeviceCategory", "normalizeMacForFirebase"]
    - path: "lib/network/vendorCache.ts"
      provides: "getCachedVendor, cacheVendor, fetchVendorName functions"
      exports: ["getCachedVendor", "cacheVendor", "fetchVendorName"]
  key_links:
    - from: "lib/network/deviceCategories.ts"
      to: "types/firebase/network.ts"
      via: "imports DeviceCategory type"
      pattern: "import.*DeviceCategory.*from.*types/firebase/network"
    - from: "lib/network/deviceCategories.ts"
      to: "lib/firebaseAdmin.ts"
      via: "Firebase RTDB reads/writes for overrides"
      pattern: "adminDb(Get|Set|Update)"
    - from: "lib/network/vendorCache.ts"
      to: "lib/firebaseAdmin.ts"
      via: "Firebase RTDB cache storage"
      pattern: "adminDb(Get|Set)"
---

<objective>
Create the device categorization foundation: DeviceCategory types, vendor-to-category mapping heuristics, Firebase RTDB vendor cache (7-day TTL), and manual override persistence layer.

Purpose: Provides the business logic and data layer that API routes (Plan 02) and UI components (Plan 03) build upon. TDD approach ensures categorization heuristics are correct before integration.

Output: Types, category mapping logic, vendor cache, override storage -- all with comprehensive tests.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/66-device-categorization/66-RESEARCH.md

# Key existing files
@app/components/devices/network/types.ts
@lib/fritzbox/fritzboxCache.ts
@lib/firebaseAdmin.ts
@lib/environmentHelper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: DeviceCategory types and categorizeByVendor logic with TDD</name>
  <files>
    types/firebase/network.ts
    lib/network/deviceCategories.ts
    lib/network/__tests__/deviceCategories.test.ts
  </files>
  <action>
**RED phase — write tests first:**

Create `lib/network/__tests__/deviceCategories.test.ts` with tests for:

1. `categorizeByVendor(vendor)` function:
   - `'Apple, Inc.'` → `'mobile'`
   - `'Samsung Electronics Co.,Ltd'` → `'mobile'`
   - `'Raspberry Pi Trading Ltd'` → `'iot'`
   - `'Espressif Inc.'` → `'iot'`
   - `'AVM GmbH'` → `'smart-home'`
   - `'TP-Link Technologies Co., Ltd.'` → `'smart-home'`
   - `'Philips Lighting BV'` → `'smart-home'`
   - `'Dell Inc.'` → `'pc'`
   - `'Intel Corporate'` → `'pc'`
   - `'HP Inc.'` → `'pc'`
   - `'SomeUnknownVendor'` → `'unknown'`
   - `null` → `'unknown'`
   - `''` → `'unknown'`
   - Case insensitive: `'APPLE, INC.'` → `'mobile'`
   - Partial match: `'Espressif Systems'` → `'iot'` (matches 'Espressif' keyword)

2. `normalizeMacForFirebase(mac)` function:
   - `'AA:BB:CC:DD:EE:FF'` → `'aa_bb_cc_dd_ee_ff'`
   - `'aa:bb:cc:dd:ee:ff'` → `'aa_bb_cc_dd_ee_ff'`
   - `'AA-BB-CC-DD-EE-FF'` → `'aa_bb_cc_dd_ee_ff'`

3. `saveCategoryOverride(mac, category)` function:
   - Calls `adminDbUpdate` with path `network/deviceCategories/{normalized_mac}`
   - Stores `{ category, overriddenAt: number, isManualOverride: true }`

4. `getCategoryOverride(mac)` function:
   - Returns stored category when override exists
   - Returns `null` when no override exists

5. `getDeviceCategory(mac, vendorCache)` function:
   - Returns manual override if exists (priority 1)
   - Returns vendor cache category if exists (priority 2)
   - Returns `'unknown'` as fallback (priority 3)

**GREEN phase — implement:**

Create `types/firebase/network.ts`:
```typescript
export type DeviceCategory = 'iot' | 'mobile' | 'pc' | 'smart-home' | 'unknown';

export interface CategoryOverride {
  category: DeviceCategory;
  overriddenAt: number;
  isManualOverride: boolean;
}

export interface VendorCacheEntry {
  vendor: string;
  category: DeviceCategory;
  timestamp: number;
}
```

Create `lib/network/deviceCategories.ts` with:
- `CATEGORY_MAPPINGS` object mapping vendor keywords to DeviceCategory
- `categorizeByVendor(vendor: string | null): DeviceCategory` — checks null/empty, tries exact match then case-insensitive includes
- `normalizeMacForFirebase(mac: string): string` — lowercase, replace colons AND dashes with underscores
- `saveCategoryOverride(mac: string, category: DeviceCategory): Promise<void>` — uses `adminDbUpdate` to store at `network/deviceCategories/{normalizedMac}` via `getEnvironmentPath`
- `getCategoryOverride(mac: string): Promise<DeviceCategory | null>` — reads from Firebase, returns category or null
- `getDeviceCategory(mac: string, cachedCategory?: DeviceCategory | null): Promise<DeviceCategory>` — checks override first, then cachedCategory param, then returns 'unknown'

Mock `@/lib/firebaseAdmin` and `@/lib/environmentHelper` in tests. Use `jest.mocked()` pattern for type-safe mocks (existing project convention).

Italian locale: category labels handled in UI (Plan 03), not in this logic layer.
  </action>
  <verify>
Run `npx jest lib/network/__tests__/deviceCategories.test.ts` — all tests pass. Run `npx tsc --noEmit` — no new TypeScript errors from types/firebase/network.ts or lib/network/deviceCategories.ts.
  </verify>
  <done>
categorizeByVendor correctly maps 10+ vendor strings to categories, handles null/empty/unknown, and does case-insensitive partial matching. Override storage reads/writes Firebase at correct paths. getDeviceCategory respects priority chain (override > cache > unknown).
  </done>
</task>

<task type="auto">
  <name>Task 2: Vendor cache layer with 7-day TTL and TDD</name>
  <files>
    lib/network/vendorCache.ts
    lib/network/__tests__/vendorCache.test.ts
  </files>
  <action>
**RED phase — write tests first:**

Create `lib/network/__tests__/vendorCache.test.ts` with tests for:

1. `getCachedVendor(mac)`:
   - Returns cached entry when within 7-day TTL
   - Returns `null` when cache expired (>7 days)
   - Returns `null` when no cache entry exists
   - Uses normalized MAC for Firebase path: `network/vendorCache/{normalized_mac}`

2. `cacheVendor(mac, entry)`:
   - Stores vendor, category, timestamp at correct Firebase path
   - Uses normalized MAC for Firebase key

3. `fetchVendorName(mac)`:
   - Makes GET request to `https://api.macvendors.com/{mac}`
   - Returns vendor string on 200 response
   - Returns `null` on 404 (unknown MAC)
   - Returns `null` on network error (does NOT throw)
   - Returns `null` on non-200 response

**GREEN phase — implement:**

Create `lib/network/vendorCache.ts`:

```typescript
import { adminDbGet, adminDbSet } from '@/lib/firebaseAdmin';
import { getEnvironmentPath } from '@/lib/environmentHelper';
import { normalizeMacForFirebase } from './deviceCategories';
import type { VendorCacheEntry } from '@/types/firebase/network';

/** Vendor cache TTL: 7 days in milliseconds */
export const VENDOR_CACHE_TTL_MS = 7 * 24 * 60 * 60 * 1000;

export async function getCachedVendor(mac: string): Promise<VendorCacheEntry | null> {
  const normalizedMac = normalizeMacForFirebase(mac);
  const path = getEnvironmentPath(`network/vendorCache/${normalizedMac}`);
  const cached = (await adminDbGet(path)) as VendorCacheEntry | null;

  if (cached && cached.timestamp && (Date.now() - cached.timestamp < VENDOR_CACHE_TTL_MS)) {
    return cached;
  }
  return null;
}

export async function cacheVendor(mac: string, entry: VendorCacheEntry): Promise<void> {
  const normalizedMac = normalizeMacForFirebase(mac);
  const path = getEnvironmentPath(`network/vendorCache/${normalizedMac}`);
  await adminDbSet(path, entry);
}

export async function fetchVendorName(mac: string): Promise<string | null> {
  try {
    const response = await fetch(`https://api.macvendors.com/${encodeURIComponent(mac)}`);
    if (response.ok) {
      return await response.text();
    }
    return null;
  } catch {
    return null;
  }
}
```

Mock `@/lib/firebaseAdmin`, `@/lib/environmentHelper`, and global `fetch` in tests. Use `jest.mocked()` for type-safe mocks.

Note: `fetchVendorName` uses global `fetch` (available in Next.js API routes). It never throws — returns null on any error, consistent with resilient fire-and-forget pattern.
  </action>
  <verify>
Run `npx jest lib/network/__tests__/vendorCache.test.ts` — all tests pass. Run `npx jest lib/network/__tests__/` — both test suites pass together. Run `npx tsc --noEmit` — no new errors.
  </verify>
  <done>
Vendor cache reads/writes Firebase with 7-day TTL. fetchVendorName calls macvendors.com API and handles errors gracefully (returns null, never throws). Both cache and fetch functions use normalized MAC addresses.
  </done>
</task>

</tasks>

<verification>
1. `npx jest lib/network/__tests__/ --verbose` — all tests green
2. `npx tsc --noEmit` — no new TypeScript errors from new files
3. `types/firebase/network.ts` exports DeviceCategory, CategoryOverride, VendorCacheEntry
4. `lib/network/deviceCategories.ts` exports categorizeByVendor, normalizeMacForFirebase, saveCategoryOverride, getCategoryOverride, getDeviceCategory
5. `lib/network/vendorCache.ts` exports getCachedVendor, cacheVendor, fetchVendorName
</verification>

<success_criteria>
- All categorization tests pass with correct vendor-to-category mappings
- Vendor cache respects 7-day TTL
- Firebase paths use normalized MAC addresses (lowercase, underscores)
- Manual override priority chain works: override > cache > unknown
- fetchVendorName handles all error cases without throwing
</success_criteria>

<output>
After completion, create `.planning/phases/66-device-categorization/66-01-SUMMARY.md`
</output>
