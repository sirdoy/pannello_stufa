---
phase: 66-device-categorization
plan: 02
type: execute
wave: 2
depends_on: ["66-01"]
files_modified:
  - app/api/network/vendor-lookup/route.ts
  - app/api/network/category-override/route.ts
  - app/api/network/vendor-lookup/__tests__/route.test.ts
  - app/api/network/category-override/__tests__/route.test.ts
autonomous: true

must_haves:
  truths:
    - "Vendor lookup API returns vendor name and auto-assigned category for a MAC address"
    - "Vendor lookup checks Firebase cache before calling macvendors.com"
    - "Category override API persists user's manual category choice in Firebase"
    - "Both endpoints require Auth0 authentication"
    - "Vendor lookup returns cached:true flag when result came from cache"
  artifacts:
    - path: "app/api/network/vendor-lookup/route.ts"
      provides: "GET endpoint for MAC vendor lookup with caching"
      exports: ["GET", "dynamic"]
    - path: "app/api/network/category-override/route.ts"
      provides: "POST endpoint for manual category override"
      exports: ["POST", "dynamic"]
    - path: "app/api/network/vendor-lookup/__tests__/route.test.ts"
      provides: "Vendor lookup route tests"
      min_lines: 50
    - path: "app/api/network/category-override/__tests__/route.test.ts"
      provides: "Category override route tests"
      min_lines: 40
  key_links:
    - from: "app/api/network/vendor-lookup/route.ts"
      to: "lib/network/vendorCache.ts"
      via: "imports getCachedVendor, cacheVendor, fetchVendorName"
      pattern: "import.*from.*lib/network/vendorCache"
    - from: "app/api/network/vendor-lookup/route.ts"
      to: "lib/network/deviceCategories.ts"
      via: "imports categorizeByVendor"
      pattern: "import.*categorizeByVendor.*from.*lib/network/deviceCategories"
    - from: "app/api/network/category-override/route.ts"
      to: "lib/network/deviceCategories.ts"
      via: "imports saveCategoryOverride"
      pattern: "import.*saveCategoryOverride.*from.*lib/network/deviceCategories"
---

<objective>
Create two API routes: vendor-lookup (GET) for MAC-to-vendor resolution with Firebase caching, and category-override (POST) for persisting manual category changes.

Purpose: Exposes categorization logic from Plan 01 as authenticated API endpoints for the UI (Plan 03) to consume. Follows established Fritz!Box API proxy pattern.

Output: Two authenticated API routes with full test coverage.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/66-device-categorization/66-RESEARCH.md
@.planning/phases/66-device-categorization/66-01-SUMMARY.md

# Key existing files for pattern reference
@app/api/fritzbox/devices/route.ts
@lib/core/middleware.ts
@lib/core/apiErrors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Vendor lookup and category override API routes</name>
  <files>
    app/api/network/vendor-lookup/route.ts
    app/api/network/category-override/route.ts
  </files>
  <action>
Create `app/api/network/vendor-lookup/route.ts`:

```typescript
import { withAuthAndErrorHandler, success, ApiError, ERROR_CODES, HTTP_STATUS } from '@/lib/core';
import { getCachedVendor, cacheVendor, fetchVendorName } from '@/lib/network/vendorCache';
import { categorizeByVendor } from '@/lib/network/deviceCategories';

export const dynamic = 'force-dynamic';

export const GET = withAuthAndErrorHandler(async (request) => {
  const { searchParams } = new URL(request.url);
  const mac = searchParams.get('mac');

  if (!mac) {
    throw new ApiError(ERROR_CODES.VALIDATION_ERROR, 'Indirizzo MAC richiesto', HTTP_STATUS.BAD_REQUEST);
  }

  // 1. Check vendor cache (7-day TTL)
  const cached = await getCachedVendor(mac);
  if (cached) {
    return success({ vendor: cached.vendor, category: cached.category, cached: true });
  }

  // 2. Fetch from macvendors.com (returns null on error/not-found)
  const vendor = await fetchVendorName(mac);

  // 3. Categorize
  const category = categorizeByVendor(vendor);

  // 4. Cache result (even 'unknown' to avoid repeated lookups)
  await cacheVendor(mac, { vendor: vendor ?? '', category, timestamp: Date.now() });

  return success({ vendor: vendor ?? '', category, cached: false });
}, 'Network/VendorLookup');
```

Create `app/api/network/category-override/route.ts`:

```typescript
import { withAuthAndErrorHandler, success, ApiError, ERROR_CODES, HTTP_STATUS } from '@/lib/core';
import { saveCategoryOverride } from '@/lib/network/deviceCategories';
import type { DeviceCategory } from '@/types/firebase/network';

export const dynamic = 'force-dynamic';

const VALID_CATEGORIES: DeviceCategory[] = ['iot', 'mobile', 'pc', 'smart-home', 'unknown'];

export const POST = withAuthAndErrorHandler(async (request) => {
  const body = await request.json() as { mac?: string; category?: string };

  if (!body.mac) {
    throw new ApiError(ERROR_CODES.VALIDATION_ERROR, 'Indirizzo MAC richiesto', HTTP_STATUS.BAD_REQUEST);
  }

  if (!body.category || !VALID_CATEGORIES.includes(body.category as DeviceCategory)) {
    throw new ApiError(
      ERROR_CODES.VALIDATION_ERROR,
      `Categoria non valida. Valori ammessi: ${VALID_CATEGORIES.join(', ')}`,
      HTTP_STATUS.BAD_REQUEST
    );
  }

  await saveCategoryOverride(body.mac, body.category as DeviceCategory);

  return success({ mac: body.mac, category: body.category, saved: true });
}, 'Network/CategoryOverride');
```

Both routes use `withAuthAndErrorHandler` for Auth0 authentication and RFC 9457 error handling. Italian error messages consistent with existing Fritz!Box routes. No rate limiting needed on these routes (category lookups are rare operations, not polled).

Note: The vendor-lookup route does NOT use `checkRateLimitFritzBox` because macvendors.com rate limits are handled by the 7-day cache (a home network with 20-30 devices will only do initial lookups once per week). If rate limit becomes a concern, add it later.
  </action>
  <verify>
Run `npx tsc --noEmit` — no new TypeScript errors from route files. Verify files exist: `ls app/api/network/vendor-lookup/route.ts app/api/network/category-override/route.ts`.
  </verify>
  <done>
Vendor lookup route resolves MAC→vendor→category with 7-day cache. Category override route validates and persists manual category to Firebase. Both require Auth0 authentication with Italian error messages.
  </done>
</task>

<task type="auto">
  <name>Task 2: API route unit tests</name>
  <files>
    app/api/network/vendor-lookup/__tests__/route.test.ts
    app/api/network/category-override/__tests__/route.test.ts
  </files>
  <action>
Create `app/api/network/vendor-lookup/__tests__/route.test.ts` following the pattern from `app/api/fritzbox/devices/__tests__/route.test.ts`:

**Tests (7 tests):**
1. Returns 401 when not authenticated
2. Returns 400 when MAC parameter missing
3. Returns 200 with cached vendor and `cached: true` when cache hit
4. Returns 200 with fresh vendor and `cached: false` when cache miss — verifies fetchVendorName called, categorizeByVendor called, cacheVendor called
5. Returns category 'unknown' when fetchVendorName returns null (unknown MAC)
6. Caches even unknown results (to prevent repeated API calls)
7. Handles fetchVendorName failure gracefully (returns 'unknown' category)

Mock: `@/lib/network/vendorCache` (getCachedVendor, cacheVendor, fetchVendorName), `@/lib/network/deviceCategories` (categorizeByVendor), `@/lib/auth0`.

Create `app/api/network/category-override/__tests__/route.test.ts`:

**Tests (5 tests):**
1. Returns 401 when not authenticated
2. Returns 400 when MAC missing from body
3. Returns 400 when category is invalid (e.g., 'laptop')
4. Returns 200 and calls saveCategoryOverride with correct args on valid request
5. Returns saved:true confirmation in response

Mock: `@/lib/network/deviceCategories` (saveCategoryOverride), `@/lib/auth0`.

Follow existing test pattern:
- Mock console.error/console.warn with `jest.fn()`
- Use `jest.mocked()` for type-safe mock access
- Create `NextRequest` with URL for GET params or JSON body for POST
- Parse response with `response.json()`
  </action>
  <verify>
Run `npx jest app/api/network/ --verbose` — all 12 tests pass. Run `npx jest app/api/network/ app/api/fritzbox/` — no regressions in existing Fritz!Box route tests.
  </verify>
  <done>
12 tests covering both API routes: authentication, validation, cache behavior, error handling. All existing Fritz!Box tests unaffected.
  </done>
</task>

</tasks>

<verification>
1. `npx jest app/api/network/ --verbose` — all route tests pass
2. `npx tsc --noEmit` — no new TypeScript errors
3. Vendor lookup route returns cached:true/false flag
4. Category override route validates category against whitelist
5. Both routes require Auth0 authentication (401 without session)
</verification>

<success_criteria>
- Vendor lookup returns vendor name + category for any MAC address
- Cache hit returns result without calling macvendors.com
- Category override persists valid categories to Firebase
- Invalid categories rejected with 400 and Italian message
- All 12 tests passing with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/66-device-categorization/66-02-SUMMARY.md`
</output>
