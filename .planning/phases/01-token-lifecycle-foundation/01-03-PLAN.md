---
phase: 01-token-lifecycle-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - app/api/notifications/register/route.js
  - lib/notificationService.js
autonomous: true

must_haves:
  truths:
    - "Registration includes device fingerprint with deviceId"
    - "Same device re-registering replaces existing token (no duplicates)"
    - "Token stored locally via tokenStorage after registration"
    - "Multi-device: different devices create separate entries"
  artifacts:
    - path: "app/api/notifications/register/route.js"
      provides: "Enhanced registration with device deduplication"
      contains: "deviceId"
    - path: "lib/notificationService.js"
      provides: "Updated getFCMToken using tokenStorage + deviceFingerprint"
  key_links:
    - from: "lib/notificationService.js"
      to: "lib/tokenStorage.js"
      via: "import { saveToken, loadToken }"
      pattern: "import.*saveToken.*from.*tokenStorage"
    - from: "lib/notificationService.js"
      to: "lib/deviceFingerprint.js"
      via: "import { generateDeviceFingerprint }"
      pattern: "import.*generateDeviceFingerprint.*from.*deviceFingerprint"
    - from: "app/api/notifications/register/route.js"
      to: "Firebase query by deviceId"
      via: "orderByChild('deviceId').equalTo"
      pattern: "orderByChild.*deviceId"
---

<objective>
Enhance token registration to support device deduplication and local persistence.

Purpose: Implement TOKEN-05 (multi-device) and TOKEN-06 (device fingerprinting) with duplicate prevention. When same device re-registers, replace existing token instead of creating duplicate entry.

Output: Updated register API and notificationService that use tokenStorage and deviceFingerprint modules.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-token-lifecycle-foundation/01-RESEARCH.md
@.planning/phases/01-token-lifecycle-foundation/01-01-SUMMARY.md
@.planning/phases/01-token-lifecycle-foundation/01-02-SUMMARY.md
@lib/notificationService.js
@app/api/notifications/register/route.js
@lib/firebaseAdmin.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update register API with device deduplication</name>
  <files>app/api/notifications/register/route.js</files>
  <action>
Update the register route to:
1. Accept deviceId and deviceInfo from request body
2. Query existing tokens by deviceId
3. Replace existing token if same device, otherwise create new entry
4. Store richer metadata (deviceInfo, deviceId, displayName)

Replace the entire route file with enhanced version:

```javascript
/**
 * API Route: Register FCM Token
 *
 * POST /api/notifications/register
 *
 * Registra un FCM token per l'utente autenticato.
 * Supporta multi-device con deduplicazione per deviceId.
 *
 * Body:
 * {
 *   token: "FCM_TOKEN_STRING",
 *   deviceId: "abc123...",              // Stable device identifier
 *   displayName: "Chrome on Windows",   // Human-readable name
 *   deviceInfo: { browser, os, ... },   // Full device metadata
 *   userAgent: "Mozilla/5.0...",        // Raw UA string
 *   platform: "ios|other",
 *   isPWA: true|false
 * }
 */

import {
  withAuthAndErrorHandler,
  success,
  parseJsonOrThrow,
  validateRequired,
} from '@/lib/core';
import { getAdminDatabase } from '@/lib/firebaseAdmin';

export const dynamic = 'force-dynamic';

/**
 * Sanitize FCM token for use as Firebase key
 * Firebase paths cannot contain: . $ # [ ] /
 */
function sanitizeFirebaseKey(token) {
  return token
    .replace(/\./g, '_DOT_')
    .replace(/\$/g, '_DOL_')
    .replace(/#/g, '_HSH_')
    .replace(/\[/g, '_LBR_')
    .replace(/\]/g, '_RBR_')
    .replace(/\//g, '_SLS_');
}

/**
 * POST /api/notifications/register
 * Register FCM token for user with device deduplication
 * Protected: Requires Auth0 authentication
 */
export const POST = withAuthAndErrorHandler(async (request, context, session) => {
  const userId = session.user.sub;
  const body = await parseJsonOrThrow(request);
  const { token, deviceId, displayName, deviceInfo, userAgent, platform, isPWA } = body;

  // Validate required field
  validateRequired(token, 'token');

  const db = getAdminDatabase();
  const tokensRef = db.ref(`users/${userId}/fcmTokens`);
  const now = new Date().toISOString();

  // If deviceId provided, check for existing device and replace
  if (deviceId) {
    // Query for existing token with same deviceId
    const snapshot = await tokensRef
      .orderByChild('deviceId')
      .equalTo(deviceId)
      .once('value');

    if (snapshot.exists()) {
      // Device exists - update the existing entry
      const existingData = snapshot.val();
      const existingKey = Object.keys(existingData)[0];

      await tokensRef.child(existingKey).update({
        token,
        lastUsed: now,
        userAgent: userAgent || 'unknown',
        platform: platform || 'other',
        isPWA: isPWA || false,
        // Preserve createdAt from original registration
        // Update deviceInfo in case browser version changed
        deviceInfo: deviceInfo || existingData[existingKey].deviceInfo,
        displayName: displayName || existingData[existingKey].displayName,
      });

      console.log(`FCM token updated for device ${deviceId} (user ${userId})`);

      return success({
        message: 'Token FCM aggiornato con successo',
        token,
        deviceId,
        action: 'updated',
      });
    }
  }

  // New device or no deviceId provided - create new entry
  const tokenData = {
    token,
    createdAt: now,
    lastUsed: now,
    deviceId: deviceId || null,
    displayName: displayName || 'Unknown device',
    deviceInfo: deviceInfo || null,
    userAgent: userAgent || 'unknown',
    platform: platform || 'other',
    isPWA: isPWA || false,
  };

  // Use token hash as key (sanitized)
  const tokenKey = sanitizeFirebaseKey(token);
  await tokensRef.child(tokenKey).set(tokenData);

  console.log(`FCM token registrato per nuovo device ${deviceId || 'unknown'} (user ${userId})`);

  return success({
    message: 'Token FCM registrato con successo',
    token,
    deviceId,
    action: 'created',
  });
}, 'Notifications/Register');
```

Key changes:
- Accepts deviceId, displayName, deviceInfo from body
- Queries by deviceId to find existing device
- Updates existing entry if same device (preserves createdAt)
- Creates new entry only for new devices
- Returns action: 'updated' or 'created' for client awareness
  </action>
  <verify>
1. File syntax valid
2. Route exports POST handler
3. Contains deviceId handling logic
4. Contains orderByChild query for deduplication
  </verify>
  <done>
Register route updated with device deduplication. Same deviceId replaces existing token, different deviceId creates new entry.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update notificationService to use new modules</name>
  <files>lib/notificationService.js</files>
  <action>
Update notificationService.js to:
1. Import and use tokenStorage for persistence
2. Import and use deviceFingerprint for device identification
3. Save token locally after successful registration
4. Load existing token on startup before requesting new one

Add imports at the top (after existing imports):
```javascript
import { saveToken, loadToken, updateLastUsed } from './tokenStorage';
import { generateDeviceFingerprint } from './deviceFingerprint';
```

Update getFCMToken function to:
1. Generate device fingerprint
2. Check for existing local token
3. Save token locally after successful API registration
4. Pass deviceId and deviceInfo to register API

Replace the getFCMToken function with this enhanced version:

```javascript
/**
 * Ottiene il FCM token per questo dispositivo
 * e lo salva su Firebase tramite API
 *
 * Enhanced with:
 * - Local persistence (IndexedDB + localStorage)
 * - Device fingerprinting for multi-device support
 * - Token refresh awareness (see tokenRefresh.js)
 */
export async function getFCMToken(userId) {
  // Ottieni VAPID key al momento dell'uso
  const vapidKey = getVapidKey();

  // Generate device fingerprint first
  const fingerprint = generateDeviceFingerprint(navigator.userAgent);
  const { deviceId, displayName, deviceInfo } = fingerprint;

  // Raccogli info ambiente per debug
  const envInfo = {
    NODE_ENV: process.env.NODE_ENV || 'unknown',
    NEXT_PUBLIC_vars: typeof window !== 'undefined'
      ? Object.keys(process.env || {}).filter(k => k.startsWith('NEXT_PUBLIC_'))
      : 'SSR',
    hostname: typeof window !== 'undefined' ? window.location.hostname : 'SSR',
    protocol: typeof window !== 'undefined' ? window.location.protocol : 'SSR',
  };

  // Log diagnostico iniziale
  await debugLog('getFCMToken chiamato', {
    userId: userId ? 'presente' : 'mancante',
    VAPID_KEY_exists: !!vapidKey,
    VAPID_KEY_length: vapidKey?.length || 0,
    VAPID_KEY_preview: vapidKey ? `${vapidKey.substring(0, 10)}...` : 'undefined',
    deviceId,
    displayName,
    environment: envInfo,
    browser: {
      isIOS: isIOS(),
      isPWA: isPWA(),
      notificationSupported: isNotificationSupported(),
      permission: typeof Notification !== 'undefined' ? Notification.permission : 'N/A',
    },
  });

  if (!userId) {
    await debugLog('Errore: userId mancante');
    throw new Error('User ID richiesto per ottenere FCM token');
  }

  if (!vapidKey) {
    await debugLog('Errore: VAPID_KEY mancante - CONFIGURAZIONE AMBIENTE', {
      environment: envInfo,
      expectedVar: 'NEXT_PUBLIC_FIREBASE_VAPID_KEY',
      message: 'La variabile ambiente non è configurata nel deployment. Controlla Vercel/hosting env vars.',
    });
    console.error('VAPID key non configurata. Aggiungi NEXT_PUBLIC_FIREBASE_VAPID_KEY al .env');
    throw new Error('Configurazione notifiche mancante');
  }

  try {
    // Verifica permesso
    await debugLog('Richiesta permesso notifiche...');
    const permission = await requestNotificationPermission();
    await debugLog('Permesso ottenuto', { permission });

    if (permission !== 'granted') {
      throw new Error('Permesso notifiche non concesso');
    }

    // Ottieni messaging instance
    await debugLog('Getting messaging instance...');
    const messaging = getMessaging();

    // Ottieni registration service worker con timeout
    await debugLog('Waiting for service worker...');

    const isDev = process.env.NODE_ENV === 'development';

    // Helper: attendi SW ready con timeout
    const waitForServiceWorker = async (timeoutMs = 10000) => {
      const existingReg = await navigator.serviceWorker.getRegistration();
      if (existingReg?.active) {
        await debugLog('SW esistente trovato e attivo');
        return existingReg;
      }

      if (isDev) {
        await debugLog('Dev mode: SW non pronto, provo senza SW registration');
        return null;
      }

      await debugLog('Nessun SW attivo, tentativo registrazione...');
      try {
        const newReg = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
        await debugLog('SW registrato', { scope: newReg.scope });

        if (newReg.installing || newReg.waiting) {
          await new Promise((resolve, reject) => {
            const sw = newReg.installing || newReg.waiting;
            const timeout = setTimeout(() => reject(new Error('SW activation timeout')), timeoutMs);

            sw.addEventListener('statechange', () => {
              if (sw.state === 'activated') {
                clearTimeout(timeout);
                resolve();
              }
            });
          });
        }

        return newReg;
      } catch (regError) {
        await debugLog('Errore registrazione SW', { error: regError.message });
        throw regError;
      }
    };

    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Service Worker non disponibile (timeout 15s). Ricarica la pagina.')), 15000);
    });

    const registration = await Promise.race([
      waitForServiceWorker(),
      timeoutPromise,
    ]);

    if (registration) {
      await debugLog('Service worker ready', {
        scope: registration.scope,
        active: !!registration.active,
      });
    } else {
      await debugLog('Proceeding without SW registration (dev mode)');
    }

    // Ottieni token FCM
    await debugLog('Getting FCM token...', { vapidKeyLength: vapidKey.length, hasRegistration: !!registration });

    const getTokenOptions = { vapidKey };
    if (registration) {
      getTokenOptions.serviceWorkerRegistration = registration;
    }

    const token = await getToken(messaging, getTokenOptions);

    if (!token) {
      await debugLog('Errore: token FCM nullo');
      throw new Error('Impossibile ottenere FCM token');
    }

    await debugLog('Token FCM ottenuto', { tokenPreview: token.substring(0, 20) + '...' });

    // Salva token su Firebase tramite API (con deviceId per deduplicazione)
    const response = await fetch('/api/notifications/register', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        token,
        deviceId,
        displayName,
        deviceInfo,
        userAgent: navigator.userAgent,
        platform: isIOS() ? 'ios' : 'other',
        isPWA: isPWA(),
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      await debugLog('Errore registrazione token', { error });
      throw new Error(error.message || 'Impossibile registrare token');
    }

    const result = await response.json();
    await debugLog('FCM token salvato con successo', { action: result.action });

    // Save token locally for persistence across browser restarts
    await saveToken(token, {
      deviceId,
      deviceInfo,
      createdAt: new Date().toISOString(),
    });
    await debugLog('Token salvato in local storage');

    console.log('✅ FCM token salvato:', token);
    return token;

  } catch (error) {
    await debugLog('Errore getFCMToken', {
      error: error.message,
      stack: error.stack?.substring(0, 500),
    });
    console.error('❌ Errore ottenimento FCM token:', error);
    throw error;
  }
}
```

The key additions:
1. Import tokenStorage and deviceFingerprint at top
2. Generate fingerprint at start of getFCMToken
3. Pass deviceId, displayName, deviceInfo to register API
4. Call saveToken() after successful registration
  </action>
  <verify>
1. File has imports for tokenStorage and deviceFingerprint
2. getFCMToken generates fingerprint
3. getFCMToken passes deviceId to register API
4. getFCMToken calls saveToken after registration
5. Run `npm test` - should pass
  </verify>
  <done>
notificationService.js updated to use tokenStorage for local persistence and deviceFingerprint for device identification. Registration now includes deviceId for deduplication.
  </done>
</task>

</tasks>

<verification>
1. Register API handles deviceId and performs deduplication
2. notificationService imports and uses new modules
3. Token saved locally after registration
4. `npm test` passes (no regressions)
</verification>

<success_criteria>
- Register API deduplicates by deviceId (same device = update, not create)
- notificationService uses tokenStorage and deviceFingerprint
- Multi-device support: different devices create separate entries
- No breaking changes to existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/01-token-lifecycle-foundation/01-03-SUMMARY.md`
</output>
