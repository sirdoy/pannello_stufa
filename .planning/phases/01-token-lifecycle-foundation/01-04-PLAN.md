---
phase: 01-token-lifecycle-foundation
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - lib/tokenRefresh.js
autonomous: true

must_haves:
  truths:
    - "Token age is checked on app startup"
    - "Tokens older than 30 days trigger refresh flow"
    - "Refresh explicitly deletes old token before getting new one"
    - "New token is saved both locally and to server"
  artifacts:
    - path: "lib/tokenRefresh.js"
      provides: "Token refresh logic with 30-day check"
      exports: ["checkAndRefreshToken", "shouldRefreshToken"]
      min_lines: 80
  key_links:
    - from: "lib/tokenRefresh.js"
      to: "lib/tokenStorage.js"
      via: "import { loadToken, saveToken }"
      pattern: "import.*loadToken.*from.*tokenStorage"
    - from: "lib/tokenRefresh.js"
      to: "firebase/messaging"
      via: "deleteToken, getToken"
      pattern: "import.*deleteToken.*from.*firebase/messaging"
---

<objective>
Create token refresh module to handle 30-day token refresh cycle.

Purpose: Implement TOKEN-02 (token refresh on app startup). Firebase recommends monthly token refresh to maintain deliverability. Old tokens should be explicitly deleted before getting new ones.

Output: `lib/tokenRefresh.js` module with startup check and refresh logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-token-lifecycle-foundation/01-RESEARCH.md
@.planning/phases/01-token-lifecycle-foundation/01-01-SUMMARY.md
@.planning/phases/01-token-lifecycle-foundation/01-02-SUMMARY.md
@lib/tokenStorage.js
@lib/deviceFingerprint.js
@lib/notificationService.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tokenRefresh.js module</name>
  <files>lib/tokenRefresh.js</files>
  <action>
Create new file `lib/tokenRefresh.js` implementing token refresh logic:

```javascript
/**
 * Token Refresh - Proactive token refresh for FCM
 *
 * Firebase recommends monthly token refresh to maintain deliverability.
 * This module checks token age on app startup and refreshes if >30 days old.
 */

import { getMessaging, getToken, deleteToken } from 'firebase/messaging';
import { loadToken, saveToken, getTokenAge, updateLastUsed } from './tokenStorage';
import { getCurrentDeviceFingerprint } from './deviceFingerprint';

// Refresh tokens older than 30 days
const REFRESH_THRESHOLD_DAYS = 30;

/**
 * Check if token should be refreshed based on age
 * @returns {Promise<boolean>} true if token needs refresh
 */
export async function shouldRefreshToken() {
  const age = await getTokenAge();

  if (age === null) {
    // No token stored - needs fresh registration, not refresh
    return false;
  }

  return age > REFRESH_THRESHOLD_DAYS;
}

/**
 * Get VAPID key (duplicated from notificationService to avoid circular deps)
 */
function getVapidKey() {
  return process.env.NEXT_PUBLIC_FIREBASE_VAPID_KEY;
}

/**
 * Debug logger (duplicated to avoid circular deps)
 */
async function debugLog(message, data = {}) {
  try {
    await fetch('/api/debug/log', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        category: 'tokenRefresh',
        message,
        data: {
          ...data,
          timestamp: new Date().toISOString(),
        },
      }),
    });
  } catch (e) {
    console.error('[tokenRefresh] debugLog failed:', e);
  }
}

/**
 * Check token age and refresh if necessary
 *
 * Called on app startup to ensure token freshness.
 * Does NOT request new permissions - only refreshes existing valid token.
 *
 * @param {string} userId - User ID for server registration
 * @returns {Promise<{refreshed: boolean, token: string|null, error?: string}>}
 */
export async function checkAndRefreshToken(userId) {
  if (typeof window === 'undefined') {
    return { refreshed: false, token: null, error: 'SSR' };
  }

  // Check if notification permission is granted
  if (Notification.permission !== 'granted') {
    return { refreshed: false, token: null, error: 'No permission' };
  }

  try {
    // Load existing token from storage
    const stored = await loadToken();

    if (!stored?.token) {
      await debugLog('No stored token found, skipping refresh');
      return { refreshed: false, token: null, error: 'No stored token' };
    }

    // Calculate token age
    const age = await getTokenAge();
    await debugLog('Token age check', { ageDays: age?.toFixed(1), threshold: REFRESH_THRESHOLD_DAYS });

    if (age !== null && age <= REFRESH_THRESHOLD_DAYS) {
      // Token is fresh enough, just update lastUsed
      await updateLastUsed();
      await debugLog('Token is fresh, updated lastUsed');
      return { refreshed: false, token: stored.token };
    }

    // Token needs refresh
    await debugLog('Token needs refresh', { ageDays: age?.toFixed(1) });

    const vapidKey = getVapidKey();
    if (!vapidKey) {
      return { refreshed: false, token: stored.token, error: 'No VAPID key' };
    }

    const messaging = getMessaging();

    // Step 1: Delete the old token (explicit revocation)
    try {
      await deleteToken(messaging);
      await debugLog('Old token deleted');
    } catch (deleteError) {
      // If delete fails, continue anyway - we'll overwrite
      await debugLog('Delete token failed (continuing)', { error: deleteError.message });
    }

    // Step 2: Get service worker registration
    let registration = null;
    try {
      registration = await navigator.serviceWorker.getRegistration();
    } catch (e) {
      await debugLog('Could not get SW registration', { error: e.message });
    }

    // Step 3: Get new token
    const getTokenOptions = { vapidKey };
    if (registration?.active) {
      getTokenOptions.serviceWorkerRegistration = registration;
    }

    const newToken = await getToken(messaging, getTokenOptions);

    if (!newToken) {
      await debugLog('Failed to get new token');
      return { refreshed: false, token: stored.token, error: 'getToken returned null' };
    }

    await debugLog('New token obtained', { tokenPreview: newToken.substring(0, 20) + '...' });

    // Step 4: Get device fingerprint for registration
    const fingerprint = getCurrentDeviceFingerprint();

    // Step 5: Register new token with server
    const response = await fetch('/api/notifications/register', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        token: newToken,
        deviceId: fingerprint?.deviceId || stored.deviceId,
        displayName: fingerprint?.displayName,
        deviceInfo: fingerprint?.deviceInfo || stored.deviceInfo,
        userAgent: navigator.userAgent,
        platform: stored.platform || 'other',
        isPWA: stored.isPWA || false,
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      await debugLog('Server registration failed', { error });
      // Still save locally even if server fails
    }

    // Step 6: Save new token locally
    await saveToken(newToken, {
      deviceId: fingerprint?.deviceId || stored.deviceId,
      deviceInfo: fingerprint?.deviceInfo || stored.deviceInfo,
      createdAt: new Date().toISOString(), // Reset creation date
    });

    await debugLog('Token refresh complete');

    return { refreshed: true, token: newToken };

  } catch (error) {
    await debugLog('Token refresh error', { error: error.message });
    console.error('[tokenRefresh] Error:', error);

    // Return stored token if refresh failed
    const stored = await loadToken();
    return { refreshed: false, token: stored?.token || null, error: error.message };
  }
}

/**
 * Initialize token management on app startup
 *
 * Should be called once when app loads. Checks for stored token,
 * refreshes if needed, and returns current token status.
 *
 * @param {string} userId - User ID
 * @returns {Promise<{hasToken: boolean, token: string|null, wasRefreshed: boolean}>}
 */
export async function initializeTokenManagement(userId) {
  if (typeof window === 'undefined') {
    return { hasToken: false, token: null, wasRefreshed: false };
  }

  try {
    // Check for stored token
    const stored = await loadToken();

    if (!stored?.token) {
      return { hasToken: false, token: null, wasRefreshed: false };
    }

    // Check if refresh is needed
    const result = await checkAndRefreshToken(userId);

    return {
      hasToken: !!result.token,
      token: result.token,
      wasRefreshed: result.refreshed,
    };

  } catch (error) {
    console.error('[tokenRefresh] Initialize failed:', error);
    return { hasToken: false, token: null, wasRefreshed: false };
  }
}

/**
 * Force token refresh (for manual refresh button or troubleshooting)
 *
 * @param {string} userId - User ID
 * @returns {Promise<{success: boolean, token: string|null, error?: string}>}
 */
export async function forceTokenRefresh(userId) {
  if (typeof window === 'undefined') {
    return { success: false, token: null, error: 'SSR' };
  }

  await debugLog('Force refresh requested');

  // Temporarily set a very old createdAt to trigger refresh
  const stored = await loadToken();
  if (stored) {
    // Modify stored data to force refresh
    await saveToken(stored.token, {
      ...stored,
      createdAt: new Date(0).toISOString(), // Very old date
    });
  }

  const result = await checkAndRefreshToken(userId);

  return {
    success: result.refreshed,
    token: result.token,
    error: result.error,
  };
}
```

Key implementation details:
- Uses 30-day threshold per Firebase recommendations
- Explicitly deletes old token before getting new (clean lifecycle)
- Preserves deviceId across refresh (no duplicate devices)
- Updates createdAt on refresh (resets the clock)
- Fallback to stored token if refresh fails
- forceTokenRefresh for manual intervention
- initializeTokenManagement for app startup hook
  </action>
  <verify>
1. File exists at lib/tokenRefresh.js
2. Exports: checkAndRefreshToken, shouldRefreshToken, initializeTokenManagement, forceTokenRefresh
3. Uses loadToken/saveToken from tokenStorage
4. Uses deleteToken from firebase/messaging
5. No syntax errors
  </verify>
  <done>
lib/tokenRefresh.js created with 30-day refresh logic. Module checks token age on startup and refreshes old tokens with explicit deletion of old token first.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for tokenRefresh</name>
  <files>lib/__tests__/tokenRefresh.test.js</files>
  <action>
Create test file for tokenRefresh module:

```javascript
/**
 * Token Refresh Tests
 */

// Mock modules before imports
jest.mock('./tokenStorage', () => ({
  loadToken: jest.fn(),
  saveToken: jest.fn(),
  getTokenAge: jest.fn(),
  updateLastUsed: jest.fn(),
}));

jest.mock('./deviceFingerprint', () => ({
  getCurrentDeviceFingerprint: jest.fn(() => ({
    deviceId: 'test-device-id',
    displayName: 'Test Browser on Test OS',
    deviceInfo: { browser: 'Test', os: 'Test' },
  })),
}));

jest.mock('firebase/messaging', () => ({
  getMessaging: jest.fn(() => ({})),
  getToken: jest.fn(),
  deleteToken: jest.fn(),
}));

// Mock fetch
global.fetch = jest.fn(() =>
  Promise.resolve({
    ok: true,
    json: () => Promise.resolve({ success: true }),
  })
);

// Mock Notification
global.Notification = {
  permission: 'granted',
};

// Mock navigator.serviceWorker
Object.defineProperty(global.navigator, 'serviceWorker', {
  value: {
    getRegistration: jest.fn(() => Promise.resolve({ active: true })),
  },
  writable: true,
});

// Mock process.env
process.env.NEXT_PUBLIC_FIREBASE_VAPID_KEY = 'test-vapid-key';

import { shouldRefreshToken, checkAndRefreshToken } from './tokenRefresh';
import { loadToken, saveToken, getTokenAge, updateLastUsed } from './tokenStorage';
import { getToken, deleteToken } from 'firebase/messaging';

describe('tokenRefresh', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('shouldRefreshToken', () => {
    it('returns false when no token stored', async () => {
      getTokenAge.mockResolvedValue(null);

      const result = await shouldRefreshToken();

      expect(result).toBe(false);
    });

    it('returns false when token is fresh (< 30 days)', async () => {
      getTokenAge.mockResolvedValue(15);

      const result = await shouldRefreshToken();

      expect(result).toBe(false);
    });

    it('returns true when token is old (> 30 days)', async () => {
      getTokenAge.mockResolvedValue(45);

      const result = await shouldRefreshToken();

      expect(result).toBe(true);
    });

    it('returns true when token is exactly 30 days old', async () => {
      getTokenAge.mockResolvedValue(30.1);

      const result = await shouldRefreshToken();

      expect(result).toBe(true);
    });
  });

  describe('checkAndRefreshToken', () => {
    it('skips refresh when no stored token', async () => {
      loadToken.mockResolvedValue(null);

      const result = await checkAndRefreshToken('user123');

      expect(result.refreshed).toBe(false);
      expect(result.error).toBe('No stored token');
      expect(deleteToken).not.toHaveBeenCalled();
    });

    it('updates lastUsed when token is fresh', async () => {
      loadToken.mockResolvedValue({ token: 'fresh-token' });
      getTokenAge.mockResolvedValue(10);

      const result = await checkAndRefreshToken('user123');

      expect(result.refreshed).toBe(false);
      expect(result.token).toBe('fresh-token');
      expect(updateLastUsed).toHaveBeenCalled();
      expect(deleteToken).not.toHaveBeenCalled();
    });

    it('refreshes token when older than 30 days', async () => {
      loadToken.mockResolvedValue({
        token: 'old-token',
        deviceId: 'device-123',
      });
      getTokenAge.mockResolvedValue(45);
      getToken.mockResolvedValue('new-token-abc');

      const result = await checkAndRefreshToken('user123');

      expect(result.refreshed).toBe(true);
      expect(result.token).toBe('new-token-abc');
      expect(deleteToken).toHaveBeenCalled();
      expect(getToken).toHaveBeenCalled();
      expect(saveToken).toHaveBeenCalledWith(
        'new-token-abc',
        expect.objectContaining({ deviceId: 'test-device-id' })
      );
    });

    it('returns error when no permission', async () => {
      const originalPermission = Notification.permission;
      Notification.permission = 'denied';

      const result = await checkAndRefreshToken('user123');

      expect(result.refreshed).toBe(false);
      expect(result.error).toBe('No permission');

      Notification.permission = originalPermission;
    });
  });
});
```
  </action>
  <verify>
Run `npm test lib/__tests__/tokenRefresh.test.js` - tests should pass
  </verify>
  <done>
Unit tests for tokenRefresh created and passing. Tests cover shouldRefreshToken logic and checkAndRefreshToken flow.
  </done>
</task>

</tasks>

<verification>
1. `lib/tokenRefresh.js` exists with all exports
2. `npm test` passes including new tokenRefresh tests
3. Module correctly checks 30-day threshold
4. Refresh flow deletes old token before getting new
</verification>

<success_criteria>
- tokenRefresh module created with 30-day refresh logic
- Unit tests passing for refresh behavior
- Explicit token deletion before refresh (clean lifecycle)
- Preserves deviceId across refresh
</success_criteria>

<output>
After completion, create `.planning/phases/01-token-lifecycle-foundation/01-04-SUMMARY.md`
</output>
