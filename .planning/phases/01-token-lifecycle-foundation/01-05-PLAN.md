---
phase: 01-token-lifecycle-foundation
plan: 05
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - app/api/notifications/cleanup/route.js
  - lib/firebaseAdmin.js
autonomous: true

must_haves:
  truths:
    - "Invalid tokens are removed from database when send fails with UNREGISTERED error"
    - "Cleanup API endpoint exists and removes stale tokens (>90 days)"
    - "Cleanup endpoint is protected with bearer token authentication"
    - "Stale token count is returned in cleanup response"
  artifacts:
    - path: "app/api/notifications/cleanup/route.js"
      provides: "Cleanup endpoint for cron-job.org"
      exports: ["POST"]
      min_lines: 50
    - path: "lib/firebaseAdmin.js"
      provides: "Updated sendNotificationToUser with invalid token detection"
      contains: "messaging/registration-token-not-registered"
  key_links:
    - from: "app/api/notifications/cleanup/route.js"
      to: "Firebase Admin SDK"
      via: "getAdminDatabase, adminDbRemove"
      pattern: "getAdminDatabase|adminDbRemove"
    - from: "lib/firebaseAdmin.js"
      to: "Token removal on error"
      via: "adminDbRemove on UNREGISTERED error"
      pattern: "adminDbRemove.*fcmTokens"
---

<objective>
Implement invalid token cleanup: real-time detection on send errors and scheduled cleanup API.

Purpose: Implement TOKEN-03 (invalid tokens removed on error) and TOKEN-04 (cleanup tokens >90 days). Invalid tokens waste FCM quota and slow delivery. Cleanup endpoint enables cron-job.org to remove stale tokens daily.

Output: Updated sendNotificationToUser with error detection, new cleanup API route.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-token-lifecycle-foundation/01-RESEARCH.md
@.planning/phases/01-token-lifecycle-foundation/01-03-SUMMARY.md
@lib/firebaseAdmin.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update sendPushNotification with invalid token detection</name>
  <files>lib/firebaseAdmin.js</files>
  <action>
Update the sendPushNotification function to detect and remove invalid tokens.

Add a helper function to remove invalid tokens from Firebase, then update sendPushNotification and sendNotificationToUser to use it.

After the existing imports and before the initializeFirebaseAdmin function, add:

```javascript
// Error codes that indicate token is permanently invalid
const INVALID_TOKEN_ERRORS = [
  'messaging/registration-token-not-registered',
  'messaging/invalid-argument',
  'messaging/invalid-registration-token',
];
```

Add this new helper function after adminDbRemove:

```javascript
/**
 * Remove an invalid FCM token from all users
 * Called when FCM returns UNREGISTERED or INVALID_ARGUMENT error
 *
 * @param {string} invalidToken - The token to remove
 */
async function removeInvalidToken(invalidToken) {
  try {
    const db = getAdminDatabase();

    // Find and remove this token from all users
    // Token is stored at users/{userId}/fcmTokens/{tokenKey}
    const usersRef = db.ref('users');
    const snapshot = await usersRef.once('value');

    if (!snapshot.exists()) return;

    const updates = {};

    snapshot.forEach(userSnap => {
      const userId = userSnap.key;
      const tokens = userSnap.child('fcmTokens').val() || {};

      Object.entries(tokens).forEach(([tokenKey, tokenData]) => {
        if (tokenData.token === invalidToken) {
          updates[`users/${userId}/fcmTokens/${tokenKey}`] = null;
          console.log(`üóëÔ∏è Removing invalid token for user ${userId}`);
        }
      });
    });

    if (Object.keys(updates).length > 0) {
      await db.ref().update(updates);
      console.log(`‚úÖ Removed ${Object.keys(updates).length} invalid token(s)`);
    }
  } catch (error) {
    console.error('‚ùå Error removing invalid token:', error);
  }
}
```

Update the sendPushNotification function. Replace the existing function with this enhanced version that detects and removes invalid tokens:

```javascript
/**
 * Invia notifica push a uno o pi√π dispositivi
 * Enhanced with invalid token detection and removal
 *
 * @param {string|string[]} tokens - FCM token(s) destinatario
 * @param {Object} notification - Dati notifica
 * @param {string} notification.title - Titolo notifica
 * @param {string} notification.body - Corpo notifica
 * @param {Object} [notification.data] - Dati custom aggiuntivi
 * @param {string} [notification.icon] - URL icona
 * @param {string} [notification.priority] - Priorit√† (high|normal)
 */
export async function sendPushNotification(tokens, notification) {
  try {
    // Inizializza Admin SDK
    initializeFirebaseAdmin();

    // Normalizza tokens in array
    const tokenArray = Array.isArray(tokens) ? tokens : [tokens];

    if (tokenArray.length === 0) {
      throw new Error('Nessun token FCM fornito');
    }

    // Costruisci messaggio
    const hasAbsoluteIcon = notification.icon?.startsWith('http');

    const message = {
      notification: {
        title: notification.title || 'Pannello Stufa',
        body: notification.body || '',
        ...(hasAbsoluteIcon && { imageUrl: notification.icon }),
      },
      data: notification.data || {},
      android: {
        priority: notification.priority === 'high' ? 'high' : 'normal',
        notification: {
          channelId: 'default',
          priority: notification.priority === 'high' ? 'high' : 'default',
          defaultSound: true,
          defaultVibrateTimings: true,
        },
      },
      apns: {
        payload: {
          aps: {
            alert: {
              title: notification.title || 'Pannello Stufa',
              body: notification.body || '',
            },
            sound: 'default',
            badge: 1,
            ...(notification.priority === 'high' && {
              'content-available': 1,
              priority: 10,
            }),
          },
        },
      },
      webpush: {
        notification: {
          title: notification.title || 'Pannello Stufa',
          body: notification.body || '',
          icon: notification.icon || '/icons/icon-192.png',
          badge: '/icons/icon-72.png',
          requireInteraction: notification.priority === 'high',
          vibrate: notification.priority === 'high' ? [200, 100, 200] : [100],
        },
        fcmOptions: {
          link: notification.data?.url || '/',
        },
      },
    };

    // Track invalid tokens for removal
    const invalidTokens = [];

    // Invia a singolo token
    if (tokenArray.length === 1) {
      try {
        const response = await getMessaging().send({
          ...message,
          token: tokenArray[0],
        });

        console.log('‚úÖ Notifica inviata:', response);
        return {
          success: true,
          successCount: 1,
          failureCount: 0,
          responses: [{ success: true, messageId: response }],
        };
      } catch (error) {
        // Check if token is invalid
        if (INVALID_TOKEN_ERRORS.includes(error.code)) {
          console.warn(`‚ö†Ô∏è Invalid token detected: ${error.code}`);
          invalidTokens.push(tokenArray[0]);

          // Remove invalid token asynchronously (don't block response)
          removeInvalidToken(tokenArray[0]).catch(console.error);
        }

        return {
          success: false,
          successCount: 0,
          failureCount: 1,
          responses: [{ success: false, error }],
          invalidTokensRemoved: invalidTokens.length,
        };
      }
    }

    // Invia a multipli token (batch)
    const response = await getMessaging().sendEachForMulticast({
      ...message,
      tokens: tokenArray,
    });

    console.log(`‚úÖ Notifiche inviate: ${response.successCount}/${tokenArray.length}`);

    // Check for invalid tokens and remove them
    if (response.failureCount > 0) {
      response.responses.forEach((resp, idx) => {
        if (!resp.success && INVALID_TOKEN_ERRORS.includes(resp.error?.code)) {
          console.warn(`‚ö†Ô∏è Invalid token at index ${idx}: ${resp.error.code}`);
          invalidTokens.push(tokenArray[idx]);
        } else if (!resp.success) {
          console.error(`‚ùå Errore token ${tokenArray[idx]}:`, resp.error);
        }
      });

      // Remove invalid tokens asynchronously
      if (invalidTokens.length > 0) {
        Promise.all(invalidTokens.map(t => removeInvalidToken(t))).catch(console.error);
      }
    }

    return {
      success: response.successCount > 0,
      successCount: response.successCount,
      failureCount: response.failureCount,
      responses: response.responses,
      invalidTokensRemoved: invalidTokens.length,
    };

  } catch (error) {
    console.error('‚ùå Errore invio notifica push:', error);
    throw error;
  }
}
```

The key changes:
1. Added INVALID_TOKEN_ERRORS constant with FCM error codes
2. Added removeInvalidToken helper function
3. Updated sendPushNotification to detect invalid token errors
4. Removes invalid tokens asynchronously (doesn't block response)
5. Returns invalidTokensRemoved count in response
  </action>
  <verify>
1. INVALID_TOKEN_ERRORS constant defined
2. removeInvalidToken function exists
3. sendPushNotification catches invalid token errors
4. Run `npm test` - should pass
  </verify>
  <done>
sendPushNotification updated to detect and remove invalid tokens. UNREGISTERED and INVALID_ARGUMENT errors trigger automatic token removal.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create cleanup API endpoint</name>
  <files>app/api/notifications/cleanup/route.js</files>
  <action>
Create new file `app/api/notifications/cleanup/route.js` for scheduled cleanup:

```javascript
/**
 * API Route: Cleanup Stale FCM Tokens
 *
 * POST /api/notifications/cleanup
 *
 * Removes FCM tokens that haven't been used in >90 days.
 * Designed to be called by cron-job.org daily.
 *
 * Authentication: Bearer token via CRON_SECRET env var
 *
 * Response:
 * {
 *   success: true,
 *   removed: 5,
 *   scanned: 100,
 *   timestamp: "2026-01-23T12:00:00Z"
 * }
 */

import { getAdminDatabase } from '@/lib/firebaseAdmin';

export const dynamic = 'force-dynamic';

// Tokens inactive for >90 days are considered stale
const STALE_THRESHOLD_MS = 90 * 24 * 60 * 60 * 1000;

/**
 * POST /api/notifications/cleanup
 * Remove stale FCM tokens
 * Protected: Requires CRON_SECRET bearer token
 */
export async function POST(request) {
  try {
    // Verify authorization
    const authHeader = request.headers.get('authorization');
    const cronSecret = process.env.CRON_SECRET;

    if (!cronSecret) {
      console.error('CRON_SECRET not configured');
      return Response.json(
        { error: 'Server configuration error' },
        { status: 500 }
      );
    }

    if (authHeader !== `Bearer ${cronSecret}`) {
      console.warn('Unauthorized cleanup attempt');
      return Response.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    console.log('üßπ Starting token cleanup...');

    const db = getAdminDatabase();
    const usersRef = db.ref('users');
    const snapshot = await usersRef.once('value');

    if (!snapshot.exists()) {
      return Response.json({
        success: true,
        removed: 0,
        scanned: 0,
        timestamp: new Date().toISOString(),
        message: 'No users found',
      });
    }

    const now = Date.now();
    const updates = {};
    let scanned = 0;
    let removed = 0;

    snapshot.forEach(userSnap => {
      const userId = userSnap.key;
      const tokens = userSnap.child('fcmTokens').val() || {};

      Object.entries(tokens).forEach(([tokenKey, tokenData]) => {
        scanned++;

        // Use lastUsed if available, otherwise fall back to createdAt
        const lastActivity = tokenData.lastUsed || tokenData.createdAt;

        if (!lastActivity) {
          // No timestamp - consider stale
          updates[`users/${userId}/fcmTokens/${tokenKey}`] = null;
          removed++;
          console.log(`üóëÔ∏è Removing token without timestamp (user ${userId})`);
          return;
        }

        const lastActivityTime = new Date(lastActivity).getTime();
        const age = now - lastActivityTime;

        if (age > STALE_THRESHOLD_MS) {
          updates[`users/${userId}/fcmTokens/${tokenKey}`] = null;
          removed++;
          const ageDays = Math.floor(age / (24 * 60 * 60 * 1000));
          console.log(`üóëÔ∏è Removing stale token (${ageDays} days old, user ${userId})`);
        }
      });
    });

    // Apply all deletions in single batch update
    if (Object.keys(updates).length > 0) {
      await db.ref().update(updates);
    }

    console.log(`‚úÖ Cleanup complete: removed ${removed} of ${scanned} tokens`);

    return Response.json({
      success: true,
      removed,
      scanned,
      timestamp: new Date().toISOString(),
    });

  } catch (error) {
    console.error('‚ùå Cleanup error:', error);
    return Response.json(
      { error: 'Cleanup failed', message: error.message },
      { status: 500 }
    );
  }
}

/**
 * GET /api/notifications/cleanup
 * Health check endpoint (no auth required)
 */
export async function GET() {
  return Response.json({
    endpoint: '/api/notifications/cleanup',
    method: 'POST',
    auth: 'Bearer token required (CRON_SECRET)',
    purpose: 'Remove stale FCM tokens (>90 days inactive)',
    schedule: 'Daily via cron-job.org',
  });
}
```

Key implementation details:
- POST requires Bearer token matching CRON_SECRET env var
- Uses lastUsed timestamp (or createdAt fallback) to determine staleness
- 90-day threshold for stale tokens
- Batch update for efficiency
- GET endpoint for health check / documentation
- Logs removed tokens for monitoring
  </action>
  <verify>
1. File exists at app/api/notifications/cleanup/route.js
2. Exports POST and GET handlers
3. POST requires Bearer token auth
4. 90-day threshold implemented
5. Run `npm test` - should pass
  </verify>
  <done>
Cleanup API endpoint created at /api/notifications/cleanup. POST removes tokens inactive >90 days, protected by CRON_SECRET bearer token.
  </done>
</task>

<task type="auto">
  <name>Task 3: Document CRON_SECRET environment variable</name>
  <files>.env.example</files>
  <action>
Add CRON_SECRET to .env.example if the file exists. If not, create documentation note.

Check if .env.example exists:
```bash
ls -la .env.example
```

If it exists, append:
```
# Token cleanup cron job authentication
# Generate with: openssl rand -hex 32
CRON_SECRET=your-secret-here
```

If .env.example doesn't exist, add a comment in the cleanup route file noting the required env var.
  </action>
  <verify>
CRON_SECRET is documented (either in .env.example or in route comments)
  </verify>
  <done>
CRON_SECRET environment variable documented for cron-job.org integration.
  </done>
</task>

</tasks>

<verification>
1. `lib/firebaseAdmin.js` removes invalid tokens on UNREGISTERED error
2. `app/api/notifications/cleanup/route.js` exists with POST handler
3. Cleanup endpoint requires Bearer token auth
4. CRON_SECRET documented
5. `npm test` passes
</verification>

<success_criteria>
- Invalid tokens detected on send and removed immediately
- Cleanup API removes tokens inactive >90 days
- Cleanup protected by bearer token
- Ready for cron-job.org integration
</success_criteria>

<output>
After completion, create `.planning/phases/01-token-lifecycle-foundation/01-05-SUMMARY.md`
</output>
