---
phase: 01-token-lifecycle-foundation
plan: 06
type: execute
wave: 4
depends_on: ["01-03", "01-04", "01-05"]
files_modified:
  - lib/notificationService.js
autonomous: false

must_haves:
  truths:
    - "Token persists across browser restart"
    - "Token refresh check runs on app startup"
    - "Integration works end-to-end"
    - "All Phase 1 success criteria verifiable"
  artifacts:
    - path: "lib/notificationService.js"
      provides: "Integration of tokenRefresh on startup"
      contains: "initializeTokenManagement"
  key_links:
    - from: "lib/notificationService.js"
      to: "lib/tokenRefresh.js"
      via: "import { initializeTokenManagement }"
      pattern: "import.*initializeTokenManagement.*from.*tokenRefresh"
---

<objective>
Integrate token refresh into app startup and verify Phase 1 success criteria.

Purpose: Wire up the token refresh check to run on app startup, then verify all Phase 1 success criteria are met: browser restart survival, 60-second auto-removal, multi-device broadcast, token accumulation prevention, 30-day refresh.

Output: Integrated notification system with startup refresh, verified working.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-token-lifecycle-foundation/01-RESEARCH.md
@.planning/phases/01-token-lifecycle-foundation/01-03-SUMMARY.md
@.planning/phases/01-token-lifecycle-foundation/01-04-SUMMARY.md
@.planning/phases/01-token-lifecycle-foundation/01-05-SUMMARY.md
@lib/notificationService.js
@lib/tokenRefresh.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add startup token check to notificationService</name>
  <files>lib/notificationService.js</files>
  <action>
Add initializeTokenManagement integration to notificationService.js.

1. Add import at the top (with other tokenRefresh imports):
```javascript
import { initializeTokenManagement, checkAndRefreshToken } from './tokenRefresh';
```

2. Add new exported function at the end of the file (before the disabled cleanupOldTokens):

```javascript
/**
 * Initialize notification system on app startup
 *
 * Checks for existing token, refreshes if needed (>30 days old),
 * and returns current notification status.
 *
 * Call this once when app loads (e.g., in a useEffect in layout or _app).
 *
 * @param {string} userId - User ID from Auth0
 * @returns {Promise<{
 *   hasToken: boolean,
 *   token: string|null,
 *   wasRefreshed: boolean,
 *   permissionStatus: string
 * }>}
 */
export async function initializeNotifications(userId) {
  if (!isNotificationSupported()) {
    return {
      hasToken: false,
      token: null,
      wasRefreshed: false,
      permissionStatus: 'unsupported',
    };
  }

  const permissionStatus = getNotificationPermission();

  // If no permission, can't do much
  if (permissionStatus !== 'granted') {
    return {
      hasToken: false,
      token: null,
      wasRefreshed: false,
      permissionStatus,
    };
  }

  try {
    // Check for existing token and refresh if needed
    const result = await initializeTokenManagement(userId);

    return {
      hasToken: result.hasToken,
      token: result.token,
      wasRefreshed: result.wasRefreshed,
      permissionStatus,
    };
  } catch (error) {
    console.error('[initializeNotifications] Error:', error);
    return {
      hasToken: false,
      token: null,
      wasRefreshed: false,
      permissionStatus,
      error: error.message,
    };
  }
}

/**
 * Check if stored token exists and load it
 * Used for quick check without full initialization
 *
 * @returns {Promise<{hasToken: boolean, token: string|null, age: number|null}>}
 */
export async function checkStoredToken() {
  try {
    const stored = await loadToken();
    const age = await getTokenAge();

    return {
      hasToken: !!stored?.token,
      token: stored?.token || null,
      age,
      deviceId: stored?.deviceId || null,
    };
  } catch (error) {
    console.error('[checkStoredToken] Error:', error);
    return { hasToken: false, token: null, age: null };
  }
}
```

3. Also add the getTokenAge import if not already present:
```javascript
import { saveToken, loadToken, updateLastUsed, getTokenAge } from './tokenStorage';
```

This provides:
- `initializeNotifications()` - full startup check with refresh
- `checkStoredToken()` - quick check for existing token
  </action>
  <verify>
1. initializeNotifications function exported
2. checkStoredToken function exported
3. Import from tokenRefresh added
4. No syntax errors
5. `npm test` passes
  </verify>
  <done>
Startup integration added to notificationService. initializeNotifications checks and refreshes tokens on app load.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete token lifecycle implementation:
1. Dual persistence (IndexedDB + localStorage) via lib/tokenStorage.js
2. Device fingerprinting via lib/deviceFingerprint.js
3. Device deduplication in register API
4. 30-day token refresh via lib/tokenRefresh.js
5. Invalid token detection and removal on send
6. Cleanup API for stale tokens (/api/notifications/cleanup)
7. Startup integration via initializeNotifications()
  </what-built>
  <how-to-verify>
**Preparation:**
1. Open app at localhost:3000
2. Open browser DevTools (F12) -> Application tab

**Test 1: Token Persistence (TOKEN-01)**
1. Register for notifications (if not already)
2. Check IndexedDB -> fcmTokenDB -> tokens (should have record)
3. Check localStorage -> fcm_token_data (should have data)
4. Close browser COMPLETELY (not just tab)
5. Reopen browser and navigate to app
6. Check IndexedDB and localStorage again - data should persist
7. Check Console for "[tokenStorage] Loaded from IndexedDB" message

**Test 2: Device Deduplication (TOKEN-05, TOKEN-06)**
1. Check Firebase Console -> Realtime Database -> users/{yourId}/fcmTokens
2. Should see ONE entry per device with deviceId field
3. Refresh page multiple times
4. Check database again - should still be ONE entry (not accumulating)

**Test 3: Startup Refresh Check (TOKEN-02)**
1. Check browser console on page load
2. Should see tokenRefresh logs like "Token age check" with ageDays
3. If token is <30 days: "Token is fresh, updated lastUsed"
4. If token is >30 days: "Token needs refresh" followed by refresh flow

**Test 4: Invalid Token Removal (TOKEN-03)**
(Cannot easily test without manually invalidating token in Firebase console - defer to integration testing)

**Test 5: Cleanup Endpoint (TOKEN-04)**
1. In terminal, test cleanup endpoint:
```bash
curl -X GET http://localhost:3000/api/notifications/cleanup
```
Should return endpoint documentation.

2. Test with invalid auth:
```bash
curl -X POST http://localhost:3000/api/notifications/cleanup
```
Should return 401 Unauthorized.
  </how-to-verify>
  <resume-signal>
Type "approved" if all tests pass, or describe any issues found.

Note: Tests 1-3 are critical. Test 4 can be verified in production. Test 5 just needs endpoint to exist.
  </resume-signal>
</task>

</tasks>

<verification>
1. Startup integration working (initializeNotifications exported)
2. Token persists across browser restart (Test 1)
3. Device deduplication working (Test 2)
4. Refresh check runs on startup (Test 3)
5. Cleanup endpoint responds correctly (Test 5)
</verification>

<success_criteria>
Phase 1 Success Criteria from ROADMAP.md:
1. User closes browser completely, reopens app, and receives test notification without re-registering
2. Token with invalid status automatically removed from database within 60 seconds (verified in code, not runtime test)
3. User registers 3 different devices and receives broadcast notification on all 3
4. Admin dashboard shows max 3-5 active tokens per user (no accumulation)
5. Token older than 30 days automatically refreshes on next app launch
</success_criteria>

<output>
After completion, create `.planning/phases/01-token-lifecycle-foundation/01-06-SUMMARY.md`
</output>
