---
phase: 02-production-monitoring-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/firebaseAdmin.js
  - app/api/notifications/errors/route.js
autonomous: true

must_haves:
  truths:
    - "FCM errors are captured with device identifier and error code"
    - "Error logs are queryable via API endpoint"
    - "Invalid tokens are tracked before removal"
  artifacts:
    - path: "app/api/notifications/errors/route.js"
      provides: "Error logs query endpoint"
      exports: ["GET"]
    - path: "lib/firebaseAdmin.js"
      provides: "Enhanced error tracking in sendPushNotification"
      contains: "trackInvalidToken"
  key_links:
    - from: "app/api/notifications/errors/route.js"
      to: "lib/firebaseAdmin.js"
      via: "getAdminDatabase import"
      pattern: "import.*getAdminDatabase.*from.*firebaseAdmin"
---

<objective>
Implement error logging infrastructure to capture FCM failures with actionable diagnostics.

Purpose: Enable admin to investigate notification failures with device context and error codes.
Output: API endpoint to query error logs, enhanced error tracking in send flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-production-monitoring-infrastructure/02-CONTEXT.md
@lib/firebaseAdmin.js
@app/api/notifications/cleanup/route.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error tracking in Firebase Realtime Database</name>
  <files>lib/firebaseAdmin.js</files>
  <action>
    Add error tracking to lib/firebaseAdmin.js that logs FCM errors to Firebase Realtime Database.

    Path: `notificationErrors/{pushKey}`

    Error document structure:
    ```javascript
    {
      timestamp: ISO string,
      userId: string,
      tokenPrefix: string,       // First 20 chars of token
      deviceId: string | null,   // If we can look it up
      errorCode: string,         // FCM error code
      errorMessage: string,
      notificationType: string,  // From notification.data.type
      notificationTitle: string,
      resolved: boolean          // false initially
    }
    ```

    1. Create helper function `trackNotificationError(errorData)`:
       - Push error to `notificationErrors` path
       - Auto-generate timestamp
       - Return push key

    2. Update sendPushNotification() to call trackNotificationError for each failed token:
       - Extract errorCode from FCM response error
       - Look up deviceId from token if possible (query users/*/fcmTokens where token matches)
       - Call trackNotificationError with full context

    3. Create helper function `lookupDeviceIdForToken(token)`:
       - Query all users' fcmTokens to find deviceId for given token
       - Return deviceId or null if not found
       - Cache results briefly to avoid repeated queries

    Keep existing removeInvalidToken behavior - trackNotificationError is additional logging.

    IMPORTANT: Error tracking should not block the main send flow. Use fire-and-forget pattern.
  </action>
  <verify>
    - trackNotificationError function exists and pushes to notificationErrors path
    - sendPushNotification calls trackNotificationError for each failed token
    - Errors include tokenPrefix, errorCode, errorMessage
    - lookupDeviceIdForToken attempts to find device context
  </verify>
  <done>
    FCM errors logged to Firebase Realtime Database with device context
  </done>
</task>

<task type="auto">
  <name>Task 2: Create error logs API endpoint</name>
  <files>app/api/notifications/errors/route.js</files>
  <action>
    Create app/api/notifications/errors/route.js to query notification errors.

    Endpoint: GET /api/notifications/errors

    Query parameters:
    - limit: number (default 50, max 200)
    - errorCode: string (filter by specific FCM error code)
    - since: ISO timestamp (filter errors after this time)
    - resolved: boolean (filter by resolved status)

    Response:
    ```javascript
    {
      success: true,
      errors: [{
        id: string,
        timestamp: string,
        userId: string,
        tokenPrefix: string,
        deviceId: string | null,
        errorCode: string,
        errorMessage: string,
        notificationType: string,
        notificationTitle: string,
        resolved: boolean
      }],
      count: number,
      filters: { errorCode, since, resolved, limit }
    }
    ```

    Implementation:
    1. Use withAuthAndErrorHandler for authentication
    2. Query notificationErrors from Firebase Realtime Database
    3. Apply filters in memory (Firebase RTDB has limited query capabilities)
    4. Sort by timestamp descending
    5. Limit results

    Also implement POST for marking errors as resolved:
    - POST /api/notifications/errors with body { errorId: string }
    - Updates notificationErrors/{errorId}/resolved to true
    - Returns { success: true, resolved: errorId }

    Follow patterns from existing /api/notifications/cleanup/route.js.
  </action>
  <verify>
    - GET /api/notifications/errors returns error list
    - POST /api/notifications/errors marks error as resolved
    - Both endpoints require authentication
    - Filtering by errorCode, since, resolved works
    - Results sorted by timestamp descending
  </verify>
  <done>
    Error logs API endpoint operational with GET (query) and POST (resolve) methods
  </done>
</task>

<task type="auto">
  <name>Task 3: Add 30-day auto-cleanup for error logs</name>
  <files>app/api/notifications/cleanup/route.js</files>
  <action>
    Extend the existing cleanup route to also clean up old notification errors.

    In the POST handler (after token cleanup), add error log cleanup:

    1. Query notificationErrors for entries older than 30 days
    2. Delete those entries in batch
    3. Include in response: { ..., errorsRemoved: number }

    Implementation:
    ```javascript
    // After token cleanup...

    // Cleanup old error logs (30 days retention per 02-CONTEXT.md)
    const ERROR_RETENTION_MS = 30 * 24 * 60 * 60 * 1000;
    const errorCutoff = new Date(now - ERROR_RETENTION_MS).toISOString();

    const errorsRef = db.ref('notificationErrors');
    const errorsSnapshot = await errorsRef.once('value');

    let errorsRemoved = 0;
    if (errorsSnapshot.exists()) {
      const errorUpdates = {};
      errorsSnapshot.forEach(errorSnap => {
        const error = errorSnap.val();
        if (error.timestamp && error.timestamp < errorCutoff) {
          errorUpdates[`notificationErrors/${errorSnap.key}`] = null;
          errorsRemoved++;
        }
      });

      if (Object.keys(errorUpdates).length > 0) {
        await db.ref().update(errorUpdates);
      }
    }
    ```

    Update response to include errorsRemoved count.

    This follows the 30-day retention policy from 02-CONTEXT.md decisions.
  </action>
  <verify>
    - cleanup route deletes error logs older than 30 days
    - Response includes errorsRemoved count
    - Existing token cleanup still works
  </verify>
  <done>
    Error logs automatically cleaned up after 30 days during scheduled cleanup
  </done>
</task>

</tasks>

<verification>
1. Review lib/firebaseAdmin.js has trackNotificationError integration
2. Review app/api/notifications/errors/route.js handles GET and POST
3. Review app/api/notifications/cleanup/route.js includes error cleanup
4. Run `npm run lint` to check for syntax errors
</verification>

<success_criteria>
- FCM send errors logged to Firebase with tokenPrefix, errorCode, deviceId
- GET /api/notifications/errors returns queryable error list
- POST /api/notifications/errors marks errors as resolved
- Error logs auto-cleaned after 30 days
- Error tracking does not block notification sending
</success_criteria>

<output>
After completion, create `.planning/phases/02-production-monitoring-infrastructure/02-02-SUMMARY.md`
</output>
