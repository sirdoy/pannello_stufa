---
phase: 03-user-preferences-control
plan: 04
type: execute
wave: 3
depends_on: ["03-01"]
files_modified:
  - lib/firebaseAdmin.js
  - lib/notificationFilter.js
autonomous: true

must_haves:
  truths:
    - "User disables 'Scheduler' notifications â†’ scheduler events no longer trigger push (success criteria #1)"
    - "User sets DND 22:00-08:00 â†’ receives no notifications during those hours (success criteria #2)"
    - "CRITICAL notifications bypass DND hours (per CONTEXT.md decision)"
    - "Disabled notification types are filtered before FCM send"
  artifacts:
    - path: "lib/notificationFilter.js"
      provides: "Server-side notification filtering logic (type checks, DND filtering)"
      exports: ["filterNotificationByPreferences", "isInDNDWindow", "getTokensNotInDND"]
      min_lines: 80
  key_links:
    - from: "lib/firebaseAdmin.js sendNotificationToUser()"
      to: "lib/notificationFilter.js"
      via: "filterNotificationByPreferences call before sendPushNotification"
      pattern: "filterNotificationByPreferences"
    - from: "lib/notificationFilter.js"
      to: "Firestore users/{userId}/settings/notifications"
      via: "getAdminFirestore read"
      pattern: "getAdminFirestore.*users.*settings.*notifications"
---

<objective>
Implement server-side notification filtering based on user preferences - check enabled types and DND hours before sending.

Purpose: Enforce user preferences at send time (success criteria #1 and #2)
Output: Modified sendNotificationToUser() that respects type toggles and DND windows
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-user-preferences--control---granular-notification-settings-dnd-hours-rate-limiting/03-CONTEXT.md
@.planning/phases/03-user-preferences--control---granular-notification-settings-dnd-hours-rate-limiting/03-RESEARCH.md
@lib/firebaseAdmin.js
@lib/schemas/notificationPreferences.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notification filter module</name>
  <files>lib/notificationFilter.js</files>
  <action>
Create new file `lib/notificationFilter.js` with server-side filtering logic:

1. Imports:
   - getAdminFirestore from './firebaseAdmin'
   - getDefaultPreferences from './schemas/notificationPreferences'

2. getUserPreferencesServer(userId):
   - Fetch preferences from Firestore: `users/${userId}/settings/notifications`
   - Return parsed data or getDefaultPreferences() if not found
   - Use Admin SDK (server-side, bypasses security rules)

3. isInDNDWindow(dndWindow, timezone):
   - Parse startTime and endTime (HH:mm format)
   - Get current time in user's timezone
   - Handle overnight periods (22:00-08:00):
     - If end < start, check: now >= start OR now < end
   - Return boolean: true if currently in DND window

4. getTokensNotInDND(tokens, preferences):
   - For each token, check its deviceId against DND windows
   - Filter out tokens currently in DND
   - Return array of allowed tokens
   - Note: Per-device DND means checking `dndWindows.deviceId` match

5. filterNotificationByPreferences(userId, notification, tokens):
   Main filtering function that returns:
   ```javascript
   {
     allowed: boolean,
     allowedTokens: string[],
     reason: string | null, // 'type_disabled', 'all_in_dnd', null
     stats: {
       totalTokens: number,
       filteredByDND: number,
       filteredByType: boolean,
     }
   }
   ```

   Logic flow:
   a. Get user preferences from Firestore
   b. Extract notification type from `notification.data?.type`
   c. Check if type is enabled in preferences.enabledTypes
      - If disabled, return { allowed: false, reason: 'type_disabled' }
   d. For each token:
      - Check if device is in DND window
      - CRITICAL bypass: If type === 'CRITICAL', skip DND check
      - Add to allowedTokens if not in DND
   e. If all tokens filtered, return { allowed: false, reason: 'all_in_dnd' }
   f. Return { allowed: true, allowedTokens, ... }

6. Map notification types to enabledTypes keys:
   - Match existing NOTIFICATION_CATEGORIES_CONFIG types
   - Handle legacy types gracefully (unknown type â†’ allow)

7. Logging:
   - Log filter decisions for debugging
   - Include userId, type, filtered count
  </action>
  <verify>node -e "const f = require('./lib/notificationFilter.js'); console.log(Object.keys(f));" shows exports</verify>
  <done>Filter module exists with type checking, DND window logic, and CRITICAL bypass</done>
</task>

<task type="auto">
  <name>Task 2: Integrate filter into sendNotificationToUser</name>
  <files>lib/firebaseAdmin.js</files>
  <action>
Modify `sendNotificationToUser()` in lib/firebaseAdmin.js:

1. Import filter function:
   ```javascript
   import { filterNotificationByPreferences } from './notificationFilter';
   ```

2. Add filtering before sending (after fetching tokens, before sendPushNotification):
   ```javascript
   export async function sendNotificationToUser(userId, notification) {
     try {
       // Existing: Get all user tokens
       const tokensData = await adminDbGet(`users/${userId}/fcmTokens`);
       if (!tokensData) {
         return { success: false, error: 'NO_TOKENS', ... };
       }

       const allTokens = Object.values(tokensData);

       // NEW: Apply preference filters
       const filterResult = await filterNotificationByPreferences(
         userId,
         notification,
         allTokens
       );

       if (!filterResult.allowed) {
         console.log(`ðŸš« Notification filtered: ${filterResult.reason} for user ${userId}`);
         return {
           success: false,
           error: 'FILTERED',
           reason: filterResult.reason,
           message: getFilterMessage(filterResult.reason),
         };
       }

       // Use filtered tokens
       const tokens = filterResult.allowedTokens;

       // Existing: Send notification
       return await sendPushNotification(tokens, notification, userId);

     } catch (error) {
       // Existing error handling
     }
   }
   ```

3. Add helper for filter messages:
   ```javascript
   function getFilterMessage(reason) {
     switch (reason) {
       case 'type_disabled':
         return 'User disabled this notification type';
       case 'all_in_dnd':
         return 'All devices in Do Not Disturb mode';
       default:
         return 'Notification filtered by preferences';
     }
   }
   ```

4. Update logging to include filter stats:
   - Log when notifications are filtered
   - Include reason and device count

5. Preserve existing functionality:
   - Token validation and removal unchanged
   - Error tracking unchanged
   - Multicast sending unchanged
  </action>
  <verify>
1. Disable a notification type in settings
2. Trigger that notification type via API or scheduler
3. Verify notification is NOT sent (check logs for "Notification filtered")
  </verify>
  <done>sendNotificationToUser checks preferences before sending, respects type toggles and DND</done>
</task>

</tasks>

<verification>
1. lib/notificationFilter.js exists with exports
2. isInDNDWindow correctly handles overnight periods (22:00-08:00)
3. CRITICAL notifications bypass DND filtering
4. Disabled notification types return filtered response
5. sendNotificationToUser integrates filter before send
6. Filter logs show decision reasoning
7. Success criteria #1: Disabled scheduler type â†’ no push sent
8. Success criteria #2: During DND hours â†’ no push sent (except CRITICAL)
</verification>

<success_criteria>
- User disables "Scheduler" type â†’ scheduler notifications filtered (success criteria #1)
- DND 22:00-08:00 active â†’ notifications blocked during those hours (success criteria #2)
- CRITICAL notifications always delivered (bypass DND)
- Filter decisions logged for debugging
- Existing notification flow preserved for allowed notifications
</success_criteria>

<output>
After completion, create `.planning/phases/03-user-preferences--control---granular-notification-settings-dnd-hours-rate-limiting/03-04-SUMMARY.md`
</output>
