---
phase: 03-user-preferences-control
plan: 05
type: execute
wave: 3
depends_on: ["03-01"]
files_modified:
  - lib/rateLimiter.js
  - lib/notificationFilter.js
autonomous: true

must_haves:
  truths:
    - "Scheduler fires 3 events in 4 min → user receives only 1 notification (success criteria #3)"
    - "Rate limits scoped to notification TYPE, not category (per CONTEXT.md)"
    - "CRITICAL notifications rate-limited but with higher limits (per CONTEXT.md)"
    - "Suppressed notifications logged for debugging"
  artifacts:
    - path: "lib/rateLimiter.js"
      provides: "In-memory rate limiting with per-type windows"
      exports: ["checkRateLimit", "clearRateLimitForUser"]
      min_lines: 60
  key_links:
    - from: "lib/notificationFilter.js"
      to: "lib/rateLimiter.js"
      via: "checkRateLimit call in filter chain"
      pattern: "checkRateLimit"
---

<objective>
Implement in-memory rate limiting for notifications scoped to notification type with configurable windows.

Purpose: Prevent notification spam (success criteria #3: "3 scheduler events in 4 min → 1 notification")
Output: Rate limiter integrated into notification filter chain
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-user-preferences--control---granular-notification-settings-dnd-hours-rate-limiting/03-CONTEXT.md
@.planning/phases/03-user-preferences--control---granular-notification-settings-dnd-hours-rate-limiting/03-RESEARCH.md
@lib/notificationFilter.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiter module</name>
  <files>lib/rateLimiter.js</files>
  <action>
Create new file `lib/rateLimiter.js` with in-memory rate limiting:

1. In-memory store:
   ```javascript
   // Map: userId:notifType -> [timestamp, timestamp, ...]
   const recentSends = new Map();
   ```

2. Default rate limits per type:
   ```javascript
   const DEFAULT_RATE_LIMITS = {
     CRITICAL: { windowMinutes: 1, maxPerWindow: 5 },   // High limit
     ERROR: { windowMinutes: 1, maxPerWindow: 3 },
     maintenance: { windowMinutes: 5, maxPerWindow: 1 },
     updates: { windowMinutes: 60, maxPerWindow: 1 },   // Max 1 per hour
     scheduler_success: { windowMinutes: 5, maxPerWindow: 1 }, // Per success criteria #3
     status: { windowMinutes: 5, maxPerWindow: 1 },
     default: { windowMinutes: 5, maxPerWindow: 1 },
   };
   ```

3. checkRateLimit(userId, notifType, customLimits = null):
   ```javascript
   /**
    * Check if notification is allowed by rate limit
    * @param {string} userId - User ID
    * @param {string} notifType - Notification type (e.g., 'scheduler_success')
    * @param {Object} customLimits - Optional { windowMinutes, maxPerWindow }
    * @returns {{ allowed: boolean, suppressedCount: number, nextAllowedIn: number }}
    */
   export function checkRateLimit(userId, notifType, customLimits = null) {
     const key = `${userId}:${notifType}`;
     const now = Date.now();

     // Get limits (custom > user prefs > defaults)
     const limits = customLimits || DEFAULT_RATE_LIMITS[notifType] || DEFAULT_RATE_LIMITS.default;
     const windowMs = limits.windowMinutes * 60 * 1000;

     // Get recent sends for this key
     const sends = recentSends.get(key) || [];

     // Filter to current window
     const recentInWindow = sends.filter(ts => now - ts < windowMs);

     // Check limit
     if (recentInWindow.length >= limits.maxPerWindow) {
       // Calculate when next send is allowed
       const oldestInWindow = Math.min(...recentInWindow);
       const nextAllowedIn = (oldestInWindow + windowMs) - now;

       return {
         allowed: false,
         suppressedCount: recentInWindow.length,
         nextAllowedIn: Math.ceil(nextAllowedIn / 1000), // seconds
       };
     }

     // Track this send
     recentInWindow.push(now);
     recentSends.set(key, recentInWindow);

     return { allowed: true, suppressedCount: 0, nextAllowedIn: 0 };
   }
   ```

4. clearRateLimitForUser(userId):
   - Remove all rate limit entries for a user
   - Useful for testing and user reset

5. Periodic cleanup (prevent memory leak):
   ```javascript
   // Clean up old entries every 5 minutes
   setInterval(() => {
     const now = Date.now();
     const maxAge = 60 * 60 * 1000; // 1 hour max retention

     for (const [key, sends] of recentSends) {
       const filtered = sends.filter(ts => now - ts < maxAge);
       if (filtered.length === 0) {
         recentSends.delete(key);
       } else {
         recentSends.set(key, filtered);
       }
     }
   }, 5 * 60 * 1000);
   ```

6. Logging:
   - Log rate limit hits with userId, type, suppressedCount
   - Include nextAllowedIn for debugging
  </action>
  <verify>node -e "const r = require('./lib/rateLimiter.js'); console.log(r.checkRateLimit('test', 'scheduler_success'));" returns { allowed: true, ... }</verify>
  <done>Rate limiter module exists with per-type windows, cleanup, and logging</done>
</task>

<task type="auto">
  <name>Task 2: Integrate rate limiter into notification filter</name>
  <files>lib/notificationFilter.js</files>
  <action>
Update `lib/notificationFilter.js` to include rate limiting:

1. Import rate limiter:
   ```javascript
   import { checkRateLimit } from './rateLimiter';
   ```

2. Update filterNotificationByPreferences to add rate limit check:
   After type check, before DND check:
   ```javascript
   // 3. Check rate limit for this notification type
   const userRateLimits = preferences.rateLimits?.[notifType];
   const rateLimitResult = checkRateLimit(userId, notifType, userRateLimits);

   if (!rateLimitResult.allowed) {
     console.log(`⏱️ Rate limit hit for ${userId}:${notifType}, suppressed ${rateLimitResult.suppressedCount} in window`);
     return {
       allowed: false,
       allowedTokens: [],
       reason: 'rate_limited',
       stats: {
         totalTokens: tokens.length,
         filteredByDND: 0,
         filteredByType: false,
         rateLimited: true,
         suppressedCount: rateLimitResult.suppressedCount,
         nextAllowedIn: rateLimitResult.nextAllowedIn,
       },
     };
   }
   ```

3. Update filter order (per CONTEXT.md):
   a. Type enabled check (fastest, bail early)
   b. Rate limit check (in-memory, fast)
   c. DND window check (per-device, more complex)

4. Add rate_limited to getFilterMessage in firebaseAdmin.js:
   ```javascript
   case 'rate_limited':
     return 'Rate limit exceeded, notification suppressed';
   ```

5. Consider aggregation note (future enhancement):
   - Add TODO comment for summary notification aggregation
   - Per CONTEXT.md: "Suppressed notifications aggregated into summary"
   - Out of scope for this plan, but leave hook for Phase 4+

6. Update logging to include rate limit stats
  </action>
  <verify>
1. Trigger same notification type 3 times in 1 minute
2. Verify only first notification is sent
3. Check logs for "Rate limit hit" messages
  </verify>
  <done>Rate limiting integrated into filter chain, respects per-type limits from preferences</done>
</task>

</tasks>

<verification>
1. lib/rateLimiter.js exists with checkRateLimit export
2. Rate limiter uses in-memory Map storage
3. Cleanup interval prevents memory growth
4. Filter chain applies rate limit after type check
5. Success criteria #3 test:
   - Trigger 3 scheduler_success in 4 minutes
   - First notification sent
   - Second and third filtered with "rate_limited" reason
   - User receives only 1 notification
6. Different notification types have independent limits
7. User's custom rate limits from preferences are respected
</verification>

<success_criteria>
- 3 scheduler events in 4 min → only 1 notification sent (success criteria #3)
- Rate limits scoped to notification TYPE, not category
- CRITICAL type has higher rate limit (5 per minute)
- Rate limit decisions logged with suppression count
- In-memory store cleaned periodically (no memory leak)
</success_criteria>

<output>
After completion, create `.planning/phases/03-user-preferences--control---granular-notification-settings-dnd-hours-rate-limiting/03-05-SUMMARY.md`
</output>
