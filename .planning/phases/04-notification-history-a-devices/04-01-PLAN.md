---
phase: 04-notification-history-devices
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/notifications/history/route.js
  - lib/notificationHistoryService.js
  - firestore.indexes.json
autonomous: true

must_haves:
  truths:
    - "API returns paginated notification history for authenticated user"
    - "Cursor-based pagination works correctly with startAfter"
    - "Type and status filters return filtered results"
    - "Only notifications < 90 days returned (GDPR safeguard)"
  artifacts:
    - path: "app/api/notifications/history/route.js"
      provides: "Paginated history endpoint with filters"
      exports: ["GET"]
    - path: "lib/notificationHistoryService.js"
      provides: "Firestore query helpers for pagination"
      exports: ["getNotificationHistory"]
    - path: "firestore.indexes.json"
      provides: "Composite index definition for multi-field queries"
      contains: "notificationLogs"
  key_links:
    - from: "app/api/notifications/history/route.js"
      to: "lib/notificationHistoryService.js"
      via: "import getNotificationHistory"
      pattern: "getNotificationHistory"
    - from: "lib/notificationHistoryService.js"
      to: "lib/firebaseAdmin.js"
      via: "getAdminFirestore"
      pattern: "getAdminFirestore"
---

<objective>
Create paginated notification history API endpoint with Firestore cursor-based pagination.

Purpose: Enable users to view their notification history with infinite scroll support. This is the backend foundation for HIST-02, HIST-03, HIST-04 requirements.

Output:
- `/api/notifications/history` GET endpoint with cursor pagination
- `notificationHistoryService.js` with Firestore query helpers
- Firestore composite index for userId + type + timestamp queries
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-notification-history-a-devices/04-RESEARCH.md
@lib/notificationLogger.js
@lib/firebaseAdmin.js
@app/api/notifications/devices/route.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notification history service with pagination</name>
  <files>lib/notificationHistoryService.js</files>
  <action>
Create `notificationHistoryService.js` with Firestore cursor-based pagination:

1. Export `getNotificationHistory(userId, options)`:
   - Parameters: `{ limit = 50, cursor = null, type = null, status = null }`
   - Build Firestore query on `notificationLogs` collection
   - Filter by userId (required)
   - Apply 90-day date filter ALWAYS (GDPR safeguard per RESEARCH.md Pitfall #1)
   - Apply optional type filter (scheduler, error, maintenance, test, generic)
   - Apply optional status filter (sent, delivered, failed)
   - Order by timestamp descending
   - Use `startAfter(cursor)` for pagination if cursor provided
   - Apply limit
   - Return `{ notifications: Array, cursor: string|null, hasMore: boolean }`

2. Cursor handling:
   - Convert DocumentSnapshot to serializable cursor (base64 encode doc path + timestamp)
   - Parse cursor back to DocumentSnapshot reference for startAfter

3. Date transformation:
   - Convert Firestore Timestamps to ISO strings for client
   - Format: `timestamp: doc.data().timestamp.toDate().toISOString()`

Pattern to follow from `notificationLogger.js`:
```javascript
import { getAdminFirestore } from './firebaseAdmin.js';
import { Timestamp } from 'firebase-admin/firestore';
```

90-day filter pattern (CRITICAL - prevents expired docs from appearing):
```javascript
const ninetyDaysAgo = new Date();
ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
query = query.where('timestamp', '>', Timestamp.fromDate(ninetyDaysAgo));
```
  </action>
  <verify>
File exists and exports getNotificationHistory function:
```bash
grep -q "export async function getNotificationHistory" lib/notificationHistoryService.js && echo "OK"
```
  </verify>
  <done>
`notificationHistoryService.js` exists with getNotificationHistory function that:
- Queries notificationLogs collection with userId filter
- Applies 90-day date filter
- Supports optional type and status filters
- Returns paginated results with cursor
  </done>
</task>

<task type="auto">
  <name>Task 2: Create history API endpoint with filters</name>
  <files>app/api/notifications/history/route.js</files>
  <action>
Create GET endpoint `/api/notifications/history`:

1. Follow existing API patterns from `/api/notifications/devices/route.js`:
   - Use `withAuthAndErrorHandler` wrapper
   - Use `success` response helper
   - Add `export const dynamic = 'force-dynamic'`

2. Accept query parameters:
   - `limit` (default: 50, max: 100)
   - `cursor` (base64 encoded, optional)
   - `type` (optional: scheduler, error, maintenance, test, generic)
   - `status` (optional: sent, delivered, failed)

3. Call `getNotificationHistory(userId, options)` from service

4. Return response:
```json
{
  "notifications": [...],
  "cursor": "base64_encoded_cursor_or_null",
  "hasMore": true|false,
  "count": 50
}
```

5. Error handling:
   - Invalid cursor: return 400 with "Invalid cursor" message
   - Invalid type/status: return 400 with "Invalid filter value" message

Follow this pattern from devices route:
```javascript
import { withAuthAndErrorHandler, success } from '@/lib/core';
import { getNotificationHistory } from '@/lib/notificationHistoryService';

export const dynamic = 'force-dynamic';

export const GET = withAuthAndErrorHandler(async (request, context, session) => {
  const user = session.user;
  const { searchParams } = new URL(request.url);
  // ... parse params and call service
  return success({ notifications, cursor, hasMore, count });
}, 'Notifications/History');
```
  </action>
  <verify>
Test endpoint responds correctly:
```bash
# Check file exists with GET export
grep -q "export const GET" app/api/notifications/history/route.js && echo "OK"
```
  </verify>
  <done>
API endpoint `/api/notifications/history` exists that:
- Requires authentication
- Accepts limit, cursor, type, status parameters
- Returns paginated notifications with cursor
- Handles errors gracefully
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Firestore composite index definition</name>
  <files>firestore.indexes.json</files>
  <action>
Create or update `firestore.indexes.json` with composite index for notification queries:

```json
{
  "indexes": [
    {
      "collectionGroup": "notificationLogs",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "notificationLogs",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "type", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "notificationLogs",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "userId", "order": "ASCENDING" },
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "timestamp", "order": "DESCENDING" }
      ]
    }
  ],
  "fieldOverrides": []
}
```

This covers:
1. Basic userId + timestamp query (no filters)
2. userId + type + timestamp query (type filter)
3. userId + status + timestamp query (status filter)

Note: Index deployment is manual via `firebase deploy --only firestore:indexes` or auto-created on first query (Firebase Console link in logs).
  </action>
  <verify>
File exists with index definitions:
```bash
grep -q "notificationLogs" firestore.indexes.json && echo "OK"
```
  </verify>
  <done>
`firestore.indexes.json` exists with composite indexes for:
- userId + timestamp
- userId + type + timestamp
- userId + status + timestamp
  </done>
</task>

</tasks>

<verification>
All tasks complete when:
1. `lib/notificationHistoryService.js` exports `getNotificationHistory`
2. `/api/notifications/history` endpoint exists with GET handler
3. `firestore.indexes.json` contains notification log indexes
4. API can be tested with curl (after dev server start)
</verification>

<success_criteria>
- Notification history API returns paginated results
- Cursor pagination allows fetching next pages
- Type and status filters work correctly
- 90-day GDPR filter applied to all queries
- Firestore indexes defined for query optimization
</success_criteria>

<output>
After completion, create `.planning/phases/04-notification-history-a-devices/04-01-SUMMARY.md`
</output>
