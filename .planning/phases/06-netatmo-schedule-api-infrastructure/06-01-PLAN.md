---
phase: 06-netatmo-schedule-api-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/netatmoCacheService.js
autonomous: true

must_haves:
  truths:
    - "Schedule data is cached in Firebase with timestamp"
    - "Cache is validated before returning (age < 5 minutes)"
    - "Cache miss triggers fetch callback and stores result"
    - "Cache operations use environment-aware paths"
  artifacts:
    - path: "lib/netatmoCacheService.js"
      provides: "Firebase-based cache with TTL"
      exports: ["getCached", "invalidateCache", "CACHE_TTL_MS"]
      min_lines: 50
  key_links:
    - from: "lib/netatmoCacheService.js"
      to: "lib/firebaseAdmin.js"
      via: "adminDbGet, adminDbSet"
      pattern: "adminDb(Get|Set)"
    - from: "lib/netatmoCacheService.js"
      to: "lib/environmentHelper.js"
      via: "getEnvironmentPath"
      pattern: "getEnvironmentPath"
---

<objective>
Create Firebase-based cache service with 5-minute TTL for Netatmo API responses.

Purpose: Reduce Netatmo API calls by 90%+ through smart caching, preventing rate limit errors (500 calls/hour per user). This follows the existing pattern in netatmoTokenHelper.js (access_token_cache with expires_at).

Output: lib/netatmoCacheService.js with getCached() helper and cache invalidation
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-netatmo-schedule-api-infrastructure/06-RESEARCH.md

# Existing patterns to follow
@lib/netatmoTokenHelper.js (lines 141-150 for cache pattern)
@lib/firebaseAdmin.js (adminDbGet, adminDbSet)
@lib/environmentHelper.js (getEnvironmentPath)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Netatmo Cache Service</name>
  <files>lib/netatmoCacheService.js</files>
  <action>
Create lib/netatmoCacheService.js with the following:

1. Constants:
   - CACHE_TTL_MS = 5 * 60 * 1000 (5 minutes)
   - Export for testing/configuration

2. getCached(cacheKey, fetchFn) function:
   - Build path using getEnvironmentPath(`netatmo/cache/${cacheKey}`)
   - Read cached data via adminDbGet
   - Check if cached.data exists AND cached.cached_at exists
   - Calculate age: Date.now() - cached.cached_at
   - If age < CACHE_TTL_MS: return { data: cached.data, source: 'cache', age_seconds: age/1000 }
   - If cache miss/expired:
     - Call fetchFn() to get fresh data
     - Store via adminDbSet: { data: freshData, cached_at: Date.now() }
     - Return { data: freshData, source: 'api' }
   - Log cache HIT/MISS with emoji (follow existing logging patterns)

3. invalidateCache(cacheKey) function:
   - Build path using getEnvironmentPath
   - Delete via adminDbSet(path, null)
   - Return true

4. Export: getCached, invalidateCache, CACHE_TTL_MS

Follow existing code style:
- Use JSDoc comments
- Use async/await (not .then())
- Log with emoji prefixes (✅ for success, ❌ for errors)
- Import from @/lib paths (NOT relative paths)
  </action>
  <verify>
1. File exists: `ls lib/netatmoCacheService.js`
2. Exports correct: `grep -E "export.*(getCached|invalidateCache|CACHE_TTL_MS)" lib/netatmoCacheService.js`
3. Uses environment path: `grep "getEnvironmentPath" lib/netatmoCacheService.js`
4. No syntax errors: `node --check lib/netatmoCacheService.js` (may fail due to ESM, that's OK)
  </verify>
  <done>
- lib/netatmoCacheService.js exists
- Exports getCached, invalidateCache, CACHE_TTL_MS
- Uses adminDbGet/adminDbSet for Firebase operations
- Uses getEnvironmentPath for dev/prod namespacing
- 5-minute TTL implemented with timestamp-based validation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Unit Tests</name>
  <files>__tests__/lib/netatmoCacheService.test.js</files>
  <action>
Create __tests__/lib/netatmoCacheService.test.js:

1. Mock dependencies:
   - jest.mock('@/lib/firebaseAdmin')
   - jest.mock('@/lib/environmentHelper')

2. Test getCached():
   - "returns cached data when cache is valid (< 5 min old)"
   - "fetches fresh data when cache is expired (> 5 min old)"
   - "fetches fresh data when cache is empty"
   - "stores fresh data in cache after fetch"

3. Test invalidateCache():
   - "removes cache entry from Firebase"

4. Test CACHE_TTL_MS:
   - "exports 5-minute TTL constant"

Use jest patterns from existing tests in the project.
Follow existing test file structure from __tests__/ directory.
  </action>
  <verify>
1. Test file exists: `ls __tests__/lib/netatmoCacheService.test.js`
2. Tests pass: `npm test -- __tests__/lib/netatmoCacheService.test.js --passWithNoTests`
  </verify>
  <done>
- Unit tests exist for getCached and invalidateCache
- Tests mock Firebase dependencies
- Tests verify cache hit/miss behavior
- Tests verify 5-minute TTL logic
  </done>
</task>

</tasks>

<verification>
1. Cache service file exists with all exports
2. Environment-aware paths used throughout
3. Unit tests pass
4. Follows existing code patterns (netatmoTokenHelper.js)
</verification>

<success_criteria>
- lib/netatmoCacheService.js created with getCached(), invalidateCache(), CACHE_TTL_MS
- Uses Firebase Realtime Database via adminDbGet/adminDbSet
- Uses getEnvironmentPath for dev/prod namespacing
- 5-minute TTL implemented with timestamp validation
- Unit tests created and passing
</success_criteria>

<output>
After completion, create `.planning/phases/06-netatmo-schedule-api-infrastructure/06-01-SUMMARY.md`
</output>
