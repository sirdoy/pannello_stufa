---
phase: 06-netatmo-schedule-api-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/netatmoRateLimiter.js
autonomous: true

must_haves:
  truths:
    - "System tracks API calls per user with hourly window"
    - "System blocks requests when user exceeds 500 calls/hour"
    - "Rate limit status returns remaining quota and reset time"
    - "In-memory storage cleaned periodically to prevent leaks"
  artifacts:
    - path: "lib/netatmoRateLimiter.js"
      provides: "Per-user Netatmo API rate limiting"
      exports: ["checkNetatmoRateLimit", "trackNetatmoApiCall", "getNetatmoRateLimitStatus", "NETATMO_RATE_LIMIT"]
      min_lines: 80
  key_links:
    - from: "lib/netatmoRateLimiter.js"
      to: "existing rateLimiter.js pattern"
      via: "same in-memory Map approach"
      pattern: "new Map\\(\\)"
---

<objective>
Create Netatmo-specific rate limiter tracking API calls per user with 500 calls/hour limit.

Purpose: Prevent Netatmo API 429 errors by enforcing conservative rate limits (400 calls/hour buffer). This extends the existing rateLimiter.js pattern (in-memory Map with windowed tracking).

Output: lib/netatmoRateLimiter.js with rate checking, tracking, and status functions
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-netatmo-schedule-api-infrastructure/06-RESEARCH.md

# Existing pattern to extend
@lib/rateLimiter.js (existing in-memory rate limiting)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Netatmo Rate Limiter</name>
  <files>lib/netatmoRateLimiter.js</files>
  <action>
Create lib/netatmoRateLimiter.js with the following:

1. Constants:
   - NETATMO_RATE_LIMIT = 500 (calls per hour)
   - NETATMO_CONSERVATIVE_LIMIT = 400 (with buffer)
   - WINDOW_MS = 60 * 60 * 1000 (1 hour)

2. In-memory storage:
   - const userApiCalls = new Map()
   - Key: userId (string)
   - Value: { count: number, windowStart: number }

3. checkNetatmoRateLimit(userId) function:
   - Get current timestamp
   - Get userData from Map (default: { count: 0, windowStart: now })
   - If window expired (now - windowStart >= WINDOW_MS): reset count to 0
   - If count >= NETATMO_CONSERVATIVE_LIMIT:
     - Calculate resetInSeconds
     - Return { allowed: false, currentCount, resetInSeconds, limit: NETATMO_CONSERVATIVE_LIMIT }
   - Return { allowed: true, currentCount, remaining: LIMIT - count, limit: NETATMO_CONSERVATIVE_LIMIT }
   - Log with emoji: "‚è±Ô∏è Rate limit check: userId - count/limit"

4. trackNetatmoApiCall(userId) function:
   - Get/create userData
   - Increment count
   - Update Map
   - Log with emoji: "üìä API call tracked: userId - count/limit"

5. getNetatmoRateLimitStatus(userId) function:
   - Return current count, limit, remaining, windowStart, nextResetIn
   - Useful for debugging and UI display

6. cleanupOldEntries() function:
   - Remove entries older than 2 hours
   - Run on setInterval (every 10 minutes)
   - Log cleanup with emoji

7. Exports:
   - checkNetatmoRateLimit
   - trackNetatmoApiCall
   - getNetatmoRateLimitStatus
   - NETATMO_RATE_LIMIT (for testing/docs)
   - _internals: { userApiCalls, cleanupOldEntries } (for testing)

Follow existing rateLimiter.js style exactly.
  </action>
  <verify>
1. File exists: `ls lib/netatmoRateLimiter.js`
2. Exports correct: `grep -E "export.*(checkNetatmoRateLimit|trackNetatmoApiCall)" lib/netatmoRateLimiter.js`
3. Uses Map: `grep "new Map" lib/netatmoRateLimiter.js`
4. Conservative limit: `grep "400" lib/netatmoRateLimiter.js`
  </verify>
  <done>
- lib/netatmoRateLimiter.js exists
- Exports checkNetatmoRateLimit, trackNetatmoApiCall, getNetatmoRateLimitStatus
- Uses in-memory Map for tracking
- Implements 400 calls/hour conservative limit (500 actual, 100 buffer)
- Includes periodic cleanup to prevent memory leaks
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Unit Tests</name>
  <files>__tests__/lib/netatmoRateLimiter.test.js</files>
  <action>
Create __tests__/lib/netatmoRateLimiter.test.js:

1. Test checkNetatmoRateLimit():
   - "allows request when under limit"
   - "blocks request when limit reached"
   - "resets counter after window expires"
   - "returns correct remaining count"

2. Test trackNetatmoApiCall():
   - "increments counter for user"
   - "creates new entry for new user"

3. Test getNetatmoRateLimitStatus():
   - "returns correct status for tracked user"
   - "returns zero count for untracked user"

4. Test cleanup:
   - "removes expired entries"

Use jest.useFakeTimers() for time-based tests.
Follow existing __tests__/ patterns.
  </action>
  <verify>
1. Test file exists: `ls __tests__/lib/netatmoRateLimiter.test.js`
2. Tests pass: `npm test -- __tests__/lib/netatmoRateLimiter.test.js --passWithNoTests`
  </verify>
  <done>
- Unit tests exist for all exported functions
- Tests cover limit enforcement
- Tests cover window reset behavior
- Tests use fake timers for time-based logic
  </done>
</task>

</tasks>

<verification>
1. Rate limiter file exists with all exports
2. Conservative limit (400) implemented
3. In-memory cleanup prevents leaks
4. Unit tests pass
5. Follows existing rateLimiter.js patterns
</verification>

<success_criteria>
- lib/netatmoRateLimiter.js created with rate limit checking and tracking
- Uses in-memory Map (same pattern as existing rateLimiter.js)
- Implements 400 calls/hour conservative limit (100 buffer under 500)
- Includes cleanup interval to prevent memory leaks
- Unit tests created and passing
</success_criteria>

<output>
After completion, create `.planning/phases/06-netatmo-schedule-api-infrastructure/06-02-SUMMARY.md`
</output>
