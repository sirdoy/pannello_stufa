---
phase: 06-netatmo-schedule-api-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - app/api/netatmo/schedules/route.js
  - lib/netatmoApi.js
autonomous: true

must_haves:
  truths:
    - "GET /api/netatmo/schedules returns list of all schedules with active indicator"
    - "POST /api/netatmo/schedules switches to specified schedule"
    - "Responses indicate cache source (cache vs api)"
    - "Rate limit errors return 429 with retry-after header"
  artifacts:
    - path: "app/api/netatmo/schedules/route.js"
      provides: "Schedule list and switch endpoints"
      exports: ["GET", "POST"]
      min_lines: 80
    - path: "lib/netatmoApi.js"
      provides: "parseSchedules helper added"
      exports: ["parseSchedules"]
  key_links:
    - from: "app/api/netatmo/schedules/route.js"
      to: "lib/netatmoCacheService.js"
      via: "getCached import"
      pattern: "getCached"
    - from: "app/api/netatmo/schedules/route.js"
      to: "lib/netatmoRateLimiter.js"
      via: "checkNetatmoRateLimit import"
      pattern: "checkNetatmoRateLimit"
    - from: "app/api/netatmo/schedules/route.js"
      to: "lib/core/index.js"
      via: "withAuthAndErrorHandler, success, badRequest"
      pattern: "withAuthAndErrorHandler"
---

<objective>
Create API routes for Netatmo schedule operations with caching and rate limiting.

Purpose: Expose schedule data to frontend (Phase 9) with proper protection against rate limits. GET fetches with caching, POST switches schedule without caching (control operations are never cached).

Output: app/api/netatmo/schedules/route.js with GET (list) and POST (switch) handlers
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-netatmo-schedule-api-infrastructure/06-RESEARCH.md
@.planning/phases/06-netatmo-schedule-api-infrastructure/06-01-SUMMARY.md
@.planning/phases/06-netatmo-schedule-api-infrastructure/06-02-SUMMARY.md

# Existing API route pattern to follow
@app/api/netatmo/homestatus/route.js

# API utilities
@lib/core/index.js
@lib/netatmoApi.js
@lib/firebaseAdmin.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add parseSchedules helper to netatmoApi.js</name>
  <files>lib/netatmoApi.js</files>
  <action>
Add parseSchedules() helper function to lib/netatmoApi.js:

1. Add function after existing helpers (around line 327):

```javascript
/**
 * Parse schedules from homesdata response
 * Extracts schedule metadata: id, name, type, selected (active), zones, timetable
 * Filters out undefined values to prevent Firebase errors
 */
function parseSchedules(homesData) {
  if (!homesData || homesData.length === 0) return [];

  const home = homesData[0]; // Usually single home
  return (home.schedules || []).map(schedule => {
    const parsed = {
      id: schedule.id,
      name: schedule.name,
      type: schedule.type || 'therm', // 'therm', 'cooling', etc.
      selected: schedule.selected || false, // Is this the active schedule?
    };

    // Only add optional properties if they're defined
    if (schedule.zones && Array.isArray(schedule.zones)) {
      parsed.zones = schedule.zones.map(zone => ({
        id: zone.id,
        name: zone.name,
        type: zone.type,
        rooms: zone.rooms || [],
        temp: zone.temp,
      }));
    }

    if (schedule.timetable && Array.isArray(schedule.timetable)) {
      parsed.timetable = schedule.timetable.map(slot => ({
        m_offset: slot.m_offset, // Minutes from midnight Monday
        zone_id: slot.zone_id,
      }));
    }

    return parsed;
  });
}
```

2. Add to NETATMO_API object exports (around line 433):
   - Add parseSchedules to the object

3. Add to named exports (around line 486):
   - Add parseSchedules to export block

Follow existing code style (filterUndefined pattern from parseRooms/parseModules).
  </action>
  <verify>
1. Function exists: `grep "parseSchedules" lib/netatmoApi.js`
2. Exported: `grep -E "export.*parseSchedules|parseSchedules," lib/netatmoApi.js`
  </verify>
  <done>
- parseSchedules() function added to lib/netatmoApi.js
- Follows existing helper pattern (parseRooms, parseModules)
- Filters undefined values to prevent Firebase errors
- Exported in both NETATMO_API object and named exports
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Schedules API Route</name>
  <files>app/api/netatmo/schedules/route.js</files>
  <action>
Create app/api/netatmo/schedules/route.js:

1. Imports:
```javascript
import { withAuthAndErrorHandler, success, badRequest } from '@/lib/core';
import { requireNetatmoToken } from '@/lib/core/netatmoHelpers';
import { adminDbGet } from '@/lib/firebaseAdmin';
import { getEnvironmentPath } from '@/lib/environmentHelper';
import { getCached, invalidateCache } from '@/lib/netatmoCacheService';
import { checkNetatmoRateLimit, trackNetatmoApiCall } from '@/lib/netatmoRateLimiter';
import NETATMO_API from '@/lib/netatmoApi';
import { NextResponse } from 'next/server';

export const dynamic = 'force-dynamic';
```

2. GET handler - List schedules with caching:
```javascript
/**
 * GET /api/netatmo/schedules
 * Returns list of all schedules with active indicator
 * Cached for 5 minutes to reduce API calls
 */
export const GET = withAuthAndErrorHandler(async (req, session) => {
  const userId = session?.user?.sub || 'anonymous';

  // Rate limit check
  const rateCheck = checkNetatmoRateLimit(userId);
  if (!rateCheck.allowed) {
    return NextResponse.json(
      {
        error: 'RATE_LIMIT_EXCEEDED',
        message: `Limite API Netatmo raggiunto. Riprova tra ${rateCheck.resetInSeconds}s`,
        retryAfter: rateCheck.resetInSeconds,
      },
      {
        status: 429,
        headers: { 'Retry-After': String(rateCheck.resetInSeconds) },
      }
    );
  }

  const accessToken = await requireNetatmoToken();

  // Get schedules with cache
  const result = await getCached('schedules', async () => {
    // Track API call (only for actual API calls, not cache hits)
    trackNetatmoApiCall(userId);

    const homeId = await adminDbGet(getEnvironmentPath('netatmo/home_id'));
    if (!homeId) {
      throw new Error('home_id non trovato. Chiama prima /api/netatmo/homesdata');
    }

    const homesData = await NETATMO_API.getHomesData(accessToken);
    return NETATMO_API.parseSchedules(homesData);
  });

  return success({
    schedules: result.data,
    _source: result.source,
    _age_seconds: result.age_seconds || 0,
  });
}, 'Netatmo/Schedules');
```

3. POST handler - Switch schedule (no caching):
```javascript
/**
 * POST /api/netatmo/schedules
 * Switch to a different schedule
 * Body: { scheduleId: string }
 * Control operations are NEVER cached
 */
export const POST = withAuthAndErrorHandler(async (req, session) => {
  const userId = session?.user?.sub || 'anonymous';

  // Rate limit check
  const rateCheck = checkNetatmoRateLimit(userId);
  if (!rateCheck.allowed) {
    return NextResponse.json(
      {
        error: 'RATE_LIMIT_EXCEEDED',
        message: `Limite API Netatmo raggiunto. Riprova tra ${rateCheck.resetInSeconds}s`,
        retryAfter: rateCheck.resetInSeconds,
      },
      {
        status: 429,
        headers: { 'Retry-After': String(rateCheck.resetInSeconds) },
      }
    );
  }

  // Parse request body
  const body = await req.json();
  const { scheduleId } = body;

  if (!scheduleId) {
    return badRequest('scheduleId richiesto');
  }

  const accessToken = await requireNetatmoToken();

  // Get home_id
  const homeId = await adminDbGet(getEnvironmentPath('netatmo/home_id'));
  if (!homeId) {
    return badRequest('home_id non trovato. Chiama prima /api/netatmo/homesdata');
  }

  // Track API call
  trackNetatmoApiCall(userId);

  // Switch schedule
  const switched = await NETATMO_API.switchHomeSchedule(accessToken, homeId, scheduleId);

  if (!switched) {
    return badRequest('Impossibile cambiare schedule');
  }

  // Invalidate cache after successful switch
  await invalidateCache('schedules');

  console.log(`âœ… Schedule switched to ${scheduleId} by ${userId}`);

  return success({
    success: true,
    scheduleId,
    message: 'Schedule cambiato con successo',
  });
}, 'Netatmo/Schedules');
```

Follow existing API route patterns exactly (homestatus/route.js).
  </action>
  <verify>
1. File exists: `ls app/api/netatmo/schedules/route.js`
2. Exports GET and POST: `grep -E "export const (GET|POST)" app/api/netatmo/schedules/route.js`
3. Uses cache service: `grep "getCached" app/api/netatmo/schedules/route.js`
4. Uses rate limiter: `grep "checkNetatmoRateLimit" app/api/netatmo/schedules/route.js`
5. Force dynamic: `grep "force-dynamic" app/api/netatmo/schedules/route.js`
  </verify>
  <done>
- app/api/netatmo/schedules/route.js created
- GET handler returns cached schedule list
- POST handler switches schedule and invalidates cache
- Both handlers check rate limits before API calls
- 429 responses include Retry-After header
- Follows existing API route patterns
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Integration Test</name>
  <files>__tests__/api/netatmo/schedules.test.js</files>
  <action>
Create __tests__/api/netatmo/schedules.test.js:

1. Mock all dependencies:
   - jest.mock('@/lib/netatmoCacheService')
   - jest.mock('@/lib/netatmoRateLimiter')
   - jest.mock('@/lib/netatmoApi')
   - jest.mock('@/lib/firebaseAdmin')
   - jest.mock('@/lib/core/netatmoHelpers')

2. Test GET /api/netatmo/schedules:
   - "returns cached schedules when cache hit"
   - "fetches fresh schedules when cache miss"
   - "returns 429 when rate limit exceeded"
   - "includes _source field in response"

3. Test POST /api/netatmo/schedules:
   - "switches schedule successfully"
   - "returns 400 when scheduleId missing"
   - "returns 429 when rate limit exceeded"
   - "invalidates cache after successful switch"

Follow existing API test patterns from __tests__/api/ directory.
  </action>
  <verify>
1. Test file exists: `ls __tests__/api/netatmo/schedules.test.js`
2. Tests pass: `npm test -- __tests__/api/netatmo/schedules.test.js --passWithNoTests`
  </verify>
  <done>
- Integration tests exist for GET and POST handlers
- Tests mock cache and rate limiter dependencies
- Tests verify cache behavior and rate limit enforcement
- Tests verify 429 response format
  </done>
</task>

</tasks>

<verification>
1. API routes file exists with GET and POST exports
2. parseSchedules helper added to netatmoApi.js
3. GET uses caching, POST invalidates cache
4. Rate limiting enforced on both endpoints
5. Integration tests pass
6. Manual test: `curl -X GET http://localhost:3000/api/netatmo/schedules` returns schedules (requires auth)
</verification>

<success_criteria>
- app/api/netatmo/schedules/route.js created with GET (list) and POST (switch) handlers
- GET returns schedules with cache source indicator (_source: 'cache' or 'api')
- POST switches schedule and invalidates cache
- Both endpoints enforce rate limits (429 + Retry-After header)
- parseSchedules helper added to lib/netatmoApi.js
- Integration tests created and passing
</success_criteria>

<output>
After completion, create `.planning/phases/06-netatmo-schedule-api-infrastructure/06-03-SUMMARY.md`
</output>
