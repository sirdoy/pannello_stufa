---
phase: 07-stove-health-monitoring-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/healthMonitoring.js
  - lib/healthLogger.js
  - __tests__/lib/healthMonitoring.test.js
  - __tests__/lib/healthLogger.test.js
autonomous: true

must_haves:
  truths:
    - "Health check returns stove status (online/offline/error) with connection details"
    - "Health check detects state mismatch (stove scheduled ON but actually OFF)"
    - "Health check includes Netatmo heating demand for coordination verification"
    - "Every health check is logged to Firestore with timestamp and status"
  artifacts:
    - path: "lib/healthMonitoring.js"
      provides: "checkUserStoveHealth function with parallel API fetching"
      exports: ["checkUserStoveHealth", "determineConnectionStatus", "detectStateMismatch"]
    - path: "lib/healthLogger.js"
      provides: "Firestore logging with cron run parent + check subcollections"
      exports: ["logHealthCheckRun", "getRecentHealthLogs"]
  key_links:
    - from: "lib/healthMonitoring.js"
      to: "lib/stoveApi.js"
      via: "getStoveStatus import"
      pattern: "import.*getStoveStatus.*from.*stoveApi"
    - from: "lib/healthMonitoring.js"
      to: "lib/netatmoApi.js"
      via: "getHomeStatus for heating demand"
      pattern: "getHomeStatus"
    - from: "lib/healthLogger.js"
      to: "lib/firebaseAdmin.js"
      via: "getAdminFirestore"
      pattern: "getAdminFirestore"
---

<objective>
Create core health check logic and Firestore logging for stove health monitoring

Purpose: Establishes the foundation for automated stove health monitoring by implementing status checking, state mismatch detection, and event logging. This enables the cron endpoint (07-02) to perform health checks every minute and maintain a complete audit trail.

Output:
- `lib/healthMonitoring.js` - Core health check logic with parallel API fetching
- `lib/healthLogger.js` - Firestore event logging with structured format
- Unit tests for both services
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-stove-health-monitoring-backend/07-CONTEXT.md
@.planning/phases/07-stove-health-monitoring-backend/07-RESEARCH.md
@lib/stoveApi.js
@lib/netatmoApi.js
@lib/firebaseAdmin.js
@lib/notificationLogger.js
@app/api/scheduler/check/route.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Health Monitoring Service</name>
  <files>lib/healthMonitoring.js, __tests__/lib/healthMonitoring.test.js</files>
  <action>
Create `lib/healthMonitoring.js` with core health check logic:

**checkUserStoveHealth(userId)** - Main function:
1. Fetch data in parallel using Promise.allSettled (graceful degradation):
   - `getStoveStatus()` from lib/stoveApi.js
   - User's stove schedule from Firebase RTDB (scheduler/schedule path)
   - Netatmo heating demand via getHomeStatus (optional, for coordination verification)
2. Return health object:
   ```javascript
   {
     userId,
     timestamp: Date.now(),
     stoveStatus: { status, error, isSandbox } | null,
     stoveError: string | null,
     expectedState: 'ON' | 'OFF' | null (derived from schedule),
     netatmoDemand: 'heating' | 'idle' | null,
     connectionStatus: 'online' | 'offline' | 'error',
     stateMismatch: { detected: boolean, expected: string, actual: string } | null,
   }
   ```

**determineConnectionStatus(stoveResult)** - Helper:
- 'online' if stove API returned valid status
- 'offline' if STOVE_TIMEOUT error
- 'error' if other error (API error, parsing error)

**detectStateMismatch(stoveResult, scheduleResult, netatmoResult)** - Helper:
- Define state categories:
  - ON states: WORK, MODULATION (stove actively heating)
  - STARTING states: START (allow 15-min grace period before flagging)
  - OFF states: STANDBY, SHUTDOWN, FINALIZZAZIONE
  - ERROR states: Any status containing error code
- Compare actual stove state vs expected from schedule
- Include Netatmo demand as secondary signal (if heating but stove OFF, potential issue)
- Return mismatch object if detected, null otherwise

**getExpectedStateFromSchedule(userId)** - Helper:
- Read scheduler/mode from Firebase
- If mode is 'auto', check scheduler/schedule for current time slot
- Return 'ON' or 'OFF' based on current slot, or null if manual/unknown

Follow patterns from existing scheduler/check/route.js for status parsing (e.g., `currentStatus.includes('WORK')`).

Create unit tests covering:
- checkUserStoveHealth returns proper structure
- determineConnectionStatus handles all error cases
- detectStateMismatch correctly identifies ON vs OFF mismatches
- STARTING state has grace period (not flagged as mismatch)
- Partial API failures (Netatmo down) don't crash health check
  </action>
  <verify>
- `npm test -- --testPathPattern="healthMonitoring" --passWithNoTests` passes
- lib/healthMonitoring.js exports checkUserStoveHealth, determineConnectionStatus, detectStateMismatch
  </verify>
  <done>
Health monitoring service returns stove connection status and detects state mismatches using parallel API fetching with graceful degradation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Health Logger Service</name>
  <files>lib/healthLogger.js, __tests__/lib/healthLogger.test.js</files>
  <action>
Create `lib/healthLogger.js` following the pattern from notificationLogger.js:

**logHealthCheckRun(results, options = {})** - Main function:
1. Accept array of health check results from Promise.allSettled
2. Create parent document in `healthMonitoring` collection:
   ```javascript
   {
     timestamp: Timestamp.now(),
     checkedCount: results.length,
     successCount: results.filter(r => r.status === 'fulfilled').length,
     failureCount: results.filter(r => r.status === 'rejected').length,
     hasStateMismatch: results.some(r => r.value?.stateMismatch?.detected),
     duration: options.duration || 0, // execution time in ms
   }
   ```
3. Create subcollection `checks` under parent document for individual results:
   ```javascript
   {
     userId: string,
     status: 'fulfilled' | 'rejected',
     connectionStatus: 'online' | 'offline' | 'error' | null,
     stoveStatus: string | null, // e.g., 'WORK', 'STANDBY'
     expectedState: 'ON' | 'OFF' | null,
     netatmoDemand: 'heating' | 'idle' | null,
     stateMismatch: { detected, expected, actual } | null,
     error: string | null,
   }
   ```
4. Use batch writes for efficiency
5. Return parent document ID
6. Wrap in try-catch, don't throw on logging failure (fire-and-forget pattern)

**getRecentHealthLogs(options = {})** - Query helper:
- Default last 24 hours
- Optional: limit, startDate, endDate, hasStateMismatch filter
- Order by timestamp descending
- Return array with id and converted timestamps

Follow fire-and-forget pattern from notificationLogger.js - logging failures should NOT block health check flow.

Create unit tests covering:
- logHealthCheckRun creates parent document with correct aggregates
- Subcollection documents include all fields
- Fire-and-forget: returns null on Firestore error instead of throwing
- getRecentHealthLogs applies filters correctly
  </action>
  <verify>
- `npm test -- --testPathPattern="healthLogger" --passWithNoTests` passes
- lib/healthLogger.js exports logHealthCheckRun, getRecentHealthLogs
  </verify>
  <done>
Health logger service writes monitoring events to Firestore with parent/subcollection structure for audit trail and dashboard queries
  </done>
</task>

</tasks>

<verification>
Run all tests:
```bash
npm test -- --testPathPattern="health" --passWithNoTests
```

Verify exports:
```bash
grep -E "export (async function|function|const)" lib/healthMonitoring.js lib/healthLogger.js
```

Check imports are valid:
```bash
node -e "require('./lib/healthMonitoring.js')" 2>&1 | head -5
node -e "require('./lib/healthLogger.js')" 2>&1 | head -5
```
</verification>

<success_criteria>
- [ ] lib/healthMonitoring.js exports checkUserStoveHealth function
- [ ] checkUserStoveHealth uses Promise.allSettled for parallel fetching
- [ ] State mismatch detection compares stove status vs expected schedule
- [ ] STARTING state has grace period (not flagged immediately)
- [ ] lib/healthLogger.js exports logHealthCheckRun function
- [ ] Firestore logging uses parent/subcollection structure
- [ ] Fire-and-forget pattern: logging failures don't throw
- [ ] All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-stove-health-monitoring-backend/07-01-SUMMARY.md`
</output>
