---
phase: 07-stove-health-monitoring-backend
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - lib/healthDeadManSwitch.js
  - app/api/health-monitoring/check/route.js
  - lib/envValidator.js
  - __tests__/lib/healthDeadManSwitch.test.js
  - __tests__/lib/envValidator.test.js
autonomous: true

must_haves:
  truths:
    - "Cron endpoint updates dead man's switch timestamp before any processing"
    - "Dead man's switch alerts admin if cron hasn't run in 10+ minutes"
    - "Environment variables are validated on startup in production"
    - "Cron execution logs include timestamp, duration, and status"
  artifacts:
    - path: "app/api/health-monitoring/check/route.js"
      provides: "Cron endpoint with HMAC security"
      exports: ["GET"]
    - path: "lib/healthDeadManSwitch.js"
      provides: "Dead man's switch tracking and alerting"
      exports: ["updateDeadManSwitch", "checkDeadManSwitch"]
    - path: "lib/envValidator.js"
      provides: "Environment variable validation"
      exports: ["validateHealthMonitoringEnv"]
  key_links:
    - from: "app/api/health-monitoring/check/route.js"
      to: "lib/healthMonitoring.js"
      via: "checkUserStoveHealth import"
      pattern: "import.*checkUserStoveHealth.*from.*healthMonitoring"
    - from: "app/api/health-monitoring/check/route.js"
      to: "lib/healthLogger.js"
      via: "logHealthCheckRun import"
      pattern: "import.*logHealthCheckRun.*from.*healthLogger"
    - from: "app/api/health-monitoring/check/route.js"
      to: "lib/core/middleware.js"
      via: "withCronSecret wrapper"
      pattern: "withCronSecret"
    - from: "lib/healthDeadManSwitch.js"
      to: "lib/firebaseAdmin.js"
      via: "adminDbSet/adminDbGet for RTDB"
      pattern: "adminDbSet|adminDbGet"
---

<objective>
Create cron endpoint for health monitoring with dead man's switch and environment validation

Purpose: Exposes the health check infrastructure as a secured cron endpoint that runs every minute, maintains dead man's switch for reliability monitoring, and validates environment configuration. This completes the backend monitoring infrastructure for Phase 7.

Output:
- `/api/health-monitoring/check` - HMAC-secured cron endpoint
- `lib/healthDeadManSwitch.js` - Dead man's switch service
- `lib/envValidator.js` - Environment validation service
- Unit tests for new services
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-stove-health-monitoring-backend/07-CONTEXT.md
@.planning/phases/07-stove-health-monitoring-backend/07-RESEARCH.md
@.planning/phases/07-stove-health-monitoring-backend/07-01-SUMMARY.md
@lib/core/middleware.js
@lib/firebaseAdmin.js
@app/api/scheduler/check/route.js
@app/components/CronHealthBanner.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Dead Man's Switch Service</name>
  <files>lib/healthDeadManSwitch.js, __tests__/lib/healthDeadManSwitch.test.js</files>
  <action>
Create `lib/healthDeadManSwitch.js` for tracking cron execution health:

**updateDeadManSwitch()** - Called at START of every cron execution:
1. Write current ISO timestamp to RTDB at `healthMonitoring/lastCheck`
2. Use adminDbSet from firebaseAdmin.js
3. Return true on success, false on error (don't throw)
4. This runs FIRST in cron handler, before any other logic

**checkDeadManSwitch()** - Check if cron is stale (for alerting):
1. Read `healthMonitoring/lastCheck` from RTDB
2. If null/missing: return { stale: true, reason: 'never_run' }
3. Calculate elapsed time from lastCheck to now
4. THRESHOLD: 10 minutes (600000 ms)
5. If elapsed > THRESHOLD: return { stale: true, elapsed, reason: 'timeout' }
6. Otherwise: return { stale: false, elapsed, lastCheck }

**alertDeadManSwitch(reason)** - Send alert when cron is stale:
1. Use triggerMaintenanceAlertServer from notificationTriggersServer.js
2. Message based on reason:
   - 'never_run': "Health monitoring cron has never executed"
   - 'timeout': "Health monitoring cron hasn't run in {elapsed} minutes"
3. Fire-and-forget: log result but don't throw

**Fallback check pattern (from RESEARCH.md):**
When dead man's switch triggers, attempt one manual health check:
- If check succeeds: "Cron service not running but system responsive"
- If check fails: "System completely unresponsive"

Create unit tests covering:
- updateDeadManSwitch writes timestamp to RTDB
- checkDeadManSwitch returns stale:true when elapsed > 10 min
- checkDeadManSwitch handles missing lastCheck
- alertDeadManSwitch doesn't throw on notification failure
  </action>
  <verify>
- `npm test -- --testPathPattern="healthDeadManSwitch" --passWithNoTests` passes
- lib/healthDeadManSwitch.js exports updateDeadManSwitch, checkDeadManSwitch, alertDeadManSwitch
  </verify>
  <done>
Dead man's switch service tracks cron execution and can alert admin when cron is stale (10+ minutes without execution)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Environment Validator</name>
  <files>lib/envValidator.js, __tests__/lib/envValidator.test.js</files>
  <action>
Create `lib/envValidator.js` for startup environment validation:

**validateHealthMonitoringEnv()** - Validate required env vars:
1. Required variables for health monitoring:
   - `ADMIN_USER_ID` - Required for sending alerts
   - `CRON_SECRET` - Required for endpoint security
   - `FIREBASE_ADMIN_PROJECT_ID` - Required for Firestore logging
   - `FIREBASE_ADMIN_CLIENT_EMAIL` - Required for Firestore logging
   - `FIREBASE_ADMIN_PRIVATE_KEY` - Required for Firestore logging
2. Optional but checked:
   - `NETATMO_CLIENT_ID` / `NETATMO_CLIENT_SECRET` - For heating demand check
3. Return validation result:
   ```javascript
   {
     valid: boolean,
     missing: string[], // names of missing required vars
     warnings: string[], // optional vars missing
   }
   ```
4. Log validation result (pass/fail) at startup

**validateNetatmoEnv()** - Netatmo-specific validation:
1. Check dev vs prod credentials pattern:
   - Development: env vars may be different
   - Production: warn if using test credentials
2. Return { valid, environment: 'dev'|'prod', warnings }

Create unit tests covering:
- validateHealthMonitoringEnv returns missing array for absent vars
- validateHealthMonitoringEnv returns valid:true when all present
- Netatmo env detection distinguishes dev/prod
  </action>
  <verify>
- `npm test -- --testPathPattern="envValidator" --passWithNoTests` passes
- lib/envValidator.js exports validateHealthMonitoringEnv, validateNetatmoEnv
  </verify>
  <done>
Environment validator ensures required configuration is present and warns about misconfiguration
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Health Monitoring Cron Endpoint</name>
  <files>app/api/health-monitoring/check/route.js</files>
  <action>
Create `/api/health-monitoring/check` cron endpoint following scheduler/check pattern:

```javascript
import { withCronSecret, success } from '@/lib/core';
import { updateDeadManSwitch, checkDeadManSwitch, alertDeadManSwitch } from '@/lib/healthDeadManSwitch';
import { checkUserStoveHealth } from '@/lib/healthMonitoring';
import { logHealthCheckRun } from '@/lib/healthLogger';
import { validateHealthMonitoringEnv } from '@/lib/envValidator';

export const dynamic = 'force-dynamic';

export const GET = withCronSecret(async (request) => {
  const startTime = Date.now();

  // 1. Update dead man's switch FIRST (before any logic that could fail)
  await updateDeadManSwitch();

  // 2. Validate environment (log warnings but continue)
  const envValidation = validateHealthMonitoringEnv();
  if (!envValidation.valid) {
    console.warn('⚠️ Health monitoring env validation failed:', envValidation.missing);
    // Continue anyway - might still partially work
  }

  // 3. Get users to check (for now, just admin user)
  const users = process.env.ADMIN_USER_ID ? [process.env.ADMIN_USER_ID] : [];

  if (users.length === 0) {
    console.warn('⚠️ No users to check (ADMIN_USER_ID not set)');
    return success({
      checked: 0,
      timestamp: Date.now(),
      duration: Date.now() - startTime,
      warning: 'ADMIN_USER_ID not configured',
    });
  }

  // 4. Check each user's stove health in parallel
  const results = await Promise.allSettled(
    users.map(userId => checkUserStoveHealth(userId))
  );

  // 5. Log results to Firestore (fire-and-forget)
  const duration = Date.now() - startTime;
  logHealthCheckRun(results, { duration }).catch(err =>
    console.error('Failed to log health check:', err)
  );

  // 6. Prepare response
  const successCount = results.filter(r => r.status === 'fulfilled').length;
  const failureCount = results.filter(r => r.status === 'rejected').length;
  const mismatches = results
    .filter(r => r.status === 'fulfilled' && r.value?.stateMismatch?.detected)
    .map(r => ({
      userId: r.value.userId,
      expected: r.value.stateMismatch.expected,
      actual: r.value.stateMismatch.actual,
    }));

  // 7. Log summary
  console.log(`✅ Health check complete: ${successCount}/${users.length} users, ${mismatches.length} mismatches`);

  return success({
    checked: users.length,
    successCount,
    failureCount,
    mismatches,
    timestamp: Date.now(),
    duration,
  });
}, 'HealthMonitoring/Check');
```

Key points:
- Use `withCronSecret` from lib/core/middleware.js (supports query param + header)
- Update dead man's switch BEFORE any other processing
- Use Promise.allSettled (not Promise.all) for graceful degradation
- Fire-and-forget logging - don't let Firestore errors block response
- Include duration in response for monitoring
- Log context: 'HealthMonitoring/Check'
  </action>
  <verify>
- File exists at app/api/health-monitoring/check/route.js
- Exports `GET` function wrapped with `withCronSecret`
- Uses `export const dynamic = 'force-dynamic'`

Manual verification:
```bash
# Test with secret (should work)
curl "http://localhost:3000/api/health-monitoring/check?secret=${CRON_SECRET}"

# Test without secret (should 401)
curl "http://localhost:3000/api/health-monitoring/check"
```
  </verify>
  <done>
Health monitoring cron endpoint executes health checks every minute with HMAC security, dead man's switch tracking, and Firestore logging
  </done>
</task>

</tasks>

<verification>
Run all tests:
```bash
npm test -- --testPathPattern="health|envValidator" --passWithNoTests
```

Verify endpoint exists:
```bash
ls -la app/api/health-monitoring/check/route.js
```

Verify exports:
```bash
grep -E "export (async function|function|const)" lib/healthDeadManSwitch.js lib/envValidator.js
```

Check imports in route:
```bash
grep "import" app/api/health-monitoring/check/route.js
```
</verification>

<success_criteria>
- [ ] /api/health-monitoring/check endpoint exists and uses withCronSecret
- [ ] Dead man's switch updates RTDB at healthMonitoring/lastCheck
- [ ] Dead man's switch detects stale cron (10+ min threshold)
- [ ] Environment validator checks required env vars
- [ ] Cron endpoint logs duration in response
- [ ] Cron endpoint uses Promise.allSettled for graceful degradation
- [ ] All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-stove-health-monitoring-backend/07-02-SUMMARY.md`
</output>
