---
phase: 08-stove-thermostat-integration-correction
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - lib/coordinationDebounce.js
  - lib/coordinationNotificationThrottle.js
  - __tests__/lib/coordinationDebounce.test.js
  - __tests__/lib/coordinationNotificationThrottle.test.js
autonomous: true

must_haves:
  truths:
    - "System debounces stove state changes (2-min delay before applying coordination)"
    - "Debounce timer cancels if stove turns OFF during wait period"
    - "Early shutoff handling: 30s retry timer when stove OFF during debounce"
    - "Global notification throttle enforces max 1 notification per 30 minutes"
    - "Events are always logged to Firestore regardless of notification throttling"
  artifacts:
    - path: "lib/coordinationDebounce.js"
      provides: "Debounce timer management with cancellation"
      exports: ["startDebounceTimer", "cancelDebounceTimer", "hasPendingDebounce", "getDebounceStatus"]
    - path: "lib/coordinationNotificationThrottle.js"
      provides: "Global notification deduplication with 30-min window"
      exports: ["shouldSendCoordinationNotification", "recordNotificationSent", "getThrottleStatus"]
  key_links:
    - from: "lib/coordinationDebounce.js"
      to: "In-memory Map"
      via: "setTimeout/clearTimeout like rateLimiter.js"
      pattern: "activeTimers.*Map"
    - from: "lib/coordinationDebounce.js"
      to: "lib/coordinationState.js"
      via: "Update pendingDebounce state flag"
      pattern: "updateCoordinationState"
    - from: "lib/coordinationNotificationThrottle.js"
      to: "In-memory Map"
      via: "Timestamp tracking like rateLimiter.js"
      pattern: "lastNotification.*Map"
---

<objective>
Implement debounce timer and notification throttling services for coordination control.

Purpose: Prevent rapid state changes from triggering multiple coordination actions (debouncing) and prevent notification spam by enforcing a global 30-minute window across all coordination event types (global throttle, not per-type).

Output: Two in-memory services following the Map-based pattern from rateLimiter.js - coordinationDebounce.js for timing control, coordinationNotificationThrottle.js for notification deduplication.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-stove-thermostat-integration-correction/08-CONTEXT.md
@.planning/phases/08-stove-thermostat-integration-correction/08-RESEARCH.md
@.planning/phases/08-stove-thermostat-integration-correction/08-01-SUMMARY.md
@lib/rateLimiter.js
@lib/coordinationState.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Debounce Timer Service</name>
  <files>lib/coordinationDebounce.js, __tests__/lib/coordinationDebounce.test.js</files>
  <action>
Create `lib/coordinationDebounce.js` for managing coordination debounce timers.

Follow the in-memory Map pattern from `rateLimiter.js`:
- `const activeTimers = new Map()` for tracking timers by userId
- Use native setTimeout/clearTimeout
- Timers do NOT persist across server restarts (this is intentional per RESEARCH.md)

Timer entry structure:
```javascript
{
  timer: <setTimeout handle>,
  startedAt: number,       // Date.now() when timer started
  targetState: 'ON'|'OFF', // What state triggered the debounce
  duration: number,        // Duration in ms
}
```

Implement functions:

**startDebounceTimer(userId, targetState, callback, delayMs = 120000)**
- Cancel existing timer for userId if any
- Create new setTimeout with callback
- Store timer info in Map
- Update coordinationState: `await updateCoordinationState({ pendingDebounce: true, debounceStartedAt: Date.now() })`
- Return { started: true, duration: delayMs }

**cancelDebounceTimer(userId)**
- Clear timeout if exists
- Delete from Map
- Update coordinationState: `await updateCoordinationState({ pendingDebounce: false, debounceStartedAt: null })`
- Return { cancelled: boolean }

**hasPendingDebounce(userId)**
- Return boolean: true if timer exists for userId

**getDebounceStatus(userId)**
- Return { pending: boolean, startedAt: number|null, remainingMs: number|null, targetState: string|null }

**handleStoveStateChange(userId, newState, callback)**
This is the main coordination function that implements the context decisions:
- If newState is 'ON' and no pending debounce: start 2-min (120000ms) timer
- If newState is 'OFF' during debounce with targetState 'ON':
  - Cancel existing timer
  - Start shorter 30-second (30000ms) retry timer (handles quick restarts)
- If newState is 'OFF' and no pending debounce: execute immediately (restore setpoints)
- If newState matches targetState: no change needed

Add cleanup interval like rateLimiter.js (every 5 minutes, clear stale entries).

Create comprehensive tests using jest.useFakeTimers():
- startDebounceTimer creates timer and stores in Map
- startDebounceTimer cancels existing timer for same user
- startDebounceTimer updates coordinationState.pendingDebounce to true
- cancelDebounceTimer clears timer
- cancelDebounceTimer updates coordinationState.pendingDebounce to false
- hasPendingDebounce returns correct status
- getDebounceStatus returns remaining time
- handleStoveStateChange starts 2-min timer on ON
- handleStoveStateChange applies 30s retry on OFF during debounce
- handleStoveStateChange executes immediately on OFF with no debounce
- Timer callback fires after delay
- Cleanup removes old entries
  </action>
  <verify>Run `npm test -- __tests__/lib/coordinationDebounce.test.js` - all tests pass</verify>
  <done>Debounce service manages in-memory timers with 2-min default delay, state persistence via coordinationState, and early cancellation/retry logic</done>
</task>

<task type="auto">
  <name>Task 2: Create Notification Throttle Service</name>
  <files>lib/coordinationNotificationThrottle.js, __tests__/lib/coordinationNotificationThrottle.test.js</files>
  <action>
Create `lib/coordinationNotificationThrottle.js` for global coordination notification deduplication.

This is DIFFERENT from rateLimiter.js which is per-notification-type. This service enforces a GLOBAL window across ALL coordination event types.

Per CONTEXT.md: "Global throttle - max 1 notification total every 30 minutes across all coordination events"

In-memory storage:
```javascript
const lastNotificationSent = new Map(); // userId -> timestamp
const GLOBAL_THROTTLE_MS = 30 * 60 * 1000; // 30 minutes
```

Implement functions:

**shouldSendCoordinationNotification(userId)**
- Check if user has sent any coordination notification in last 30 minutes
- Return { allowed: boolean, waitSeconds: number, reason: string|null }
- reason: 'global_throttle' if blocked, null if allowed

**recordNotificationSent(userId)**
- Store current timestamp for userId
- Called after successfully sending notification

**getThrottleStatus(userId)**
- Return { lastSentAt: number|null, nextAllowedAt: number|null, waitSeconds: number }

**clearThrottle(userId)** (for testing)
- Remove user from throttle map

Note: This service does NOT send notifications - it only decides whether sending is allowed. The actual sending is done by caller, which should:
1. Check shouldSendCoordinationNotification()
2. If allowed: send notification, then recordNotificationSent()
3. If not allowed: skip notification but ALWAYS log event to Firestore

Add cleanup interval (every 5 minutes, remove entries older than 30 minutes).

Create comprehensive tests:
- shouldSendCoordinationNotification allows first notification
- shouldSendCoordinationNotification blocks within 30-min window
- shouldSendCoordinationNotification allows after 30-min window expires
- recordNotificationSent updates timestamp
- getThrottleStatus returns correct wait time
- Throttle is global (blocks all event types, not per-type)
- clearThrottle removes user entry
- Cleanup removes expired entries
  </action>
  <verify>Run `npm test -- __tests__/lib/coordinationNotificationThrottle.test.js` - all tests pass</verify>
  <done>Global notification throttle enforces 30-min window across all coordination events per user</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm test -- coordinationDebounce coordinationNotificationThrottle` - All tests pass
2. Debounce service uses in-memory Map AND persists pendingDebounce flag to coordinationState
3. Notification throttle is GLOBAL per user, not per event type
4. Both services have automatic cleanup to prevent memory leaks
</verification>

<success_criteria>
- Two new services created with in-memory Map-based pattern
- Debounce handles 2-min delay, early cancellation, 30s retry, and state persistence
- Notification throttle enforces global 30-min window
- Both services follow rateLimiter.js patterns (cleanup intervals, memory management)
- All tests pass (expect ~15-20 new tests)
</success_criteria>

<output>
After completion, create `.planning/phases/08-stove-thermostat-integration-correction/08-02-SUMMARY.md`
</output>
