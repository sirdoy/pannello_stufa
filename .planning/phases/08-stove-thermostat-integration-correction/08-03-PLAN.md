---
phase: 08-stove-thermostat-integration-correction
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - lib/coordinationUserIntent.js
  - lib/coordinationPauseCalculator.js
  - __tests__/lib/coordinationUserIntent.test.js
  - __tests__/lib/coordinationPauseCalculator.test.js
autonomous: true

must_haves:
  truths:
    - "System detects user manual setpoint changes by comparing current vs expected"
    - "System detects user mode changes (away, frost guard, etc.)"
    - "Manual changes pause automation until next schedule slot begins"
    - "Pause duration is calculated from Netatmo schedule timetable"
    - "Stove activity during pause respects user intent (no override applied)"
  artifacts:
    - path: "lib/coordinationUserIntent.js"
      provides: "User intent detection via Netatmo API comparison"
      exports: ["detectUserIntent", "wasManuallyChanged"]
    - path: "lib/coordinationPauseCalculator.js"
      provides: "Calculate pause end time from Netatmo schedule"
      exports: ["calculatePauseUntil", "getNextScheduleSlot", "formatPauseReason"]
  key_links:
    - from: "lib/coordinationUserIntent.js"
      to: "lib/netatmoApi.js"
      via: "getHomeStatus for current setpoint"
      pattern: "NETATMO_API\\.getHomeStatus"
    - from: "lib/coordinationUserIntent.js"
      to: "lib/coordinationState.js"
      via: "Compare against expected setpoint in state"
      pattern: "getCoordinationState"
    - from: "lib/coordinationPauseCalculator.js"
      to: "lib/netatmoCacheService.js"
      via: "Get cached schedule for pause calculation"
      pattern: "getCachedSchedule"
---

<objective>
Implement user intent detection and dynamic pause duration calculation for respecting manual thermostat changes.

Purpose: Detect when users manually change thermostat setpoints (via app or physical device) and pause automation until the next schedule slot. This implements the "user intent is sacred" principle from CONTEXT.md.

Output: Two services - coordinationUserIntent.js for detecting manual changes, coordinationPauseCalculator.js for calculating schedule-aware pause duration.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-stove-thermostat-integration-correction/08-CONTEXT.md
@.planning/phases/08-stove-thermostat-integration-correction/08-RESEARCH.md
@.planning/phases/08-stove-thermostat-integration-correction/08-01-SUMMARY.md
@lib/netatmoApi.js
@lib/netatmoCacheService.js
@lib/coordinationState.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create User Intent Detection Service</name>
  <files>lib/coordinationUserIntent.js, __tests__/lib/coordinationUserIntent.test.js</files>
  <action>
Create `lib/coordinationUserIntent.js` for detecting manual thermostat changes.

Per CONTEXT.md: "Any setpoint change from app/device counts as manual (not just physical thermostat)"

Detection logic:
- Compare current Netatmo setpoint against expected (stored in coordination state)
- Check if mode changed to non-standard (away, hg/frost guard, off)
- Tolerance: 0.5°C for setpoint comparison (accounts for rounding)

Implement functions:

**detectUserIntent(homeId, roomIds, expectedSetpoints)**
Parameters:
- homeId: Netatmo home ID
- roomIds: Array of room IDs to check
- expectedSetpoints: Object { roomId: expectedTemp } from coordination state

Returns:
```javascript
{
  manualChange: boolean,
  changes: [
    {
      roomId: string,
      roomName: string,
      type: 'setpoint_changed' | 'mode_changed',
      expected: number | string,
      actual: number | string,
    }
  ],
  reason: string | null,  // Human-readable reason for pause
}
```

Implementation:
1. Get current room status from Netatmo API (getHomeStatus)
2. For each room in roomIds:
   - Check if therm_setpoint_mode is 'manual' and setpoint differs by > 0.5°C
   - Check if mode is not 'manual' and not 'home' (user switched to away/hg/off)
3. Return detection result

**wasManuallyChanged(homeId, roomId, expectedSetpoint)**
Convenience function for single room check, returns boolean.

Handle errors gracefully:
- API errors return { manualChange: false, error: message }
- Missing room data treated as no change detected

Create comprehensive tests (mock netatmoApi):
- Detects setpoint change > 0.5°C
- Ignores setpoint change <= 0.5°C (tolerance)
- Detects mode change to 'away'
- Detects mode change to 'hg' (frost guard)
- No change detected when setpoint matches
- No change detected in normal 'home' mode
- Handles missing room data gracefully
- Handles API errors gracefully
- Multi-room detection works correctly
  </action>
  <verify>Run `npm test -- __tests__/lib/coordinationUserIntent.test.js` - all tests pass</verify>
  <done>User intent detection compares current vs expected setpoints and detects mode changes</done>
</task>

<task type="auto">
  <name>Task 2: Create Pause Duration Calculator</name>
  <files>lib/coordinationPauseCalculator.js, __tests__/lib/coordinationPauseCalculator.test.js</files>
  <action>
Create `lib/coordinationPauseCalculator.js` for calculating when automation pause should end.

Per CONTEXT.md: "Pause duration: Until next schedule slot begins (not fixed 30 minutes)"

Netatmo schedule structure (from API):
```javascript
{
  timetable: [
    { m_offset: 0, zone_id: 1 },      // Monday 00:00
    { m_offset: 360, zone_id: 2 },    // Monday 06:00
    { m_offset: 720, zone_id: 1 },    // Monday 12:00
    ...
  ],
  zones: [
    { id: 1, name: "Comfort", temp: 21 },
    { id: 2, name: "Night", temp: 18 },
  ]
}
```

m_offset is minutes from Monday 00:00 (week-relative).

Implement functions:

**calculatePauseUntil(currentTime, schedule)**
Parameters:
- currentTime: Date or timestamp
- schedule: Netatmo schedule object with timetable array

Returns:
```javascript
{
  pauseUntil: number,          // Unix timestamp when pause ends
  nextSlot: {
    offset: number,            // m_offset value
    zoneId: number,
    zoneName: string,
    temp: number,
  },
  waitMinutes: number,         // Minutes until pause ends
}
```

Implementation:
1. Calculate current m_offset (minutes since Monday 00:00)
2. Find first timetable entry with m_offset > current
3. If no next slot this week, wrap to Monday 00:00
4. Convert m_offset back to actual timestamp
5. Return pause end time and slot details

**getNextScheduleSlot(currentTime, timetable)**
Lower-level function returning just the next timetable entry.

**formatPauseReason(changeType, nextSlotTime)**
Returns human-readable pause reason for UI:
- "Automazione in pausa fino alle {HH:MM} (modifica manuale rilevata)"
- Localized to Italian per existing UI convention

Handle edge cases:
- Empty timetable: Return 1-hour default pause
- Sunday night: Correctly wrap to Monday
- Current time exactly on slot boundary: Use NEXT slot

Create comprehensive tests:
- Finds next slot correctly mid-week
- Handles Sunday → Monday wrap
- Handles timezone edge cases (use UTC internally)
- Returns correct pauseUntil timestamp
- Formats reason in Italian
- Empty timetable returns 1-hour default
- Slot boundary edge case handled
  </action>
  <verify>Run `npm test -- __tests__/lib/coordinationPauseCalculator.test.js` - all tests pass</verify>
  <done>Pause calculator determines schedule-aware automation pause duration from Netatmo timetable</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm test -- coordinationUserIntent coordinationPauseCalculator` - All tests pass
2. User intent detection uses 0.5°C tolerance for setpoint comparison
3. Pause calculation correctly handles week wraparound (Sunday → Monday)
4. Both services handle API/data errors gracefully
</verification>

<success_criteria>
- Two new services for user intent and pause calculation
- Intent detection uses Netatmo API with proper tolerance
- Pause ends at next schedule slot (not fixed duration)
- All tests pass (expect ~15-20 new tests)
- Italian localization for user-facing strings
</success_criteria>

<output>
After completion, create `.planning/phases/08-stove-thermostat-integration-correction/08-03-SUMMARY.md`
</output>
