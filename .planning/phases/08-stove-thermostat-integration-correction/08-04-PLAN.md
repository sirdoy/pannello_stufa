---
phase: 08-stove-thermostat-integration-correction
plan: 04
type: execute
wave: 3
depends_on: ["08-01", "08-02", "08-03"]
files_modified:
  - lib/coordinationOrchestrator.js
  - lib/netatmoStoveSync.js
  - __tests__/lib/coordinationOrchestrator.test.js
autonomous: true

must_haves:
  truths:
    - "Stove ON triggers setpoint boost (+configured °C) after 2-min debounce"
    - "Stove OFF restores previous setpoints (not schedule)"
    - "Manual changes pause automation with notification"
    - "Multi-room zones apply individual boost amounts"
    - "Max setpoint capped at 30°C with notification"
    - "Notifications throttled to max 1 per 30 minutes globally"
  artifacts:
    - path: "lib/coordinationOrchestrator.js"
      provides: "Main coordination logic orchestrating all services"
      exports: ["processCoordinationCycle", "applySetpointBoost", "restorePreviousSetpoints"]
    - path: "lib/netatmoStoveSync.js"
      provides: "Enhanced stove sync with setpoint restoration"
      exports: ["(existing exports)", "setRoomsToBoostMode", "restoreRoomSetpoints"]
  key_links:
    - from: "lib/coordinationOrchestrator.js"
      to: "lib/coordinationDebounce.js"
      via: "Debounce timer management"
      pattern: "handleStoveStateChange|startDebounceTimer"
    - from: "lib/coordinationOrchestrator.js"
      to: "lib/coordinationUserIntent.js"
      via: "Detect manual changes"
      pattern: "detectUserIntent"
    - from: "lib/coordinationOrchestrator.js"
      to: "lib/coordinationState.js"
      via: "State management"
      pattern: "getCoordinationState|updateCoordinationState"
    - from: "lib/coordinationOrchestrator.js"
      to: "lib/coordinationNotificationThrottle.js"
      via: "Notification deduplication"
      pattern: "shouldSendCoordinationNotification"
---

<objective>
Create the main coordination orchestrator that ties all services together and enhance netatmoStoveSync for boost mode support.

Purpose: Implement the complete coordination workflow: detect stove state → debounce → check user intent → apply/restore setpoints → send throttled notifications. This is the "brain" that coordinates all Phase 8 components.

Output: coordinationOrchestrator.js as the main entry point, enhanced netatmoStoveSync.js with boost mode support.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-stove-thermostat-integration-correction/08-CONTEXT.md
@.planning/phases/08-stove-thermostat-integration-correction/08-RESEARCH.md
@.planning/phases/08-stove-thermostat-integration-correction/08-01-SUMMARY.md
@.planning/phases/08-stove-thermostat-integration-correction/08-02-SUMMARY.md
@.planning/phases/08-stove-thermostat-integration-correction/08-03-SUMMARY.md
@lib/netatmoStoveSync.js
@lib/coordinationState.js
@lib/coordinationPreferences.js
@lib/coordinationDebounce.js
@lib/coordinationNotificationThrottle.js
@lib/coordinationUserIntent.js
@lib/coordinationPauseCalculator.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance netatmoStoveSync with Boost Mode</name>
  <files>lib/netatmoStoveSync.js</files>
  <action>
Enhance the existing `lib/netatmoStoveSync.js` with boost mode functionality.

Current behavior: Sets rooms to fixed low temperature (16°C) when stove is ON.
New behavior: Applies configurable boost (+N°C) when stove is ON.

Add new functions:

**setRoomsToBoostMode(config, boostAmount, previousSetpoints = {})**
Similar to existing setRoomsToStoveMode but:
- Applies boost: newSetpoint = currentSetpoint + boostAmount
- Caps at 30°C maximum
- Stores currentSetpoint in previousSetpoints object for later restoration
- Returns { success, appliedSetpoints: { roomId: { applied, previous, capped } } }

Key differences from existing function:
- Uses boost instead of fixed temperature
- Tracks previous setpoints for restoration
- Returns capped flag when 30°C limit reached

**restoreRoomSetpoints(rooms, previousSetpoints)**
New function for setpoint restoration:
- For rooms with previousSetpoints[roomId]: restore to that value (manual mode, 8h duration)
- For rooms without previous: return to schedule (mode: 'home')
- Returns { success, restoredRooms: [...] }

This preserves user's manual adjustments instead of always returning to schedule.

Modify existing exports:
- Keep all existing functions for backward compatibility
- Add new setRoomsToBoostMode, restoreRoomSetpoints
- Keep setRoomsToStoveMode for legacy/fallback use

NO changes to existing test files - these new functions will be tested via orchestrator tests.
  </action>
  <verify>Existing tests still pass: `npm test -- netatmoStoveSync`</verify>
  <done>netatmoStoveSync enhanced with boost mode and setpoint restoration preserving previous values</done>
</task>

<task type="auto">
  <name>Task 2: Create Coordination Orchestrator</name>
  <files>lib/coordinationOrchestrator.js, __tests__/lib/coordinationOrchestrator.test.js</files>
  <action>
Create `lib/coordinationOrchestrator.js` as the main coordination entry point.

This orchestrator implements the complete workflow from CONTEXT.md:

**processCoordinationCycle(userId, stoveStatus, homeId)**
Main function called by cron endpoint every minute.

Flow:
```
1. Get coordination preferences (is it enabled?)
2. If not enabled: return early { action: 'skipped', reason: 'disabled' }

3. Get current coordination state

4. Check if automation is paused:
   - If paused and now > pausedUntil: clear pause
   - If paused and now <= pausedUntil: skip coordination { action: 'skipped', reason: 'paused' }

5. Determine stove state (ON = WORK/MODULATION, STARTING, OFF = others)

6. Detect user intent (compare current setpoints vs expected):
   - If manual change detected AND stove ON:
     - Calculate pause until next schedule slot
     - Update state: automationPaused = true, pausedUntil, pauseReason
     - Send notification (if throttle allows)
     - Return { action: 'paused', reason: 'user_intent', pausedUntil }

7. Handle stove state transitions:

   a. Stove transitioning to ON (STARTING → WORK/MODULATION):
      - If pendingDebounce: check if timer should fire
      - If no pending debounce: start 2-min debounce timer
      - Debounce callback:
        - Apply boost to configured zones
        - Store previous setpoints in state
        - Update state: stoveOn = true, pendingDebounce = false
        - Send notification (if throttle allows)
      - Return { action: 'debouncing', remainingMs }

   b. Stove transitioning to OFF during debounce:
      - Cancel debounce, start 30s retry timer
      - Return { action: 'retry_timer', remainingMs: 30000 }

   c. Stove confirmed OFF (no debounce pending):
      - Restore previous setpoints
      - Clear state: stoveOn = false, previousSetpoints = null
      - Send notification (if throttle allows)
      - Return { action: 'restored', restoredRooms }

   d. No state change:
      - Return { action: 'no_change' }

8. Log coordination event to Firestore (fire-and-forget)
```

**applySetpointBoost(userId, homeId, preferences)**
Applies boost to all configured zones:
1. Get zone configurations from preferences
2. For each enabled zone:
   - Get current setpoint
   - Calculate boosted setpoint (cap at 30°C)
   - Apply via setRoomsToBoostMode
3. Store previous setpoints in coordination state
4. Return results with capped flags

**restorePreviousSetpoints(userId, homeId)**
Restores setpoints after stove OFF:
1. Get previousSetpoints from state
2. Call restoreRoomSetpoints
3. Clear previousSetpoints from state
4. Return results

**sendCoordinationNotification(userId, type, data)**
Handles throttled notification sending:
1. Check shouldSendCoordinationNotification
2. If allowed: send via triggerMaintenanceAlertServer, recordNotificationSent
3. If blocked: skip but log "notification_throttled" event
4. ALWAYS log event to Firestore regardless of notification

Notification types:
- 'coordination_applied': "Boost +{X}°C applicato ({rooms})"
- 'coordination_restored': "Setpoint ripristinati ({rooms})"
- 'automation_paused': "Automazione in pausa fino alle {HH:MM}"
- 'max_setpoint_reached': "Setpoint limitato a 30°C ({rooms})"

Create comprehensive tests (mock all dependencies):
- processCoordinationCycle skips when disabled
- processCoordinationCycle respects pause until pausedUntil
- processCoordinationCycle clears expired pause
- processCoordinationCycle detects user intent and pauses
- processCoordinationCycle starts debounce on stove ON
- processCoordinationCycle handles OFF during debounce (30s retry)
- processCoordinationCycle restores on stove OFF
- applySetpointBoost caps at 30°C
- applySetpointBoost stores previous setpoints
- restorePreviousSetpoints uses stored values
- sendCoordinationNotification respects throttle
- sendCoordinationNotification always logs to Firestore
  </action>
  <verify>Run `npm test -- __tests__/lib/coordinationOrchestrator.test.js` - all tests pass</verify>
  <done>Coordination orchestrator implements complete workflow with debouncing, user intent, and throttled notifications</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm test -- coordinationOrchestrator netatmoStoveSync` - All tests pass
2. Orchestrator correctly sequences: state check → user intent → debounce → action → notification
3. Boost mode respects 30°C cap
4. Setpoint restoration uses stored values (not schedule)
5. Notifications properly throttled (max 1 per 30 min)
</verification>

<success_criteria>
- Enhanced netatmoStoveSync with boost mode and restoration
- Coordination orchestrator as main entry point
- Complete workflow implemented per CONTEXT.md decisions
- All tests pass (expect ~20-25 new tests)
- Ready for cron endpoint integration
</success_criteria>

<output>
After completion, create `.planning/phases/08-stove-thermostat-integration-correction/08-04-SUMMARY.md`
</output>
