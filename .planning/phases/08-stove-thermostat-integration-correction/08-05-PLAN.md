---
phase: 08-stove-thermostat-integration-correction
plan: 05
type: execute
wave: 4
depends_on: ["08-04"]
files_modified:
  - app/api/coordination/enforce/route.js
  - lib/coordinationEventLogger.js
  - __tests__/lib/coordinationEventLogger.test.js
autonomous: true

must_haves:
  truths:
    - "Cron endpoint runs coordination cycle every minute"
    - "All coordination events logged to Firestore with timestamp"
    - "Endpoint secured with HMAC (withCronSecret)"
    - "Fire-and-forget logging doesn't block cron response"
    - "Response includes coordination action and timing"
  artifacts:
    - path: "app/api/coordination/enforce/route.js"
      provides: "Cron endpoint for periodic coordination enforcement"
      exports: ["GET"]
    - path: "lib/coordinationEventLogger.js"
      provides: "Firestore event logging for coordination"
      exports: ["logCoordinationEvent", "getRecentCoordinationEvents", "getCoordinationStats"]
  key_links:
    - from: "app/api/coordination/enforce/route.js"
      to: "lib/coordinationOrchestrator.js"
      via: "processCoordinationCycle call"
      pattern: "processCoordinationCycle"
    - from: "app/api/coordination/enforce/route.js"
      to: "lib/core/middleware.js"
      via: "withCronSecret for HMAC security"
      pattern: "withCronSecret"
    - from: "lib/coordinationEventLogger.js"
      to: "lib/firebaseAdmin.js"
      via: "Firestore writes"
      pattern: "getAdminFirestore"
---

<objective>
Create the cron endpoint and event logging service for automated coordination enforcement.

Purpose: Integrate coordination orchestrator into cron-based execution with comprehensive Firestore logging for audit trail and dashboard display. This completes the Phase 8 backend infrastructure.

Output: Cron endpoint `/api/coordination/enforce` and coordinationEventLogger.js for Firestore logging.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-stove-thermostat-integration-correction/08-CONTEXT.md
@.planning/phases/08-stove-thermostat-integration-correction/08-RESEARCH.md
@.planning/phases/08-stove-thermostat-integration-correction/08-04-SUMMARY.md
@lib/coordinationOrchestrator.js
@lib/core/middleware.js
@lib/healthLogger.js
@app/api/health-monitoring/check/route.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Coordination Event Logger</name>
  <files>lib/coordinationEventLogger.js, __tests__/lib/coordinationEventLogger.test.js</files>
  <action>
Create `lib/coordinationEventLogger.js` for Firestore event logging.

Follow the pattern from `lib/healthLogger.js` (fire-and-forget, batch writes).

Firestore structure at `coordinationEvents` collection:
```javascript
{
  timestamp: Timestamp,
  userId: string,
  eventType: string,          // 'boost_applied', 'setpoints_restored', 'automation_paused', 'user_intent_detected', 'max_setpoint_capped', 'notification_sent', 'notification_throttled'
  stoveStatus: string,        // Current stove status
  action: string,             // 'applied', 'restored', 'paused', 'skipped', 'debouncing'
  details: {
    // Varies by event type
    rooms: [{ roomId, roomName, setpoint, previous, capped }],
    pausedUntil: number,
    pauseReason: string,
    throttleWaitSeconds: number,
    // etc.
  },
  notificationSent: boolean,  // Whether notification was actually sent
  cronRunId: string | null,   // Links to cron run for correlation
}
```

Implement functions:

**logCoordinationEvent(event)**
- Fire-and-forget: catches errors, returns null on failure
- Adds timestamp automatically
- Returns document ID on success

**getRecentCoordinationEvents(options)**
Options:
- userId: filter by user (optional)
- eventType: filter by type (optional)
- startDate, endDate: time range
- limit: max results (default 100)

Returns array of events, sorted by timestamp desc.

**getCoordinationStats(userId, days = 7)**
Returns aggregated statistics:
- totalEvents
- byEventType: { boost_applied: N, setpoints_restored: N, ... }
- notificationsSent
- notificationsThrottled
- pauseCount
- averagePauseDurationMinutes

Create comprehensive tests (mock Firestore):
- logCoordinationEvent writes to Firestore
- logCoordinationEvent adds timestamp
- logCoordinationEvent returns null on error (fire-and-forget)
- getRecentCoordinationEvents filters by userId
- getRecentCoordinationEvents filters by eventType
- getRecentCoordinationEvents respects date range
- getCoordinationStats calculates correct aggregates
  </action>
  <verify>Run `npm test -- __tests__/lib/coordinationEventLogger.test.js` - all tests pass</verify>
  <done>Coordination event logger provides Firestore audit trail with query and stats capabilities</done>
</task>

<task type="auto">
  <name>Task 2: Create Coordination Cron Endpoint</name>
  <files>app/api/coordination/enforce/route.js</files>
  <action>
Create cron endpoint at `app/api/coordination/enforce/route.js`.

Follow the pattern from `app/api/health-monitoring/check/route.js`.

Security: Use `withCronSecret` middleware (HMAC validation via query param or Authorization header).

Request flow:
```
1. HMAC validation (withCronSecret)
2. Get ADMIN_USER_ID from env
3. Get stove status via getStoveStatus()
4. Get home_id from Firebase
5. Call processCoordinationCycle(userId, stoveStatus, homeId)
6. Log event to Firestore (fire-and-forget via coordinationEventLogger)
7. Return response with action, timing, details
```

Response structure:
```javascript
{
  success: true,
  action: 'boost_applied' | 'setpoints_restored' | 'debouncing' | 'paused' | 'skipped' | 'no_change',
  details: {
    // Action-specific details
    stoveStatus: string,
    rooms: [...],          // For boost_applied/restored
    pausedUntil: number,   // For paused
    reason: string,        // For skipped/paused
    remainingMs: number,   // For debouncing
  },
  timestamp: number,
  duration: number,        // Execution time in ms
}
```

Error handling:
- Missing ADMIN_USER_ID: Return 500 with warning
- Stove API error: Return 200 with action: 'error', include error details
- Coordination error: Return 200 with action: 'error', log to Firestore

Headers:
```javascript
export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';
```
  </action>
  <verify>Manual test: `curl "http://localhost:3000/api/coordination/enforce?secret={CRON_SECRET}"` returns valid response</verify>
  <done>Cron endpoint executes coordination cycle with HMAC security and Firestore logging</done>
</task>

<task type="auto">
  <name>Task 3: Update Orchestrator with Event Logging</name>
  <files>lib/coordinationOrchestrator.js</files>
  <action>
Update `lib/coordinationOrchestrator.js` to integrate with event logger.

Add event logging at all coordination decision points:

1. After boost applied:
```javascript
await logCoordinationEvent({
  userId,
  eventType: 'boost_applied',
  stoveStatus,
  action: 'applied',
  details: { rooms: appliedRooms, boost: preferences.defaultBoost },
  notificationSent: notificationResult.sent,
});
```

2. After setpoints restored:
```javascript
await logCoordinationEvent({
  userId,
  eventType: 'setpoints_restored',
  stoveStatus,
  action: 'restored',
  details: { rooms: restoredRooms },
  notificationSent: notificationResult.sent,
});
```

3. After automation paused:
```javascript
await logCoordinationEvent({
  userId,
  eventType: 'automation_paused',
  stoveStatus,
  action: 'paused',
  details: { pausedUntil, pauseReason, changes },
  notificationSent: notificationResult.sent,
});
```

4. When notification throttled:
```javascript
await logCoordinationEvent({
  userId,
  eventType: 'notification_throttled',
  stoveStatus,
  action: 'throttled',
  details: { waitSeconds: throttleResult.waitSeconds, intendedType },
  notificationSent: false,
});
```

5. When max setpoint reached:
```javascript
await logCoordinationEvent({
  userId,
  eventType: 'max_setpoint_capped',
  stoveStatus,
  action: 'capped',
  details: { rooms: cappedRooms, cappedAt: 30 },
  notificationSent: notificationResult.sent,
});
```

All logging is fire-and-forget - use `.catch(() => {})` to prevent failures from blocking coordination.
  </action>
  <verify>Run `npm test -- coordinationOrchestrator` - existing tests still pass with logging added</verify>
  <done>Orchestrator logs all coordination events to Firestore for audit trail and dashboard</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm test -- coordinationEventLogger coordinationOrchestrator` - All tests pass
2. Cron endpoint returns valid JSON with action and timing
3. Events appear in Firestore `coordinationEvents` collection
4. Logging failures don't block coordination actions
</verification>

<success_criteria>
- Cron endpoint at /api/coordination/enforce with HMAC security
- Event logger with query and stats capabilities
- All coordination actions logged to Firestore
- Fire-and-forget logging pattern (non-blocking)
- All tests pass (expect ~10-15 new tests)
- Phase 8 backend infrastructure complete
</success_criteria>

<output>
After completion, create `.planning/phases/08-stove-thermostat-integration-correction/08-05-SUMMARY.md`
</output>
