---
phase: 09-schedule-management-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/hooks/useScheduleData.js
  - lib/utils/scheduleHelpers.js
  - lib/routes.js
autonomous: true

must_haves:
  truths:
    - "Schedule data can be fetched and cached client-side"
    - "Timetable slots can be parsed into day-grouped timeline format"
    - "Temperature values map to accessible color gradients"
  artifacts:
    - path: "lib/hooks/useScheduleData.js"
      provides: "React hook for schedule fetching with loading/error states"
      exports: ["useScheduleData"]
    - path: "lib/utils/scheduleHelpers.js"
      provides: "Timetable parsing and color utilities"
      exports: ["parseTimelineSlots", "tempToColor", "formatDuration", "formatTimeFromMinutes"]
  key_links:
    - from: "lib/hooks/useScheduleData.js"
      to: "/api/netatmo/schedules"
      via: "fetch call"
      pattern: "fetch.*api/netatmo/schedules"
---

<objective>
Create schedule data hooks and helper utilities for Phase 9 UI components.

Purpose: Establish the data layer and utility functions needed by the schedule visualization and override UI. This foundational work enables parallel development of UI components in subsequent plans.

Output: useScheduleData hook for fetching/caching schedules, scheduleHelpers utilities for timetable parsing and temperature-to-color mapping.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-schedule-management-ui/09-CONTEXT.md
@.planning/phases/09-schedule-management-ui/09-RESEARCH.md

# Key source files
@lib/routes.js
@app/api/netatmo/schedules/route.js
@lib/netatmoApi.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schedule helpers utility</name>
  <files>lib/utils/scheduleHelpers.js</files>
  <action>
Create utility module with:

1. **parseTimelineSlots(schedule)** - Transform Netatmo timetable into day-grouped slots:
   - Input: schedule object with zones[] and timetable[]
   - m_offset is minutes from Monday 00:00 (NOT per-day)
   - Calculate day (0-6) as `Math.floor(m_offset / 1440)`
   - Calculate minutesInDay as `m_offset % 1440`
   - Return array of { day, startMinutes, endMinutes, temperature, zoneName, durationPercent }
   - durationPercent = ((endMinutes - startMinutes) / 1440) * 100

2. **tempToColor(temp)** - Color-blind accessible gradient:
   - Range: 15-23Â°C (typical home heating range)
   - Use cyan-yellow-red gradient (NOT red-green)
   - Return HSL string for CSS backgroundColor
   - Must meet WCAG contrast when used with white text

3. **formatTimeFromMinutes(minutes)** - Format minutes to HH:MM:
   - Input: minutes from midnight (0-1439)
   - Output: "08:00", "14:30" etc
   - Handle edge case: 1440 -> "00:00" (next day)

4. **formatDuration(minutes)** - Format duration for display:
   - < 60 min: "15 min"
   - >= 60 min: "1h 30m" or "2h" if no remainder

5. **DAY_NAMES** - Italian day abbreviations: ['Lun', 'Mar', 'Mer', 'Gio', 'Ven', 'Sab', 'Dom']

Pattern reference: See existing lib/utils/ for module structure. Export as named exports.
  </action>
  <verify>
Create test: `__tests__/utils/scheduleHelpers.test.js`
- Test parseTimelineSlots with sample Netatmo timetable (verify m_offset parsing)
- Test tempToColor returns valid HSL for range 15-23
- Test formatTimeFromMinutes edge cases (0, 720, 1439)
- Test formatDuration for < 60 and >= 60 minutes
Run: `npm test -- scheduleHelpers`
  </verify>
  <done>All helper functions exported and tested, m_offset parsing correctly calculates day index</done>
</task>

<task type="auto">
  <name>Task 2: Create useScheduleData hook</name>
  <files>lib/hooks/useScheduleData.js</files>
  <action>
Create React hook for schedule data fetching:

```javascript
'use client';
import { useState, useEffect, useCallback } from 'react';

export function useScheduleData() {
  const [schedules, setSchedules] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [source, setSource] = useState(null); // 'cache' | 'api'

  const fetchSchedules = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const res = await fetch('/api/netatmo/schedules');
      const data = await res.json();

      if (!res.ok) {
        throw new Error(data.message || data.error || 'Failed to fetch schedules');
      }

      setSchedules(data.schedules || []);
      setSource(data._source);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  // Initial fetch
  useEffect(() => {
    fetchSchedules();
  }, [fetchSchedules]);

  // Derived state
  const activeSchedule = schedules.find(s => s.selected);

  return {
    schedules,
    activeSchedule,
    loading,
    error,
    source,
    refetch: fetchSchedules,
  };
}
```

Key behaviors:
- Fetch on mount, expose refetch for manual refresh
- Track _source from API response (cache vs fresh)
- Derive activeSchedule from schedules array
- Handle 429 rate limit errors gracefully (show retryAfter)
  </action>
  <verify>
Create test: `__tests__/hooks/useScheduleData.test.js`
- Mock fetch, verify initial load triggers fetch
- Verify activeSchedule derived correctly
- Verify error handling for failed fetch
Run: `npm test -- useScheduleData`
  </verify>
  <done>Hook exports loading, error, schedules, activeSchedule, refetch</done>
</task>

<task type="auto">
  <name>Task 3: Add schedules route to routes.js</name>
  <files>lib/routes.js</files>
  <action>
Add schedules endpoint to NETATMO_ROUTES in lib/routes.js:

```javascript
// In NETATMO_ROUTES object, add:
schedules: `${API_BASE}/netatmo/schedules`,
```

This ensures consistent route usage across the app (matches existing pattern for other Netatmo endpoints).
  </action>
  <verify>
Grep for NETATMO_ROUTES.schedules usage pattern.
Verify no hardcoded '/api/netatmo/schedules' strings exist elsewhere.
  </verify>
  <done>NETATMO_ROUTES.schedules exported and available for import</done>
</task>

</tasks>

<verification>
1. `npm test -- scheduleHelpers` - All helper tests pass
2. `npm test -- useScheduleData` - Hook tests pass
3. Import check: `grep -r "useScheduleData\|scheduleHelpers" lib/` shows exports
</verification>

<success_criteria>
- parseTimelineSlots correctly transforms m_offset to day-based slots
- tempToColor produces accessible color gradient
- useScheduleData hook manages loading/error/data states
- NETATMO_ROUTES.schedules added to routes.js
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-schedule-management-ui/09-01-SUMMARY.md`
</output>
