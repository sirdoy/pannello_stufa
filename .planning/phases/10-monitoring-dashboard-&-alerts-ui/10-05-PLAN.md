---
phase: 10-monitoring-dashboard-&-alerts-ui
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/notificationTriggers.js
  - lib/notificationTriggersServer.js
  - app/api/health-monitoring/check/route.js
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "System triggers push notifications for critical health issues (connection lost, unexpected state)"
    - "Notification deduplication prevents alert spam (30-minute window)"
    - "Health alerts respect user notification preferences"
  artifacts:
    - path: "lib/notificationTriggers.js"
      provides: "Health monitoring notification types"
      contains: "monitoring_connection_lost"
    - path: "lib/notificationTriggersServer.js"
      provides: "Server-side health alert helpers"
      exports: ["triggerHealthMonitoringAlertServer"]
    - path: "app/api/health-monitoring/check/route.js"
      provides: "Notification triggering on health issues"
      contains: "shouldSendCoordinationNotification"
  key_links:
    - from: "app/api/health-monitoring/check/route.js"
      to: "lib/notificationTriggersServer.js"
      via: "import triggerHealthMonitoringAlertServer"
      pattern: "triggerHealthMonitoringAlertServer"
    - from: "app/api/health-monitoring/check/route.js"
      to: "lib/coordinationNotificationThrottle.js"
      via: "import shouldSendCoordinationNotification"
      pattern: "shouldSendCoordinationNotification"
---

<objective>
Wire push notification triggering into health monitoring cron endpoint.

Purpose: Close the gap where health monitoring detects issues (connection lost, state mismatch, stove errors) but doesn't alert users. The infrastructure exists but is not connected.

Output: Health monitoring cron triggers push notifications for critical issues with 30-minute deduplication.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-monitoring-dashboard-&-alerts-ui/10-VERIFICATION.md

# Existing notification infrastructure
@lib/notificationTriggers.js
@lib/notificationTriggersServer.js
@lib/coordinationNotificationThrottle.js
@lib/healthMonitoring.js

# Endpoint to modify
@app/api/health-monitoring/check/route.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add health monitoring notification types</name>
  <files>lib/notificationTriggers.js, lib/notificationTriggersServer.js</files>
  <action>
Add three new notification types to NOTIFICATION_TYPES in lib/notificationTriggers.js:

1. `monitoring_connection_lost`:
   - category: 'monitoring'
   - preferenceKey: 'monitoring.connectionLost'
   - defaultEnabled: true
   - title: 'Stufa Disconnessa'
   - body: (data) => data.message || 'La stufa non risponde. Verifica la connessione.'
   - priority: 'high'
   - url: '/monitoring'

2. `monitoring_state_mismatch`:
   - category: 'monitoring'
   - preferenceKey: 'monitoring.stateMismatch'
   - defaultEnabled: true
   - title: 'Anomalia Rilevata'
   - body: (data) => data.message || `Stufa dovrebbe essere ${data.expected} ma e ${data.actual}`
   - priority: 'high'
   - url: '/monitoring'

3. `monitoring_stove_error`:
   - category: 'monitoring'
   - preferenceKey: 'monitoring.stoveError'
   - defaultEnabled: true
   - title: 'Errore Stufa Rilevato'
   - body: (data) => data.message || `Errore AL${data.errorCode}: ${data.errorDescription || 'Richiesto intervento'}`
   - priority: 'high'
   - url: '/monitoring'

Add new category to NOTIFICATION_CATEGORIES:
```javascript
monitoring: {
  id: 'monitoring',
  label: 'Health Monitoring',
  description: 'Notifiche dal sistema di monitoraggio automatico',
  icon: 'ðŸ“Š',
  masterToggle: true,
},
```

Add mapping entries to LEGACY_TYPE_MAPPING in lib/notificationTriggersServer.js:
```javascript
'monitoring_connection_lost': 'ERROR',
'monitoring_state_mismatch': 'ERROR',
'monitoring_stove_error': 'CRITICAL',
```

Add helper function in lib/notificationTriggersServer.js:
```javascript
/**
 * Trigger health monitoring alert
 * @param {string} userId - User ID
 * @param {string} alertType - 'connection_lost' | 'state_mismatch' | 'stove_error'
 * @param {Object} data - Alert data (expected, actual, errorCode, errorDescription, message)
 */
export async function triggerHealthMonitoringAlertServer(userId, alertType, data = {}) {
  const typeId = `monitoring_${alertType}`;
  return triggerNotificationServer(userId, typeId, data);
}
```
  </action>
  <verify>
Run: `grep -n "monitoring_connection_lost\|monitoring_state_mismatch\|monitoring_stove_error" lib/notificationTriggers.js`
Expected: 3 matches for the new notification types

Run: `grep -n "triggerHealthMonitoringAlertServer" lib/notificationTriggersServer.js`
Expected: Function definition and export found
  </verify>
  <done>
Three health monitoring notification types defined with Italian messages, monitoring category added, helper function exported from server triggers module.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire notification triggering in health check cron</name>
  <files>app/api/health-monitoring/check/route.js</files>
  <action>
Modify the health check cron endpoint to trigger notifications when critical issues are detected.

1. Add imports at top of file:
```javascript
import { triggerHealthMonitoringAlertServer } from '@/lib/notificationTriggersServer';
import {
  shouldSendCoordinationNotification,
  recordNotificationSent,
} from '@/lib/coordinationNotificationThrottle';
```

2. After the mismatch extraction block (after line 79), add notification triggering logic:

```javascript
// 6b. Trigger notifications for critical issues (with throttling)
const notificationPromises = [];

for (const result of results) {
  if (result.status !== 'fulfilled') continue;

  const { userId, connectionStatus, stateMismatch } = result.value;

  // Check throttle BEFORE attempting to send
  const throttleCheck = shouldSendCoordinationNotification(userId);
  if (!throttleCheck.allowed) {
    console.log(`â±ï¸ Health alert throttled for ${userId} (wait ${throttleCheck.waitSeconds}s)`);
    continue;
  }

  // Connection lost (offline or error status)
  if (connectionStatus === 'offline' || connectionStatus === 'error') {
    notificationPromises.push(
      triggerHealthMonitoringAlertServer(userId, 'connection_lost', {
        message: connectionStatus === 'offline'
          ? 'La stufa non risponde (timeout). Verifica la connessione.'
          : 'Errore di connessione alla stufa. Verifica il sistema.',
      }).then(() => recordNotificationSent(userId))
    );
    continue; // Don't send multiple notifications per user
  }

  // State mismatch detected
  if (stateMismatch?.detected) {
    if (stateMismatch.reason === 'stove_error') {
      // Stove error (AL code)
      notificationPromises.push(
        triggerHealthMonitoringAlertServer(userId, 'stove_error', {
          errorCode: stateMismatch.actual.replace('ERROR (AL', '').replace(')', ''),
          errorDescription: stateMismatch.errorDescription,
          message: `Errore stufa: ${stateMismatch.actual}`,
        }).then(() => recordNotificationSent(userId))
      );
    } else {
      // State mismatch (should_be_on, should_be_off, netatmo_heating_stove_off)
      notificationPromises.push(
        triggerHealthMonitoringAlertServer(userId, 'state_mismatch', {
          expected: stateMismatch.expected,
          actual: stateMismatch.actual,
          reason: stateMismatch.reason,
          message: `Anomalia: stufa dovrebbe essere ${stateMismatch.expected} ma e ${stateMismatch.actual}`,
        }).then(() => recordNotificationSent(userId))
      );
    }
  }
}

// Fire-and-forget notifications (don't block response)
if (notificationPromises.length > 0) {
  Promise.allSettled(notificationPromises).then(results => {
    const sent = results.filter(r => r.status === 'fulfilled').length;
    const failed = results.filter(r => r.status === 'rejected').length;
    console.log(`ðŸ“¬ Health alerts sent: ${sent} success, ${failed} failed`);
  });
}
```

3. Update the console log summary (line 82) to include notification count:
```javascript
console.log(`âœ… Health check complete: ${successCount}/${users.length} users, ${mismatches.length} mismatches, ${notificationPromises.length} alerts triggered`);
```

Note: Use fire-and-forget pattern (Promise.allSettled without await) so notifications don't delay cron response. The throttle check happens synchronously BEFORE adding to promises array.
  </action>
  <verify>
Run: `grep -n "shouldSendCoordinationNotification\|triggerHealthMonitoringAlertServer" app/api/health-monitoring/check/route.js`
Expected: Both imports and usages found

Run: `grep -n "recordNotificationSent" app/api/health-monitoring/check/route.js`
Expected: recordNotificationSent called after successful notification trigger

Run: `grep -n "Fire-and-forget\|Promise.allSettled" app/api/health-monitoring/check/route.js`
Expected: Fire-and-forget pattern comment and Promise.allSettled usage
  </verify>
  <done>
Health check cron endpoint now triggers push notifications for connection lost, state mismatch, and stove errors. Uses coordination throttle for 30-minute deduplication. Fire-and-forget pattern ensures notifications don't block cron response.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for health notification triggering</name>
  <files>__tests__/lib/healthNotifications.test.js</files>
  <action>
Create unit tests to verify health notification types and triggering logic.

```javascript
/**
 * Health Monitoring Notifications Tests
 *
 * Tests for notification types and triggering logic added in 10-05 gap closure.
 */

import {
  NOTIFICATION_TYPES,
  NOTIFICATION_CATEGORIES,
  buildNotificationPayload,
} from '@/lib/notificationTriggers';

describe('Health Monitoring Notification Types', () => {
  describe('Notification Type Definitions', () => {
    test('monitoring_connection_lost type exists with correct config', () => {
      const type = NOTIFICATION_TYPES.monitoring_connection_lost;

      expect(type).toBeDefined();
      expect(type.id).toBe('monitoring_connection_lost');
      expect(type.category).toBe('monitoring');
      expect(type.defaultEnabled).toBe(true);
      expect(type.priority).toBe('high');
      expect(type.url).toBe('/monitoring');
    });

    test('monitoring_state_mismatch type exists with correct config', () => {
      const type = NOTIFICATION_TYPES.monitoring_state_mismatch;

      expect(type).toBeDefined();
      expect(type.id).toBe('monitoring_state_mismatch');
      expect(type.category).toBe('monitoring');
      expect(type.defaultEnabled).toBe(true);
      expect(type.priority).toBe('high');
    });

    test('monitoring_stove_error type exists with correct config', () => {
      const type = NOTIFICATION_TYPES.monitoring_stove_error;

      expect(type).toBeDefined();
      expect(type.id).toBe('monitoring_stove_error');
      expect(type.category).toBe('monitoring');
      expect(type.defaultEnabled).toBe(true);
      expect(type.priority).toBe('high');
    });
  });

  describe('Monitoring Category', () => {
    test('monitoring category exists', () => {
      const category = NOTIFICATION_CATEGORIES.monitoring;

      expect(category).toBeDefined();
      expect(category.id).toBe('monitoring');
      expect(category.masterToggle).toBe(true);
    });
  });

  describe('Payload Building', () => {
    test('builds connection_lost payload with default message', () => {
      const payload = buildNotificationPayload('monitoring_connection_lost', {});

      expect(payload.notification.title).toBe('Stufa Disconnessa');
      expect(payload.notification.body).toContain('non risponde');
      expect(payload.data.priority).toBe('high');
    });

    test('builds state_mismatch payload with custom data', () => {
      const payload = buildNotificationPayload('monitoring_state_mismatch', {
        expected: 'ON',
        actual: 'STANDBY',
        message: 'Custom mismatch message',
      });

      expect(payload.notification.title).toBe('Anomalia Rilevata');
      expect(payload.notification.body).toBe('Custom mismatch message');
      expect(payload.data.expected).toBe('ON');
      expect(payload.data.actual).toBe('STANDBY');
    });

    test('builds stove_error payload with error code', () => {
      const payload = buildNotificationPayload('monitoring_stove_error', {
        errorCode: '03',
        errorDescription: 'Mancanza pellet',
      });

      expect(payload.notification.title).toBe('Errore Stufa Rilevato');
      expect(payload.notification.body).toContain('AL03');
      expect(payload.notification.body).toContain('Mancanza pellet');
    });
  });
});
```
  </action>
  <verify>
Run: `npm test -- --testPathPattern="healthNotifications" --verbose`
Expected: All tests pass (6 tests: 3 type definitions, 1 category, 3 payload building)
  </verify>
  <done>
Unit tests verify all three notification types exist with correct configuration, monitoring category is defined, and payload building works with both default and custom messages.
  </done>
</task>

</tasks>

<verification>
1. Notification types added: `grep -c "monitoring_" lib/notificationTriggers.js` returns at least 3
2. Server helper added: `grep "triggerHealthMonitoringAlertServer" lib/notificationTriggersServer.js` shows export
3. Cron wiring complete: `grep "shouldSendCoordinationNotification" app/api/health-monitoring/check/route.js` shows import and usage
4. Tests pass: `npm test -- --testPathPattern="healthNotifications"` runs without failures
</verification>

<success_criteria>
- Three health monitoring notification types defined (connection_lost, state_mismatch, stove_error)
- Health check cron triggers notifications for critical issues
- 30-minute throttle prevents notification spam
- Fire-and-forget pattern doesn't block cron response
- Unit tests verify notification type configuration
</success_criteria>

<output>
After completion, create `.planning/phases/10-monitoring-dashboard-&-alerts-ui/10-05-SUMMARY.md`
</output>
