---
phase: 41-pages-migration
plan: 07
type: execute
wave: 2
depends_on: ["41-01", "41-02", "41-03", "41-04", "41-05", "41-06"]
files_modified: []
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "tsc --noEmit reports zero errors for app/ pages and co-located components"
    - "No .js/.jsx files remain in app/ directory (excluding __tests__, __mocks__, page.test.js)"
    - "All 70 migrated files compile without TypeScript errors"
  artifacts:
    - path: "app/"
      provides: "Zero .js page/component/provider files"
      contains: "only .tsx/.ts files"
  key_links:
    - from: "all migrated .tsx files"
      to: "tsc --noEmit"
      via: "TypeScript compilation"
      pattern: "zero errors"
---

<objective>
Run tsc, identify and fix all TypeScript errors introduced by the page migration, and verify zero .js files remain.

Purpose: Ensure all 70 migrated files compile cleanly. Prior phases (38, 39, 40) consistently needed gap closure to resolve tsc errors that surface only after all files are renamed.
Output: Zero tsc errors in app/ pages, zero .js page/component/provider files remaining.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-pages-migration/41-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify migration completeness and identify remaining .js files</name>
  <files></files>
  <action>
    1. Run: `find app -name "*.js" -o -name "*.jsx" | grep -v node_modules | grep -v __tests__ | grep -v __mocks__ | grep -v page.test.js | sort`
       - This should return EMPTY (all 70 files migrated by Plans 01-06)
       - If any .js files remain, they were missed — migrate them with git mv

    2. Verify file counts:
       - Context providers: `ls app/context/*.tsx` — expect 3 files
       - Root files: `ls app/layout.tsx app/template.tsx app/not-found.tsx` — expect all exist
       - Page files: `find app -name "page.tsx" | wc -l` — expect 38 (37 pages + 1 home)
       - Note: page.test.js is deferred to Phase 42

    3. If any files were missed, run `git mv` for each and add minimal TypeScript typing.
  </action>
  <verify>
    Run: `find app -name "*.js" -o -name "*.jsx" | grep -v node_modules | grep -v __tests__ | grep -v __mocks__ | grep -v "page.test.js" | wc -l`
    Confirm: Returns 0
  </verify>
  <done>Zero .js/.jsx files remain in app/ (excluding test files deferred to Phase 42). All 70 files successfully migrated.</done>
</task>

<task type="auto">
  <name>Task 2: Fix tsc errors and achieve zero errors</name>
  <files></files>
  <action>
    1. Run: `npx tsc --noEmit 2>&1 | head -200`
       - Capture all TypeScript errors

    2. If errors exist, categorize them:
       - **Import path errors:** .js extension in imports needs removal or update
       - **Type mismatch errors:** Missing type annotations, incompatible assignments
       - **Missing type errors:** Referenced types not imported
       - **Context/hook errors:** Context value type mismatches

    3. Fix errors systematically by category (Phase 40-07 pattern):
       - Group by error type, fix all of same type together
       - Use double assertion pattern `(value as unknown as Type)` for stubborn conversions
       - Use pragmatic 'any' for truly complex external API structures
       - Add missing imports: `import type { Metadata } from 'next'`
       - Fix context provider types if createContext generic mismatches

    4. Re-run tsc after each batch of fixes to track progress

    5. Final run: `npx tsc --noEmit 2>&1 | grep -c "error TS"` must return 0

    **Known patterns from prior phases:**
    - ErrorCode synchronization: Add new codes to ERROR_CODES constant + ERROR_MESSAGES map + ErrorCode type
    - Date arithmetic: Use .getTime() for Date subtraction
    - Dynamic route params: Promise<{ paramName: string }> for Next.js 16
    - Double assertion: (value as unknown as TargetType) for incompatible conversions
    - Firebase: adminDbGet() cast to typed interface, never leave as unknown
  </action>
  <verify>
    Run: `npx tsc --noEmit 2>&1 | grep -c "error TS"`
    Confirm: Returns 0 (zero TypeScript errors)
  </verify>
  <done>tsc --noEmit passes with zero errors. All migrated files compile cleanly.</done>
</task>

</tasks>

<verification>
- `find app -name "*.js" -o -name "*.jsx" | grep -v node_modules | grep -v __tests__ | grep -v __mocks__ | grep -v "page.test.js" | wc -l` — returns 0
- `npx tsc --noEmit 2>&1 | grep -c "error TS"` — returns 0
- All 70 files migrated and compiling
</verification>

<success_criteria>
- Zero .js/.jsx files remain in app/ (excluding test files for Phase 42)
- Zero tsc errors across all migrated files
- All type errors resolved using established patterns (pragmatic any, double assertion, etc.)
</success_criteria>

<output>
After completion, create `.planning/phases/41-pages-migration/41-07-SUMMARY.md`
</output>
