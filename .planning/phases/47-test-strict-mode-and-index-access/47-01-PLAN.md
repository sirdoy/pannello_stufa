---
phase: 47-test-strict-mode-and-index-access
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - __tests__/lib/coordinationEventLogger.test.ts
  - __tests__/lib/healthLogger.test.ts
  - __tests__/lib/notificationHistoryService.test.ts
autonomous: true

must_haves:
  truths:
    - "coordinationEventLogger.test.ts has zero tsc errors with strict: true"
    - "healthLogger.test.ts has zero tsc errors with strict: true"
    - "notificationHistoryService.test.ts has zero tsc errors with strict: true"
  artifacts:
    - path: "__tests__/lib/coordinationEventLogger.test.ts"
      provides: "Strict-mode compliant coordination event logger tests"
    - path: "__tests__/lib/healthLogger.test.ts"
      provides: "Strict-mode compliant health logger tests"
    - path: "__tests__/lib/notificationHistoryService.test.ts"
      provides: "Strict-mode compliant notification history service tests"
  key_links:
    - from: "__tests__/lib/coordinationEventLogger.test.ts"
      to: "lib/coordinationEventLogger.ts"
      via: "import and mock"
      pattern: "jest\\.mock.*coordinationEventLogger"
---

<objective>
Fix 108 strict-mode tsc errors across 3 high-error test files: coordinationEventLogger (46 errors), healthLogger (33 errors), notificationHistoryService (29 errors).

Purpose: These three files account for ~38% of all remaining tsc errors. Fixing them establishes the pattern for all subsequent test file fixes.
Output: Three test files with zero tsc errors under strict: true.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@__tests__/lib/coordinationEventLogger.test.ts
@__tests__/lib/healthLogger.test.ts
@__tests__/lib/notificationHistoryService.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix coordinationEventLogger.test.ts (46 errors) and healthLogger.test.ts (33 errors)</name>
  <files>__tests__/lib/coordinationEventLogger.test.ts, __tests__/lib/healthLogger.test.ts</files>
  <action>
Fix 79 tsc errors across these two files. The errors are predominantly:
- TS7034: Variable implicitly has type 'any' — Add explicit `jest.Mock` type annotation to mock variables declared with `let`. Pattern: `let mockCollection: jest.Mock;`
- TS7005: Variable implicitly has 'any' type — Same root cause as TS7034, the variable needs a type where it's used. Adding the type at declaration fixes both.
- TS18047/TS18048: Possibly null/undefined — Add non-null assertions (!) where test data is known to exist, or add null guards.
- TS7031: Binding element implicitly has 'any' type — Add type annotations to destructured parameters.
- TS7053: Element implicitly has 'any' type — Use proper Record types or type assertions for dynamic access.

Key patterns from Phase 44-07 decisions:
- Test-specific pragmatic `as any` for intentional null/undefined test cases
- Non-null assertions (!) in tests for data known to exist
- `jest.Mock` for mock function variables
- `jest.mocked()` for auto-mocked module access

Run `npx tsc --noEmit 2>&1 | grep "coordinationEventLogger.test\|healthLogger.test" | wc -l` to verify 0 errors in these files.
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep -c "coordinationEventLogger.test\|healthLogger.test" outputs 0</verify>
  <done>Both files compile with zero tsc errors under strict: true. All existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Fix notificationHistoryService.test.ts (29 errors)</name>
  <files>__tests__/lib/notificationHistoryService.test.ts</files>
  <action>
Fix 29 tsc errors in notificationHistoryService.test.ts. Same error patterns as Task 1:
- TS7034/TS7005: Mock variables need explicit `jest.Mock` type annotations
- TS18047/TS18048: Null/undefined checks needed
- TS7053: Dynamic property access needs proper typing
- TS2345: Type arguments need explicit types

Apply the same patterns:
1. Add `jest.Mock` type to all `let mock*` declarations
2. Add non-null assertions where test data is guaranteed to exist
3. Add type annotations to mock factory return objects
4. Use `as any` sparingly for intentional null/undefined test cases

Run `npx tsc --noEmit 2>&1 | grep "notificationHistoryService.test" | wc -l` to verify 0 errors.
Then run `npx jest notificationHistoryService` to verify tests still pass.
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep -c "notificationHistoryService.test" outputs 0 AND npx jest notificationHistoryService passes</verify>
  <done>notificationHistoryService.test.ts compiles with zero tsc errors under strict: true. All tests pass.</done>
</task>

</tasks>

<verification>
```bash
# Verify zero errors in these 3 files
npx tsc --noEmit 2>&1 | grep "coordinationEventLogger.test\|healthLogger.test\|notificationHistoryService.test" | wc -l
# Expected: 0

# Verify tests still pass
npx jest coordinationEventLogger healthLogger notificationHistoryService
# Expected: all pass
```
</verification>

<success_criteria>
- 0 tsc errors in coordinationEventLogger.test.ts (was 46)
- 0 tsc errors in healthLogger.test.ts (was 33)
- 0 tsc errors in notificationHistoryService.test.ts (was 29)
- All tests in these files still pass
</success_criteria>

<output>
After completion, create `.planning/phases/47-test-strict-mode-and-index-access/47-01-SUMMARY.md`
</output>
