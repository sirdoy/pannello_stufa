---
phase: 49-persistent-rate-limiting
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/rateLimiterPersistent.ts
  - __tests__/lib/rateLimiterPersistent.test.ts
autonomous: true

must_haves:
  truths:
    - "Notification rate limits persist across simulated cold starts (new instance reads existing state)"
    - "Sliding window algorithm correctly filters expired timestamps and enforces maxPerWindow"
    - "Concurrent rate limit checks via Firebase transactions do not allow exceeding limits"
    - "When Firebase returns null (empty path), rate limiter initializes correctly and allows first request"
    - "Expired timestamps are cleaned up on every transaction (no unbounded array growth)"
  artifacts:
    - path: "lib/rateLimiterPersistent.ts"
      provides: "Firebase RTDB-backed notification rate limiter"
      exports: ["checkRateLimitPersistent", "clearRateLimitPersistentForUser", "getRateLimitPersistentStatus"]
    - path: "__tests__/lib/rateLimiterPersistent.test.ts"
      provides: "Unit tests for persistent notification rate limiter"
      min_lines: 100
  key_links:
    - from: "lib/rateLimiterPersistent.ts"
      to: "lib/firebaseAdmin.ts"
      via: "adminDbTransaction import"
      pattern: "import.*adminDbTransaction.*from.*firebaseAdmin"
---

<objective>
Create a Firebase RTDB-backed notification rate limiter that mirrors the existing `rateLimiter.ts` API but persists state via Firebase transactions instead of in-memory Maps.

Purpose: Notification rate limits currently reset on every Vercel cold start/deployment, allowing spam bursts. Firebase RTDB transactions provide atomic read-modify-write operations that persist across serverless instances.

Output: `lib/rateLimiterPersistent.ts` with tests proving persistence and correctness of sliding window algorithm.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-persistent-rate-limiting/49-RESEARCH.md
@lib/rateLimiter.ts
@lib/firebaseAdmin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create persistent notification rate limiter with TDD</name>
  <files>lib/rateLimiterPersistent.ts, __tests__/lib/rateLimiterPersistent.test.ts</files>
  <action>
**RED phase:** Create `__tests__/lib/rateLimiterPersistent.test.ts` with tests for:
- `checkRateLimitPersistent(userId, notifType, customLimits?)` returns `Promise<RateLimitResult>` with `{ allowed, suppressedCount, nextAllowedIn }`
- Allows first request for new user/type combo (Firebase returns null -> initialize)
- Blocks when maxPerWindow reached within windowMs
- Filters expired timestamps (only keeps timestamps within windowMs)
- Returns correct `nextAllowedIn` seconds when blocked
- Works with custom limits (override defaults)
- `clearRateLimitPersistentForUser(userId)` removes all rate limit entries for user
- `getRateLimitPersistentStatus(userId, notifType)` returns current count/status

Mock `adminDbTransaction` from `@/lib/firebaseAdmin`:
```typescript
jest.mock('@/lib/firebaseAdmin', () => ({
  adminDbTransaction: jest.fn(),
  adminDbGet: jest.fn(),
  adminDbRemove: jest.fn(),
}));
```

Test the transaction callback logic by capturing the update function passed to `adminDbTransaction` and calling it with simulated current data:
- null (first time) -> should return { timestamps: [now], windowStart: now }
- existing data with recent timestamps -> should add new timestamp if under limit
- existing data at limit -> should return unchanged data (no modification)
- existing data with old timestamps -> should filter them out (cleanup on read)

Use `jest.useFakeTimers()` for deterministic time control.

**GREEN phase:** Create `lib/rateLimiterPersistent.ts`:

```typescript
import { adminDbTransaction, adminDbGet, adminDbRemove } from '@/lib/firebaseAdmin';
```

Export the same types as `rateLimiter.ts`: `RateLimitResult`, `RateLimitConfig`, `RateLimitStatus`.

Implement `checkRateLimitPersistent()`:
- Path: `rateLimits/{userId}/{notifType}`
- Use `adminDbTransaction()` with a PURE callback (no side effects):
  1. Cast current data to `RateLimitWindow | null`
  2. Filter timestamps to current window: `timestamps.filter(ts => now - ts < windowMs)`
  3. Also apply max retention filter: `now - ts < MAX_RETENTION_MS` (2 hours = 7200000ms)
  4. If `recentInWindow.length >= maxPerWindow` -> return current data unchanged
  5. If allowed -> push `now` to timestamps, return updated data
- After transaction, check result to determine allowed/blocked
- Use same `DEFAULT_RATE_LIMITS` record from existing `rateLimiter.ts` (copy the config, do NOT import from it to keep modules independent)

Implement `clearRateLimitPersistentForUser()`:
- Use `adminDbRemove('rateLimits/{userId}')` to remove all rate limit entries for a user

Implement `getRateLimitPersistentStatus()`:
- Use `adminDbGet('rateLimits/{userId}/{notifType}')` to read current state
- Return `RateLimitStatus` with currentCount, maxAllowed, windowMinutes, nextResetIn

**IMPORTANT anti-patterns to avoid:**
- Do NOT put console.log or any side effects inside the transaction callback (it may run multiple times)
- Do NOT return `undefined` from the transaction callback (aborts the transaction)
- Always handle `null` current data (first time case)
- Keep timestamps array bounded by filtering on every transaction

**REFACTOR phase:** Ensure clean separation, add JSDoc comments matching existing `rateLimiter.ts` style.
  </action>
  <verify>
Run `npx jest __tests__/lib/rateLimiterPersistent.test.ts --no-coverage` - all tests pass.
Verify `lib/rateLimiterPersistent.ts` exports: `checkRateLimitPersistent`, `clearRateLimitPersistentForUser`, `getRateLimitPersistentStatus`.
Verify no `console.log` inside transaction callbacks.
  </verify>
  <done>
Persistent notification rate limiter passes all unit tests. Transaction callback is pure (no side effects). Sliding window correctly filters expired timestamps. Max retention (2h) prevents unbounded array growth. API mirrors existing rateLimiter.ts interface but async.
  </done>
</task>

</tasks>

<verification>
- `npx jest __tests__/lib/rateLimiterPersistent.test.ts --no-coverage` passes
- `npx tsc --noEmit lib/rateLimiterPersistent.ts` no type errors
- Transaction callback purity: grep for console.log inside transaction callback - none found
- Exports match: `checkRateLimitPersistent`, `clearRateLimitPersistentForUser`, `getRateLimitPersistentStatus`
</verification>

<success_criteria>
- All tests green for persistent notification rate limiter
- Firebase RTDB path: `rateLimits/{userId}/{notifType}`
- Sliding window with cleanup on read (max retention 2h)
- Pure transaction callback (no side effects)
- Same type interfaces as existing `rateLimiter.ts` (RateLimitResult, RateLimitConfig, RateLimitStatus)
</success_criteria>

<output>
After completion, create `.planning/phases/49-persistent-rate-limiting/49-01-SUMMARY.md`
</output>
