---
phase: 49-persistent-rate-limiting
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/netatmoRateLimiterPersistent.ts
  - __tests__/lib/netatmoRateLimiterPersistent.test.ts
autonomous: true

must_haves:
  truths:
    - "Netatmo API rate limits persist across simulated cold starts (400/hour enforced across instances)"
    - "10-second burst limit (50 req/10s) enforced via sliding window timestamps"
    - "Hourly conservative limit (400/hour) enforced via separate window tracking"
    - "Track + check flow works atomically (no race between check and track)"
    - "Expired windows cleaned up on every transaction read"
  artifacts:
    - path: "lib/netatmoRateLimiterPersistent.ts"
      provides: "Firebase RTDB-backed Netatmo API rate limiter"
      exports: ["checkNetatmoRateLimitPersistent", "trackNetatmoApiCallPersistent", "getNetatmoRateLimitPersistentStatus"]
    - path: "__tests__/lib/netatmoRateLimiterPersistent.test.ts"
      provides: "Unit tests for persistent Netatmo rate limiter"
      min_lines: 100
  key_links:
    - from: "lib/netatmoRateLimiterPersistent.ts"
      to: "lib/firebaseAdmin.ts"
      via: "adminDbTransaction import"
      pattern: "import.*adminDbTransaction.*from.*firebaseAdmin"
---

<objective>
Create a Firebase RTDB-backed Netatmo API rate limiter that enforces BOTH the 50 req/10s burst limit and the 400 req/hour conservative limit with persistent state.

Purpose: The current in-memory Netatmo rate limiter resets on cold starts, allowing API quota exhaustion. The persistent version enforces limits across all serverless instances, preventing 429 errors from Netatmo.

Output: `lib/netatmoRateLimiterPersistent.ts` with tests proving dual-window enforcement and persistence.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-persistent-rate-limiting/49-RESEARCH.md
@lib/netatmoRateLimiter.ts
@lib/firebaseAdmin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create persistent Netatmo rate limiter with TDD</name>
  <files>lib/netatmoRateLimiterPersistent.ts, __tests__/lib/netatmoRateLimiterPersistent.test.ts</files>
  <action>
**RED phase:** Create `__tests__/lib/netatmoRateLimiterPersistent.test.ts` with tests for:

1. `checkNetatmoRateLimitPersistent(userId)` returns `Promise<RateLimitCheckResult>`:
   - Allows request when under both limits (fresh user)
   - Blocks when 10s burst limit reached (50 calls in 10s window)
   - Blocks when hourly limit reached (400 calls in 1h window)
   - Returns correct `remaining` count
   - Returns `resetInSeconds` when blocked
   - Resets 10s window after 10 seconds pass
   - Resets hourly window after 1 hour passes

2. `trackNetatmoApiCallPersistent(userId)` returns `Promise<RateLimitTrackResult>`:
   - Increments counter atomically via transaction
   - Creates new entry for new user
   - Returns correct `count`, `limit`, `remaining`
   - Resets count when window expires

3. `getNetatmoRateLimitPersistentStatus(userId)` returns `Promise<RateLimitStatusResult>`:
   - Returns zero count for untracked user
   - Returns correct status for tracked user
   - Returns zero count for expired window

4. Cleanup: expired timestamps filtered on every transaction

Mock `adminDbTransaction` and `adminDbGet` from `@/lib/firebaseAdmin`:
```typescript
jest.mock('@/lib/firebaseAdmin', () => ({
  adminDbTransaction: jest.fn(),
  adminDbGet: jest.fn(),
}));
```

Test transaction callback by capturing the update function and calling with simulated data. Use `jest.useFakeTimers()`.

**GREEN phase:** Create `lib/netatmoRateLimiterPersistent.ts`:

```typescript
import { adminDbTransaction, adminDbGet } from '@/lib/firebaseAdmin';
```

Export same types as `netatmoRateLimiter.ts`: `RateLimitCheckResult`, `RateLimitTrackResult`, `RateLimitStatusResult`, and constants `NETATMO_RATE_LIMIT`, `NETATMO_CONSERVATIVE_LIMIT`.

Firebase RTDB schema for Netatmo rate limits:
```
rateLimits/{userId}/netatmo_api_10s -> { timestamps: number[] }
rateLimits/{userId}/netatmo_api_1h -> { count: number, windowStart: number }
```

Implement `checkNetatmoRateLimitPersistent(userId)`:
- Check BOTH windows:
  1. 10s burst: Read `rateLimits/{userId}/netatmo_api_10s`, filter timestamps to last 10s, check < 50
  2. Hourly: Read `rateLimits/{userId}/netatmo_api_1h`, check count < 400 within current window
- Use `adminDbGet()` for read-only checks (no writes during check)
- Return `RateLimitCheckResult` (same interface as existing)

Implement `trackNetatmoApiCallPersistent(userId)`:
- Atomically update BOTH windows using `adminDbTransaction()`:
  1. 10s burst: Add timestamp, filter old timestamps (> 10s)
  2. Hourly: Increment count (or reset if window expired)
- Return `RateLimitTrackResult` (same interface as existing)

Implement `getNetatmoRateLimitPersistentStatus(userId)`:
- Use `adminDbGet()` to read hourly window state
- Return `RateLimitStatusResult` (same interface as existing)

**IMPORTANT design notes:**
- Separate check from track (existing pattern: check before call, track after successful call)
- Two separate RTDB paths for burst and hourly limits
- Transaction callbacks must be PURE (no side effects)
- Handle null current data (first time case) in all transaction callbacks
- Constants: `NETATMO_BURST_LIMIT = 50`, `NETATMO_BURST_WINDOW_MS = 10_000`, `NETATMO_CONSERVATIVE_LIMIT = 400`, `NETATMO_HOURLY_WINDOW_MS = 3_600_000`

**REFACTOR phase:** Clean separation, JSDoc comments matching existing style.
  </action>
  <verify>
Run `npx jest __tests__/lib/netatmoRateLimiterPersistent.test.ts --no-coverage` - all tests pass.
Verify exports: `checkNetatmoRateLimitPersistent`, `trackNetatmoApiCallPersistent`, `getNetatmoRateLimitPersistentStatus`.
Verify dual-window enforcement (both 10s and 1h limits checked).
  </verify>
  <done>
Persistent Netatmo rate limiter passes all unit tests. Both 50 req/10s burst limit and 400 req/hour conservative limit enforced via Firebase RTDB transactions. Check/track separation maintained. Transaction callbacks pure. Expired timestamps cleaned on every transaction.
  </done>
</task>

</tasks>

<verification>
- `npx jest __tests__/lib/netatmoRateLimiterPersistent.test.ts --no-coverage` passes
- `npx tsc --noEmit lib/netatmoRateLimiterPersistent.ts` no type errors
- Dual-window enforcement: both burst (50/10s) and hourly (400/1h) paths exist
- Exports match existing interface: `RateLimitCheckResult`, `RateLimitTrackResult`, `RateLimitStatusResult`
</verification>

<success_criteria>
- All tests green for persistent Netatmo rate limiter
- Two Firebase RTDB paths: `rateLimits/{userId}/netatmo_api_10s` and `rateLimits/{userId}/netatmo_api_1h`
- Both limits enforced: 50/10s burst AND 400/hour conservative
- Check/track separation maintained (same pattern as existing limiter)
- Pure transaction callbacks
</success_criteria>

<output>
After completion, create `.planning/phases/49-persistent-rate-limiting/49-02-SUMMARY.md`
</output>
