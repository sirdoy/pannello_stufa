---
phase: 49-persistent-rate-limiting
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/coordinationThrottlePersistent.ts
  - __tests__/lib/coordinationThrottlePersistent.test.ts
autonomous: true

must_haves:
  truths:
    - "Coordination throttle persists across simulated cold starts (30-min window survives restart)"
    - "Global throttle enforced: max 1 notification per 30 minutes across ALL coordination event types"
    - "Different users have independent throttle windows"
    - "Recording a notification atomically updates the timestamp via Firebase transaction"
    - "Expired throttle entries cleaned up on read (return null to delete RTDB node)"
  artifacts:
    - path: "lib/coordinationThrottlePersistent.ts"
      provides: "Firebase RTDB-backed coordination notification throttle"
      exports: ["shouldSendCoordinationNotificationPersistent", "recordNotificationSentPersistent", "getThrottlePersistentStatus", "clearThrottlePersistent"]
    - path: "__tests__/lib/coordinationThrottlePersistent.test.ts"
      provides: "Unit tests for persistent coordination throttle"
      min_lines: 80
  key_links:
    - from: "lib/coordinationThrottlePersistent.ts"
      to: "lib/firebaseAdmin.ts"
      via: "adminDbTransaction and adminDbGet imports"
      pattern: "import.*adminDb(Transaction|Get|Set|Remove).*from.*firebaseAdmin"
---

<objective>
Create a Firebase RTDB-backed coordination notification throttle that mirrors the existing `coordinationNotificationThrottle.ts` API but persists the last-sent timestamp via Firebase.

Purpose: The current in-memory throttle resets on cold starts, allowing coordination notification spam after deployments. Firebase persistence ensures the 30-minute global window is enforced across all serverless instances.

Output: `lib/coordinationThrottlePersistent.ts` with tests proving persistence and correct 30-minute global throttle.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-persistent-rate-limiting/49-RESEARCH.md
@lib/coordinationNotificationThrottle.ts
@lib/firebaseAdmin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create persistent coordination throttle with TDD</name>
  <files>lib/coordinationThrottlePersistent.ts, __tests__/lib/coordinationThrottlePersistent.test.ts</files>
  <action>
**RED phase:** Create `__tests__/lib/coordinationThrottlePersistent.test.ts` with tests for:

1. `shouldSendCoordinationNotificationPersistent(userId)` returns `Promise<ThrottleResult>`:
   - Allows first notification (Firebase returns null -> no previous send)
   - Blocks within 30-minute window (Firebase returns recent timestamp)
   - Allows after 30-minute window expires
   - Calculates correct waitSeconds when blocked
   - Different users have independent throttle windows

2. `recordNotificationSentPersistent(userId)` returns `Promise<void>`:
   - Writes current timestamp to Firebase via `adminDbSet`
   - Overwrites previous timestamp atomically

3. `getThrottlePersistentStatus(userId)` returns `Promise<ThrottleStatus>`:
   - Returns null status when no notifications sent (Firebase returns null)
   - Returns correct wait time after notification recorded
   - Returns zero wait time after window expires

4. `clearThrottlePersistent(userId)` returns `Promise<boolean>`:
   - Removes user entry from Firebase
   - Returns false if no entry exists

Mock Firebase admin functions:
```typescript
jest.mock('@/lib/firebaseAdmin', () => ({
  adminDbGet: jest.fn(),
  adminDbSet: jest.fn(),
  adminDbRemove: jest.fn(),
}));
```

Note: The coordination throttle is simpler than the rate limiter (single timestamp, not an array). Use `adminDbSet`/`adminDbGet` instead of transactions for the check. Use `adminDbSet` for recording (not a transaction, because we don't need read-modify-write - just overwrite with current timestamp).

Use `jest.useFakeTimers()` for deterministic time control.

**GREEN phase:** Create `lib/coordinationThrottlePersistent.ts`:

```typescript
import { adminDbGet, adminDbSet, adminDbRemove } from '@/lib/firebaseAdmin';
```

Firebase RTDB schema:
```
rateLimits/{userId}/coordination_throttle -> { lastSentAt: number }
```

Export same interfaces as existing: `ThrottleResult`, `ThrottleStatus`.

Implement `shouldSendCoordinationNotificationPersistent(userId)`:
- Read `rateLimits/{userId}/coordination_throttle` via `adminDbGet()`
- If null or no lastSentAt -> return `{ allowed: true, waitSeconds: 0, reason: null }`
- If `now - lastSentAt < GLOBAL_THROTTLE_MS` (30 min) -> return blocked with waitSeconds
- If expired -> return allowed
- Log decision OUTSIDE of any transaction (pure read -> decision -> log)

Implement `recordNotificationSentPersistent(userId)`:
- Write `{ lastSentAt: Date.now() }` to `rateLimits/{userId}/coordination_throttle` via `adminDbSet()`
- Simple overwrite, no transaction needed (last-writer-wins is correct for timestamps)

Implement `getThrottlePersistentStatus(userId)`:
- Read via `adminDbGet()`, compute status same as existing implementation
- Return `ThrottleStatus` with `lastSentAt`, `nextAllowedAt`, `waitSeconds`

Implement `clearThrottlePersistent(userId)`:
- Check if entry exists via `adminDbGet()`
- If exists, remove via `adminDbRemove()` and return true
- If not exists, return false

**Design decision:** Unlike the notification rate limiter, the coordination throttle stores a single timestamp (not an array). This is simpler - use `adminDbSet`/`adminDbGet` instead of transactions. The read-then-write is acceptable because:
1. The worst case of a race is TWO notifications sent within 30 min (not catastrophic)
2. The record step happens AFTER send, not before (so the window starts after successful send)

Export `GLOBAL_THROTTLE_MS` constant (30 * 60 * 1000 = 1800000) for test assertions.

**REFACTOR phase:** Clean code, JSDoc comments, match existing file's style.
  </action>
  <verify>
Run `npx jest __tests__/lib/coordinationThrottlePersistent.test.ts --no-coverage` - all tests pass.
Verify exports: `shouldSendCoordinationNotificationPersistent`, `recordNotificationSentPersistent`, `getThrottlePersistentStatus`, `clearThrottlePersistent`.
Verify Firebase path: `rateLimits/{userId}/coordination_throttle`.
  </verify>
  <done>
Persistent coordination throttle passes all unit tests. 30-minute global window enforced via Firebase RTDB reads/writes. Single timestamp storage (simple overwrite). Per-user isolation confirmed. Status and clear functions work correctly.
  </done>
</task>

</tasks>

<verification>
- `npx jest __tests__/lib/coordinationThrottlePersistent.test.ts --no-coverage` passes
- `npx tsc --noEmit lib/coordinationThrottlePersistent.ts` no type errors
- Exports match existing interface shape: ThrottleResult, ThrottleStatus
- Firebase path: `rateLimits/{userId}/coordination_throttle`
</verification>

<success_criteria>
- All tests green for persistent coordination throttle
- 30-minute global window persisted in Firebase RTDB
- Simple read/write pattern (no transaction needed for single timestamp)
- Per-user isolation verified in tests
- Same external API shape as existing coordinationNotificationThrottle.ts (but async)
</success_criteria>

<output>
After completion, create `.planning/phases/49-persistent-rate-limiting/49-03-SUMMARY.md`
</output>
