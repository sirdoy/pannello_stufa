---
phase: 49-persistent-rate-limiting
plan: 04
type: execute
wave: 2
depends_on: ["49-01", "49-02", "49-03"]
files_modified:
  - lib/rateLimiter.ts
  - lib/netatmoRateLimiter.ts
  - lib/coordinationNotificationThrottle.ts
  - lib/notificationFilter.ts
  - app/api/netatmo/schedules/route.ts
  - lib/coordinationOrchestrator.ts
  - app/api/health-monitoring/check/route.ts
  - __tests__/lib/netatmoRateLimiter.test.ts
  - __tests__/lib/coordinationNotificationThrottle.test.ts
autonomous: true

must_haves:
  truths:
    - "Feature flag USE_PERSISTENT_RATE_LIMITER controls which implementation is used"
    - "When flag is true, all three limiters use Firebase RTDB-backed implementations"
    - "When flag is false OR Firebase fails, graceful fallback to in-memory limiters"
    - "All existing consumers work without API changes (async/await added where needed)"
    - "Existing tests continue to pass (no regression in notification filter, schedules, health monitoring)"
  artifacts:
    - path: "lib/rateLimiter.ts"
      provides: "Feature-flagged notification rate limiter with persistent fallback"
      exports: ["checkRateLimit", "clearRateLimitForUser", "getRateLimitStatus"]
    - path: "lib/netatmoRateLimiter.ts"
      provides: "Feature-flagged Netatmo rate limiter with persistent fallback"
      exports: ["checkNetatmoRateLimit", "trackNetatmoApiCall", "getNetatmoRateLimitStatus"]
    - path: "lib/coordinationNotificationThrottle.ts"
      provides: "Feature-flagged coordination throttle with persistent fallback"
      exports: ["shouldSendCoordinationNotification", "recordNotificationSent", "getThrottleStatus", "clearThrottle"]
  key_links:
    - from: "lib/rateLimiter.ts"
      to: "lib/rateLimiterPersistent.ts"
      via: "dynamic import based on feature flag"
      pattern: "USE_PERSISTENT_RATE_LIMITER"
    - from: "lib/netatmoRateLimiter.ts"
      to: "lib/netatmoRateLimiterPersistent.ts"
      via: "dynamic import based on feature flag"
      pattern: "USE_PERSISTENT_RATE_LIMITER"
    - from: "lib/coordinationNotificationThrottle.ts"
      to: "lib/coordinationThrottlePersistent.ts"
      via: "dynamic import based on feature flag"
      pattern: "USE_PERSISTENT_RATE_LIMITER"
    - from: "lib/notificationFilter.ts"
      to: "lib/rateLimiter.ts"
      via: "async checkRateLimit call"
      pattern: "await checkRateLimit"
---

<objective>
Wire the three persistent rate limiters into the existing codebase via feature flags. Each existing rate limiter module becomes a facade that delegates to persistent or in-memory implementation based on environment variable, with graceful fallback on Firebase errors.

Purpose: Enable gradual rollout of persistent rate limiting. The feature flag allows testing in staging first, and the fallback ensures the app never breaks if Firebase is unavailable.

Output: Updated rate limiter modules with feature flag routing, updated consumers to handle async APIs, existing tests still passing.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-persistent-rate-limiting/49-RESEARCH.md
@.planning/phases/49-persistent-rate-limiting/49-01-SUMMARY.md
@.planning/phases/49-persistent-rate-limiting/49-02-SUMMARY.md
@.planning/phases/49-persistent-rate-limiting/49-03-SUMMARY.md
@lib/rateLimiter.ts
@lib/netatmoRateLimiter.ts
@lib/coordinationNotificationThrottle.ts
@lib/notificationFilter.ts
@app/api/netatmo/schedules/route.ts
@lib/coordinationOrchestrator.ts
@app/api/health-monitoring/check/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add feature flag routing to all three rate limiter modules</name>
  <files>lib/rateLimiter.ts, lib/netatmoRateLimiter.ts, lib/coordinationNotificationThrottle.ts</files>
  <action>
Add feature flag routing to each of the three existing rate limiter modules. The pattern is identical for each:

**Feature flag constant (add to each file):**
```typescript
const USE_PERSISTENT = process.env.USE_PERSISTENT_RATE_LIMITER === 'true';
```

**Pattern for each module:**

1. **`lib/rateLimiter.ts`** - Make `checkRateLimit` async with feature flag:
   - Keep existing in-memory implementation as `checkRateLimitInMemory()` (rename the existing `checkRateLimit` function)
   - Create new async `checkRateLimit()` that:
     - If `USE_PERSISTENT` is false, calls `checkRateLimitInMemory()` (synchronous, return directly)
     - If `USE_PERSISTENT` is true, tries `checkRateLimitPersistent()` from `./rateLimiterPersistent`
     - On Firebase error, logs warning and falls back to `checkRateLimitInMemory()`
   - Similarly wrap `clearRateLimitForUser` and `getRateLimitStatus` as async with same pattern
   - **CRITICAL:** The return type changes from `RateLimitResult` to `Promise<RateLimitResult>`. This is a breaking change for consumers (handled in Task 2).

2. **`lib/netatmoRateLimiter.ts`** - Make `checkNetatmoRateLimit` and `trackNetatmoApiCall` async:
   - Keep existing in-memory implementations as `checkNetatmoRateLimitInMemory()` and `trackNetatmoApiCallInMemory()`
   - Create async wrappers with same feature flag pattern
   - Import persistent versions from `./netatmoRateLimiterPersistent`
   - On Firebase error, fallback to in-memory

3. **`lib/coordinationNotificationThrottle.ts`** - Make `shouldSendCoordinationNotification` and `recordNotificationSent` async:
   - Keep existing in-memory implementations with `InMemory` suffix
   - Create async wrappers with feature flag pattern
   - Import persistent versions from `./coordinationThrottlePersistent`
   - On Firebase error, fallback to in-memory

**Fallback pattern (same for all three):**
```typescript
export async function checkRateLimit(...args): Promise<RateLimitResult> {
  if (!USE_PERSISTENT) {
    return checkRateLimitInMemory(...args);
  }

  try {
    return await checkRateLimitPersistent(...args);
  } catch (error) {
    console.warn('Persistent rate limiter failed, falling back to in-memory:', error);
    return checkRateLimitInMemory(...args);
  }
}
```

**Important:** Keep all existing exports (types, constants, `_internals`). Only the function signatures change from sync to async.
  </action>
  <verify>
- `npx tsc --noEmit lib/rateLimiter.ts lib/netatmoRateLimiter.ts lib/coordinationNotificationThrottle.ts` no type errors
- Each file has `USE_PERSISTENT` flag
- Each file imports from its persistent counterpart
- Each file has try/catch fallback pattern
  </verify>
  <done>
All three rate limiter modules have feature flag routing. When USE_PERSISTENT_RATE_LIMITER=true, they delegate to Firebase RTDB-backed implementations. On Firebase failure, they fall back to in-memory implementations. Function signatures changed to async.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update consumers for async rate limiter APIs</name>
  <files>lib/notificationFilter.ts, app/api/netatmo/schedules/route.ts, lib/coordinationOrchestrator.ts, app/api/health-monitoring/check/route.ts</files>
  <action>
Update all consumers that call the rate limiter functions to handle the now-async API:

1. **`lib/notificationFilter.ts`** (imports `checkRateLimit` from `./rateLimiter`):
   - Change `filterNotificationByPreferences()` to `async` function
   - Add `await` before `checkRateLimit()` call (line ~110)
   - Return type becomes `Promise<...>` (the existing return type shape is unmodified)
   - **Check:** Are there callers of `filterNotificationByPreferences`? Search for them and ensure they already use `await` (they should, since it's called in API routes which are already async). If not, update those callers too.

2. **`app/api/netatmo/schedules/route.ts`** (imports `checkNetatmoRateLimit`, `trackNetatmoApiCall`):
   - Add `await` before `checkNetatmoRateLimit()` (already in async handler, just add await)
   - Add `await` before `trackNetatmoApiCall()` (same)

3. **`lib/coordinationOrchestrator.ts`** (imports `shouldSendCoordinationNotification`, `recordNotificationSent`):
   - Add `await` before `shouldSendCoordinationNotification()` call
   - Add `await` before `recordNotificationSent()` call
   - The function `processCoordinationCycle` is already async, so just add `await`

4. **`app/api/health-monitoring/check/route.ts`** (imports `shouldSendCoordinationNotification`, `recordNotificationSent`):
   - Add `await` before `shouldSendCoordinationNotification()` call
   - Add `await` before `recordNotificationSent()` call
   - Already in async handler

**Search for additional consumers:** Run grep for all imports of these three modules to ensure no consumer is missed. The research phase identified these four consumers (excluding tests and planning docs).

**Do NOT update test files in this task** - they will continue testing the in-memory path since the feature flag defaults to false (env var not set in test environment).
  </action>
  <verify>
- `npx tsc --noEmit lib/notificationFilter.ts app/api/netatmo/schedules/route.ts lib/coordinationOrchestrator.ts app/api/health-monitoring/check/route.ts` no type errors
- All `checkRateLimit`, `checkNetatmoRateLimit`, `trackNetatmoApiCall`, `shouldSendCoordinationNotification`, `recordNotificationSent` calls have `await`
- Existing tests pass: `npx jest --no-coverage __tests__/lib/netatmoRateLimiter.test.ts __tests__/lib/coordinationNotificationThrottle.test.ts __tests__/lib/coordinationOrchestrator.test.ts`
  </verify>
  <done>
All four consumers updated to use async/await with the rate limiter functions. No type errors. Existing tests pass because feature flag defaults to false (in-memory path used in tests). The async wrapper adds negligible overhead when USE_PERSISTENT is false (sync in-memory function returned as resolved promise).
  </done>
</task>

<task type="auto">
  <name>Task 3: Update existing tests for async API compatibility</name>
  <files>__tests__/lib/netatmoRateLimiter.test.ts, __tests__/lib/coordinationNotificationThrottle.test.ts</files>
  <action>
Update existing tests to handle the async API changes. Since the feature flag defaults to false (env var not set), the existing tests should still work via the in-memory path, but the function signatures are now async so tests need `await`.

1. **`__tests__/lib/netatmoRateLimiter.test.ts`**:
   - Add `async` to all test callbacks that call `checkNetatmoRateLimit`, `trackNetatmoApiCall`, or `getNetatmoRateLimitStatus`
   - Add `await` before each call to these functions
   - Example: `const result = checkNetatmoRateLimit(testUserId);` -> `const result = await checkNetatmoRateLimit(testUserId);`
   - The assertions remain unchanged (they test the same return shape)

2. **`__tests__/lib/coordinationNotificationThrottle.test.ts`**:
   - Add `async` to all test callbacks that call `shouldSendCoordinationNotification`, `recordNotificationSent`, `getThrottleStatus`, or `clearThrottle`
   - Add `await` before each call to these functions
   - Assertions remain unchanged

**Also search for other test files** that import from these modules:
- `__tests__/lib/coordinationOrchestrator.test.ts` - check if it mocks `coordinationNotificationThrottle`. If it does, the mocks may need updating to return Promises. Check and fix if needed.
- `__tests__/api/netatmo/schedules.test.ts` - check if it mocks `netatmoRateLimiter`. If it does, update mocks to return Promises.

**Important:** Do NOT modify the `_internals` manipulation in tests (`.clear()`, `.set()`, etc.) - those interact with the in-memory Map directly and don't need async.
  </action>
  <verify>
- `npx jest --no-coverage __tests__/lib/netatmoRateLimiter.test.ts __tests__/lib/coordinationNotificationThrottle.test.ts` all pass
- `npx jest --no-coverage __tests__/lib/coordinationOrchestrator.test.ts` passes (if mocks were updated)
- `npx jest --no-coverage __tests__/api/netatmo/schedules.test.ts` passes (if mocks were updated)
- Run full test suite: `npx jest --no-coverage` to check for regressions
  </verify>
  <done>
All existing tests updated for async API. Tests pass via in-memory path (feature flag off). Mock functions return Promises where needed. No regressions in full test suite.
  </done>
</task>

</tasks>

<verification>
- Full test suite passes: `npx jest --no-coverage`
- No tsc errors: `npx tsc --noEmit`
- Feature flag works: grep for `USE_PERSISTENT_RATE_LIMITER` in all three limiter files
- Fallback pattern: grep for `catch.*fallback` in all three limiter files
- All consumers use await: grep for `await.*checkRateLimit\|await.*checkNetatmoRateLimit\|await.*shouldSendCoordinationNotification`
</verification>

<success_criteria>
- Feature flag `USE_PERSISTENT_RATE_LIMITER` controls all three rate limiters
- Fallback to in-memory on Firebase failure (try/catch in each wrapper)
- All consumers (notificationFilter, schedules route, coordinationOrchestrator, health-monitoring) use async/await
- All existing tests pass (no regression)
- Full test suite green
</success_criteria>

<output>
After completion, create `.planning/phases/49-persistent-rate-limiting/49-04-SUMMARY.md`
</output>
