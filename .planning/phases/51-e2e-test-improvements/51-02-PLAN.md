---
phase: 51-e2e-test-improvements
plan: 02
type: execute
wave: 2
depends_on: ["51-01"]
files_modified:
  - tests/smoke/auth-flows.spec.ts
  - tests/features/stove-ignition.spec.ts
  - tests/features/thermostat-schedule.spec.ts
autonomous: true

must_haves:
  truths:
    - "Auth smoke tests verify signin and signout flows work with real Auth0"
    - "Stove ignition test navigates to home, finds stove card, clicks ignite, and verifies status change"
    - "Thermostat schedule test navigates to thermostat, changes schedule, and verifies update"
    - "Feature tests start already authenticated without repeating the Auth0 login flow"
    - "Tests locate elements by accessible role or test-id, not by CSS class names"
  artifacts:
    - path: "tests/smoke/auth-flows.spec.ts"
      provides: "Auth flow smoke tests (signin, signout)"
      contains: "signIn"
    - path: "tests/features/stove-ignition.spec.ts"
      provides: "Stove ignition critical flow test"
      contains: "stove"
    - path: "tests/features/thermostat-schedule.spec.ts"
      provides: "Thermostat schedule change critical flow test"
      contains: "thermostat"
  key_links:
    - from: "tests/smoke/auth-flows.spec.ts"
      to: "tests/helpers/auth.helpers.ts"
      via: "import signIn, signOut"
      pattern: "import.*auth.helpers"
    - from: "tests/features/stove-ignition.spec.ts"
      to: "app/page.tsx"
      via: "navigates to home page where StoveCard renders"
      pattern: "page.goto.*/"
    - from: "tests/features/thermostat-schedule.spec.ts"
      to: "app/page.tsx"
      via: "navigates to home page where ThermostatCard renders"
      pattern: "page.goto.*/"
---

<objective>
Create auth smoke tests and critical flow E2E tests for stove ignition and thermostat schedule change.

Purpose: Validate that Auth0 authentication works end-to-end and that the two most critical device control flows (stove power control and thermostat scheduling) function correctly from the user's perspective.

Output: 3 test spec files covering auth flows, stove ignition, and thermostat schedule change
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/51-e2e-test-improvements/51-01-SUMMARY.md

# Source files for understanding UI structure
@app/page.tsx
@app/components/devices/stove/StoveCard.tsx
@app/components/devices/thermostat/ThermostatCard.tsx
@tests/helpers/auth.helpers.ts
@tests/helpers/test-context.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth smoke tests</name>
  <files>
    tests/smoke/auth-flows.spec.ts
  </files>
  <action>
Create `tests/smoke/auth-flows.spec.ts` for verifying Auth0 authentication flows.

These tests explicitly CLEAR storageState so they test the actual login/logout flow (not cached state).

```typescript
import { test, expect } from '@playwright/test';
import { signIn, signOut } from '../helpers/auth.helpers';
import { TEST_USER } from '../helpers/test-context';

test.describe('Authentication Flows', () => {
  // Clear auth state - these tests verify the actual auth flow
  test.use({ storageState: { cookies: [], origins: [] } });

  test('should complete signin flow via Auth0', async ({ page }) => {
    await signIn(page, TEST_USER.email, TEST_USER.password);

    // After successful login, user should be on the home page
    await expect(page).toHaveURL(/localhost:3000\/?$/);

    // Dashboard should be visible (proves authenticated state)
    await expect(page.getByRole('heading', { name: 'Dashboard', level: 1 })).toBeVisible();
  });

  test('should redirect unauthenticated user to login', async ({ page }) => {
    // Try to access protected page without auth
    await page.goto('/');

    // Should redirect to Auth0 login
    await expect(page).toHaveURL(/auth\/login|auth0/);
  });

  test('should complete signout flow', async ({ page }) => {
    // First sign in
    await signIn(page, TEST_USER.email, TEST_USER.password);

    // Then sign out
    await signOut(page);

    // Should be redirected to login page
    await expect(page).toHaveURL(/auth\/login/);
  });
});
```

**IMPORTANT NOTES:**
- The `test.use({ storageState: { cookies: [], origins: [] } })` override clears the cached session for this specific describe block, so these tests exercise the real Auth0 login flow.
- The Dashboard heading uses `level: 1` because `app/page.tsx` renders `<h1 className="sr-only">Dashboard</h1>` (screen-reader only but still queryable by Playwright).
- Auth0 redirect may go to the Auth0 domain first, then back. Use regex patterns to handle both local and Auth0 URLs.
- The signout test requires signing in first (can't sign out without a session).
  </action>
  <verify>
  - `cat tests/smoke/auth-flows.spec.ts` shows 3 tests: signin, redirect, signout
  - Tests use `test.use({ storageState: { cookies: [], origins: [] } })` to clear cached auth
  - Tests import from `../helpers/auth.helpers` and `../helpers/test-context`
  - No hardcoded credentials in test file
  </verify>
  <done>
  - Auth smoke tests verify real Auth0 signin, redirect-on-unauth, and signout flows
  - Tests use cleared storageState to exercise actual auth flow
  - All credentials sourced from environment-based TEST_USER
  </done>
</task>

<task type="auto">
  <name>Task 2: Create stove ignition and thermostat schedule critical flow tests</name>
  <files>
    tests/features/stove-ignition.spec.ts
    tests/features/thermostat-schedule.spec.ts
  </files>
  <action>
Create two critical flow E2E tests. These tests run with the cached storageState from auth.setup.ts (already authenticated).

**MANDATORY PRE-STEP: Read source components and extract selectors BEFORE writing any test code.**

Run these commands first and record the output:
1. `grep -n "data-testid\|aria-label\|getByRole\|role=" app/components/devices/stove/StoveCard.tsx` — extract test IDs and ARIA attributes
2. `grep -n "data-testid\|aria-label\|getByRole\|role=" app/components/devices/thermostat/ThermostatCard.tsx` — extract test IDs and ARIA attributes
3. Read the full files `app/components/devices/stove/StoveCard.tsx` and `app/components/devices/thermostat/ThermostatCard.tsx` to understand button labels, heading text, and status display elements.

Use ONLY selectors that match real DOM elements found in step 1-3. Do NOT use the hypothetical selectors from the examples below — they are illustrative patterns only. Replace them with the actual element names discovered from the source components.

**1. `tests/features/stove-ignition.spec.ts`**:

```typescript
import { test, expect } from '@playwright/test';

test.describe('Stove Ignition Flow', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    // Wait for page to fully load (dashboard cards render via server components)
    await page.waitForLoadState('networkidle');
  });

  test('should display stove card with current status', async ({ page }) => {
    // Verify StoveCard is visible on dashboard
    // NOTE: Read StoveCard.tsx to find actual heading text - likely "Stufa" or similar
    const stoveCard = page.locator('[data-testid="stove-card"]').or(
      page.getByRole('heading', { name: /stufa/i }).locator('..')
    );
    await expect(stoveCard.first()).toBeVisible({ timeout: 15000 });
  });

  test('should show stove status indicator', async ({ page }) => {
    // Verify the stove status is displayed (Accesa/Spenta/etc.)
    // The actual status depends on real stove state - just verify the card renders with some status
    // NOTE: Executor must read StoveCard.tsx to find the actual status display element
    const statusElement = page.getByTestId('stove-status').or(
      page.locator('[class*="status"]').first()
    );

    // Status should be visible (exact value depends on actual stove state)
    await expect(statusElement.first()).toBeVisible({ timeout: 15000 });
  });

  // NOTE: Ignition test is READ-ONLY to avoid side effects on real devices
  // We verify the UI is interactive but do NOT actually ignite the stove
  test('should have ignition controls available', async ({ page }) => {
    // Verify the ignition button/control exists and is interactive
    // NOTE: Executor must read StoveCard.tsx for actual button text (likely "Accendi" or power button)
    const igniteControl = page.getByRole('button', { name: /accendi|power|avvia/i }).first();

    // If stove is already on, the button might say "Spegni" instead
    const shutdownControl = page.getByRole('button', { name: /spegni|shutdown|arresta/i }).first();

    // At least one control should be visible (either ignite or shutdown depending on state)
    const hasControl = await igniteControl.isVisible().catch(() => false) ||
      await shutdownControl.isVisible().catch(() => false);

    expect(hasControl).toBe(true);
  });
});
```

**2. `tests/features/thermostat-schedule.spec.ts`**:

```typescript
import { test, expect } from '@playwright/test';

test.describe('Thermostat Schedule Flow', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await page.waitForLoadState('networkidle');
  });

  test('should display thermostat card with current temperature', async ({ page }) => {
    // Verify ThermostatCard is visible on dashboard
    // NOTE: Read ThermostatCard.tsx for actual heading - likely "Termostato"
    const thermostatCard = page.locator('[data-testid="thermostat-card"]').or(
      page.getByRole('heading', { name: /termostato/i }).locator('..')
    );
    await expect(thermostatCard.first()).toBeVisible({ timeout: 15000 });
  });

  test('should show current temperature reading', async ({ page }) => {
    // Verify temperature is displayed
    // NOTE: Executor must read ThermostatCard.tsx for actual temperature display structure
    // Temperature is typically shown as "XX.X°C" or "XX°"
    const tempDisplay = page.getByText(/\d+[\.,]?\d*\s*°/);
    await expect(tempDisplay.first()).toBeVisible({ timeout: 15000 });
  });

  test('should show active schedule name', async ({ page }) => {
    // Verify the active schedule is displayed
    // NOTE: Read ThermostatCard.tsx - likely shows schedule name like "Comfort", "Eco", etc.
    // The card should display which schedule is currently active
    const scheduleInfo = page.getByTestId('schedule-name').or(
      page.getByText(/schedule|programma/i)
    );
    await expect(scheduleInfo.first()).toBeVisible({ timeout: 15000 });
  });

  // NOTE: Schedule change test is READ-ONLY to avoid side effects on real Netatmo
  // We verify the schedule UI is accessible and interactive
  test('should have schedule controls available', async ({ page }) => {
    // Look for schedule-related controls (dropdown, buttons, etc.)
    // NOTE: Executor must read ThermostatCard.tsx for actual control structure
    const scheduleControls = page.getByRole('button', { name: /schedule|programma|modifica/i }).or(
      page.getByRole('combobox')  // Schedule dropdown selector
    );

    // At least one schedule control should be present
    const hasControls = await scheduleControls.first().isVisible({ timeout: 10000 }).catch(() => false);
    expect(hasControls).toBe(true);
  });
});
```

**CRITICAL IMPLEMENTATION NOTES:**
1. **READ ACTUAL COMPONENTS FIRST**: The selectors above are educated guesses. The executor MUST read `StoveCard.tsx` and `ThermostatCard.tsx` to use the real element names, test IDs, and text content. Adjust selectors accordingly.
2. **READ-ONLY TESTS**: These tests do NOT perform destructive actions (igniting stove, changing schedule) because they run against real devices. They verify the UI renders correctly and controls are available.
3. **Generous timeouts**: Use `{ timeout: 15000 }` for assertions since the dashboard loads device data via API polling (5-second intervals for stove status).
4. **Fallback selectors**: Use `.or()` pattern to handle multiple possible selector strategies. Prefer `getByRole` and `getByTestId` over CSS classes.
5. **No `waitForTimeout`**: Use Playwright's auto-waiting via `expect().toBeVisible()` with timeouts instead of `page.waitForTimeout()`.
  </action>
  <verify>
  - `cat tests/features/stove-ignition.spec.ts` shows 3 tests for stove card visibility, status, and controls
  - `cat tests/features/thermostat-schedule.spec.ts` shows 4 tests for thermostat card, temperature, schedule, and controls
  - Neither test file performs destructive actions (no actual ignite/shutdown/schedule change)
  - Both test files use role-based and test-id selectors
  - No hardcoded credentials
  - **Selector audit**: For each `getByRole`, `getByTestId`, or `getByText` call, verify the target string actually exists in the source component (`StoveCard.tsx`, `ThermostatCard.tsx`). Run `grep -r "data-testid" app/components/devices/stove/ app/components/devices/thermostat/` and `grep -r "aria-label" app/components/devices/stove/ app/components/devices/thermostat/` to confirm selectors match real DOM attributes.
  </verify>
  <done>
  - Stove ignition tests verify card renders with status and interactive controls
  - Thermostat schedule tests verify card renders with temperature, schedule, and controls
  - All tests are read-only (safe to run against real devices)
  - Selectors use accessibility-first approach (getByRole, getByTestId)
  </done>
</task>

</tasks>

<verification>
1. `tests/smoke/auth-flows.spec.ts` exists with 3 auth tests (signin, redirect, signout)
2. `tests/features/stove-ignition.spec.ts` exists with stove card tests
3. `tests/features/thermostat-schedule.spec.ts` exists with thermostat card tests
4. All feature tests run with cached storageState (no per-test login)
5. Auth smoke tests clear storageState to test real auth flow
6. No destructive actions on real devices
7. All selectors use role-based or test-id approach
</verification>

<success_criteria>
- Auth smoke tests verify real Auth0 signin/signout flows
- Stove ignition test verifies card renders with status and controls
- Thermostat schedule test verifies card renders with temperature and schedule info
- All tests use cached session state (except auth smoke tests which explicitly clear it)
- No side effects on real devices (read-only tests)
</success_criteria>

<output>
After completion, create `.planning/phases/51-e2e-test-improvements/51-02-SUMMARY.md`
</output>
