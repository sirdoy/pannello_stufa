---
phase: 52-interactive-push-notifications
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/notificationActions.ts
  - lib/firebaseAdmin.ts
  - lib/notificationService.ts
autonomous: true

must_haves:
  truths:
    - "Notification action constants are defined in a shared module preventing typos between server and service worker"
    - "Feature detection correctly identifies browsers supporting notification actions via Notification.maxActions"
    - "FCM payloads include webpush.notification.actions array for supported platforms"
    - "iOS tokens receive apns.payload.aps.category but no webpush actions (graceful degradation)"
    - "Android tokens receive android.notification.clickAction for intent handling"
  artifacts:
    - path: "lib/notificationActions.ts"
      provides: "Action constants, feature detection, notification action definitions"
      exports: ["NOTIFICATION_ACTIONS", "ACTION_CATEGORIES", "getStoveActions", "getThermostatActions", "supportsNotificationActions", "getNotificationCapabilities"]
    - path: "lib/firebaseAdmin.ts"
      provides: "Enhanced sendPushNotification with actions support"
      contains: "webpush.*actions"
    - path: "lib/notificationService.ts"
      provides: "Client-side feature detection export"
      contains: "supportsNotificationActions"
  key_links:
    - from: "lib/notificationActions.ts"
      to: "lib/firebaseAdmin.ts"
      via: "Action definitions imported for FCM payload construction"
      pattern: "import.*notificationActions"
    - from: "lib/notificationActions.ts"
      to: "lib/notificationService.ts"
      via: "Feature detection re-exported for client use"
      pattern: "supportsNotificationActions"
---

<objective>
Create the foundation for interactive push notifications: shared action constants module, feature detection for notification action support, and server-side FCM payload enhancement to include action buttons and platform-specific configuration.

Purpose: Establishes the shared vocabulary (action IDs) and server-side infrastructure that both the service worker (Plan 02) and notification triggers (Plan 03) will consume. Without this, action IDs would be hardcoded strings prone to typos across server and client.

Output: `lib/notificationActions.ts` (new), enhanced `lib/firebaseAdmin.ts`, enhanced `lib/notificationService.ts`
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-interactive-push-notifications/52-RESEARCH.md
@lib/firebaseAdmin.ts
@lib/notificationService.ts
@types/firebase/notifications.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create notification actions module with constants and feature detection</name>
  <files>lib/notificationActions.ts</files>
  <action>
Create `lib/notificationActions.ts` with:

1. **Action ID constants** (const object, not enum, for tree-shaking):
```typescript
export const NOTIFICATION_ACTIONS = {
  STOVE_SHUTDOWN: 'stove-shutdown',
  STOVE_VIEW_DETAILS: 'view-details',
  THERMOSTAT_MANUAL: 'thermostat-manual',
  THERMOSTAT_VIEW: 'thermostat-view',
} as const;
```

2. **Action category constants** for iOS `aps.category` and Android `clickAction`:
```typescript
export const ACTION_CATEGORIES = {
  STOVE_ERROR: 'STOVE_ERROR_ACTIONS',
  STOVE_STATUS: 'STOVE_STATUS_ACTIONS',
  THERMOSTAT_ALERT: 'THERMOSTAT_ALERT_ACTIONS',
  MAINTENANCE: 'MAINTENANCE_ACTIONS',
} as const;
```

3. **Action definition type and factory functions**:
```typescript
export interface NotificationActionDef {
  action: string;
  title: string;
  icon?: string;
}

export function getStoveActions(): NotificationActionDef[] {
  return [
    { action: NOTIFICATION_ACTIONS.STOVE_SHUTDOWN, title: 'Spegni stufa' },
    { action: NOTIFICATION_ACTIONS.STOVE_VIEW_DETAILS, title: 'Dettagli' },
  ];
}

export function getThermostatActions(): NotificationActionDef[] {
  return [
    { action: NOTIFICATION_ACTIONS.THERMOSTAT_MANUAL, title: 'Imposta manuale' },
    { action: NOTIFICATION_ACTIONS.THERMOSTAT_VIEW, title: 'Dettagli' },
  ];
}
```

4. **Feature detection** (client-side, guards for SSR):
```typescript
export function supportsNotificationActions(): boolean {
  if (typeof window === 'undefined') return false;
  if (!('Notification' in window)) return false;
  try {
    return 'maxActions' in Notification && (Notification as any).maxActions > 0;
  } catch {
    return false;
  }
}

export function getNotificationCapabilities() {
  if (typeof window === 'undefined') {
    return { supported: false, actions: false, maxActions: 0, platform: 'server' as const };
  }
  const supported = 'Notification' in window && 'serviceWorker' in navigator;
  let maxActions = 0;
  try {
    if ('Notification' in window && 'maxActions' in Notification) {
      maxActions = (Notification as any).maxActions;
    }
  } catch { /* ignore */ }
  return {
    supported,
    actions: maxActions > 0,
    maxActions,
    platform: (/iphone|ipad|ipod/i.test(navigator.userAgent) ? 'ios' : 'other') as 'ios' | 'other',
  };
}
```

5. **Helper to get actions by notification type** (maps notification type IDs to action definitions):
```typescript
export function getActionsForNotificationType(typeId: string): NotificationActionDef[] | null {
  // Stove error/critical notifications get shutdown action
  if (typeId.startsWith('stove_error') || typeId === 'monitoring_stove_error') {
    return getStoveActions();
  }
  // Stove unexpected off gets shutdown action
  if (typeId === 'stove_unexpected_off') {
    return getStoveActions();
  }
  // Thermostat/Netatmo alerts get manual mode action
  if (typeId.startsWith('netatmo_')) {
    return getThermostatActions();
  }
  // No actions for other types (scheduler, maintenance, system)
  return null;
}
```

Do NOT import from `lib/notificationService.ts` (avoid circular dependency). The feature detection here is standalone.
  </action>
  <verify>Run `npx tsc --noEmit lib/notificationActions.ts` (or check tsc passes). Verify exports: NOTIFICATION_ACTIONS, ACTION_CATEGORIES, getStoveActions, getThermostatActions, supportsNotificationActions, getNotificationCapabilities, getActionsForNotificationType.</verify>
  <done>lib/notificationActions.ts exists with action constants, feature detection, and type-to-action mapping. No circular dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Enhance FCM payload in firebaseAdmin.ts to include notification actions</name>
  <files>lib/firebaseAdmin.ts, lib/notificationService.ts</files>
  <action>
**In `lib/firebaseAdmin.ts`:**

1. Add import at top:
```typescript
import { getActionsForNotificationType, ACTION_CATEGORIES, type NotificationActionDef } from './notificationActions';
```

2. Extend the `NotificationPayload` interface to accept actions:
```typescript
interface NotificationPayload {
  title?: string;
  body?: string;
  data?: Record<string, string>;
  icon?: string;
  priority?: 'high' | 'normal';
  actions?: NotificationActionDef[];  // NEW
}
```

3. In `sendPushNotification()`, modify the message construction to include actions in the webpush notification payload. Find the `webpush` block inside `const message = { ... }` and add the actions array:

```typescript
webpush: {
  notification: {
    title: notification.title || 'Pannello Stufa',
    body: notification.body || '',
    icon: notification.icon || '/icons/icon-192.png',
    badge: '/icons/icon-72.png',
    requireInteraction: notification.priority === 'high',
    vibrate: notification.priority === 'high' ? [200, 100, 200] : [100],
    // Add notification actions if provided
    ...(notification.actions && notification.actions.length > 0 && {
      actions: notification.actions.map(a => ({
        action: a.action,
        title: a.title,
        ...(a.icon && { icon: a.icon }),
      })),
    }),
  },
  fcmOptions: {
    link: notification.data?.url || '/',
  },
},
```

4. Enhance the `apns` block to include category when actions are present:
```typescript
apns: {
  payload: {
    aps: {
      alert: {
        title: notification.title || 'Pannello Stufa',
        body: notification.body || '',
      },
      sound: 'default',
      badge: 1,
      ...(notification.priority === 'high' && {
        'content-available': 1,
        priority: 10,
      }),
      // Add category for action buttons (iOS native apps)
      // iOS Safari PWA doesn't render actions but category is future-proof
      ...(notification.actions && notification.actions.length > 0 && {
        category: getCategoryForActions(notification.data?.type),
      }),
    },
  },
},
```

5. Add helper function before `sendPushNotification`:
```typescript
function getCategoryForActions(notificationType?: string): string {
  if (!notificationType) return ACTION_CATEGORIES.STOVE_STATUS;
  if (notificationType.startsWith('stove_error') || notificationType === 'CRITICAL' || notificationType === 'ERROR') {
    return ACTION_CATEGORIES.STOVE_ERROR;
  }
  if (notificationType.startsWith('netatmo') || notificationType === 'status') {
    return ACTION_CATEGORIES.THERMOSTAT_ALERT;
  }
  if (notificationType === 'maintenance') {
    return ACTION_CATEGORIES.MAINTENANCE;
  }
  return ACTION_CATEGORIES.STOVE_STATUS;
}
```

6. Enhance the `android` block to include clickAction when actions are present:
```typescript
android: {
  priority: (notification.priority === 'high' ? 'high' : 'normal') as 'high' | 'normal',
  notification: {
    channelId: 'default',
    priority: (notification.priority === 'high' ? 'high' : 'default') as 'high' | 'default',
    defaultSound: true,
    defaultVibrateTimings: true,
    // Add click action for Android intent filtering when actions present
    ...(notification.actions && notification.actions.length > 0 && {
      clickAction: getCategoryForActions(notification.data?.type),
    }),
  },
},
```

**In `lib/notificationService.ts`:**

Add a re-export of feature detection for client-side use (at bottom of file):
```typescript
// Re-export notification action capabilities for client-side feature detection
export { supportsNotificationActions, getNotificationCapabilities } from './notificationActions';
```

Do NOT modify the existing `isNotificationSupported()` function - these are complementary.
  </action>
  <verify>Run `npx tsc --noEmit` to check no type errors. Verify that `sendPushNotification` signature accepts `actions` in the notification parameter. Verify `lib/notificationService.ts` re-exports the feature detection.</verify>
  <done>sendPushNotification accepts optional actions array, includes them in webpush/apns/android payloads. Feature detection re-exported from notificationService.ts for client use.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no new errors
2. `lib/notificationActions.ts` exports: NOTIFICATION_ACTIONS, ACTION_CATEGORIES, getStoveActions, getThermostatActions, supportsNotificationActions, getNotificationCapabilities, getActionsForNotificationType
3. `lib/firebaseAdmin.ts` sendPushNotification includes actions in webpush.notification.actions when provided
4. `lib/firebaseAdmin.ts` includes apns.payload.aps.category when actions present
5. `lib/firebaseAdmin.ts` includes android.notification.clickAction when actions present
6. `lib/notificationService.ts` re-exports supportsNotificationActions and getNotificationCapabilities
7. No circular dependencies between modules
</verification>

<success_criteria>
- Shared action constants module exists with compile-time safety for action IDs
- Feature detection correctly returns false on server (SSR) and iOS Safari
- FCM payloads include platform-specific action configuration
- No existing tests broken
</success_criteria>

<output>
After completion, create `.planning/phases/52-interactive-push-notifications/52-01-SUMMARY.md`
</output>
