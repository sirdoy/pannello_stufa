---
phase: 52-interactive-push-notifications
plan: 02
type: execute
wave: 2
depends_on: ["52-01"]
files_modified:
  - app/sw.ts
autonomous: true

must_haves:
  truths:
    - "Push notifications display action buttons (Spegni stufa, Imposta manuale) on Chrome/Android"
    - "Clicking 'Spegni stufa' action button calls /api/stove/shutdown directly from service worker"
    - "Clicking 'Imposta manuale' action button opens /thermostat?mode=manual"
    - "Clicking notification body (no action) opens the app at the correct URL"
    - "When offline, action clicks queue the command via IndexedDB + Background Sync"
    - "Offline-queued actions show confirmation notification with tag preventing duplicates"
    - "All async work in notificationclick wrapped in event.waitUntil()"
  artifacts:
    - path: "app/sw.ts"
      provides: "Enhanced push handler with actions, notificationclick action detection, offline queue"
      contains: "event.action"
  key_links:
    - from: "app/sw.ts push handler"
      to: "showNotification"
      via: "payload.notification.actions passed to notification options"
      pattern: "actions.*payload"
    - from: "app/sw.ts notificationclick"
      to: "/api/stove/shutdown"
      via: "fetch POST when online"
      pattern: "fetch.*stove/shutdown"
    - from: "app/sw.ts notificationclick"
      to: "IndexedDB commandQueue"
      via: "Queue command when offline for Background Sync"
      pattern: "commandQueue.*readwrite"
---

<objective>
Enhance the service worker to display notification action buttons and handle action clicks. When a user clicks an action button ("Spegni stufa" or "Imposta manuale"), the SW either executes the API call immediately (online) or queues it via Background Sync (offline).

Purpose: This is the client-side counterpart to Plan 01's server-side payload. The SW receives FCM pushes with actions, shows them as buttons, and handles user clicks. This enables direct device control from the notification banner without opening the app.

Output: Enhanced `app/sw.ts` with action display and handling
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-interactive-push-notifications/52-RESEARCH.md
@.planning/phases/52-interactive-push-notifications/52-01-SUMMARY.md
@app/sw.ts
@lib/pwa/backgroundSync.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance push handler to display notification actions and refactor notificationclick for action support</name>
  <files>app/sw.ts</files>
  <action>
**IMPORTANT:** The service worker file (`app/sw.ts`) cannot import from `lib/notificationActions.ts` at build time because Serwist compiles it separately. Duplicate the action ID constants inline in the SW file (they are simple strings, duplication is acceptable and documented in research as recommended pattern).

**Step 1: Add action constants at top of SW file (after existing constants, around line 179)**

```typescript
// ============================================
// Notification Action Constants
// ============================================
// Duplicated from lib/notificationActions.ts (SW compiled separately by Serwist)
const NOTIFICATION_ACTION_IDS = {
  STOVE_SHUTDOWN: 'stove-shutdown',
  STOVE_VIEW_DETAILS: 'view-details',
  THERMOSTAT_MANUAL: 'thermostat-manual',
  THERMOSTAT_VIEW: 'thermostat-view',
} as const;
```

**Step 2: Modify the FIRST push event listener (lines 104-134)**

Update the `notificationOptions` to include actions from the push payload:

```typescript
self.addEventListener('push', (event) => {
  if (!event.data) return;

  let payload;
  try {
    payload = event.data.json();
  } catch {
    return;
  }

  const notificationTitle = payload.notification?.title || 'Pannello Stufa';
  const notificationOptions = {
    body: payload.notification?.body || '',
    icon: payload.notification?.icon || '/icons/icon-192.png',
    badge: '/icons/icon-72.png',
    tag: payload.data?.type || 'default',
    requireInteraction: payload.data?.priority === 'high',
    data: {
      url: payload.data?.url || '/',
      ...payload.data,
    },
    vibrate: payload.data?.priority === 'high' ? [200, 100, 200] : [100],
    // Include action buttons from FCM payload (Chrome/Edge/Opera only)
    // iOS Safari ignores this array (no support for notification actions)
    ...(payload.notification?.actions && {
      actions: payload.notification.actions,
    }),
  } as NotificationOptions & { vibrate?: number[]; actions?: Array<{ action: string; title: string; icon?: string }> };

  event.waitUntil(
    self.registration.showNotification(notificationTitle, notificationOptions)
  );
});
```

**Step 3: Replace the existing notificationclick handler (lines 140-167) with action-aware version**

Replace the existing `notificationclick` listener entirely:

```typescript
/**
 * Notification click handler with action button support
 *
 * Handles three scenarios:
 * 1. Action button click (event.action has value) - execute action directly
 * 2. Notification body click (event.action is empty) - open app at URL
 * 3. Offline action - queue via Background Sync
 */
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const notificationData = event.notification.data || {};
  const clickedAction = event.action; // empty string if body clicked

  if (clickedAction === NOTIFICATION_ACTION_IDS.STOVE_SHUTDOWN) {
    // User clicked "Spegni stufa" action button
    event.waitUntil(executeNotificationAction('stove/shutdown', {
      source: 'notification-action',
      type: notificationData.type || 'unknown',
    }));

  } else if (clickedAction === NOTIFICATION_ACTION_IDS.THERMOSTAT_MANUAL) {
    // User clicked "Imposta manuale" action button - open thermostat page in manual mode
    event.waitUntil(openAppUrl('/thermostat?mode=manual'));

  } else if (clickedAction === NOTIFICATION_ACTION_IDS.STOVE_VIEW_DETAILS || clickedAction === NOTIFICATION_ACTION_IDS.THERMOSTAT_VIEW) {
    // User clicked "Dettagli" - open app at notification URL
    const url = notificationData.url || '/';
    event.waitUntil(openAppUrl(url));

  } else {
    // User clicked notification body (no action) - open app
    const urlToOpen = notificationData.url || '/';
    event.waitUntil(openAppUrl(urlToOpen));
  }
});
```

**Step 4: Add helper functions before the notificationclick handler**

```typescript
/**
 * Execute a notification action (online: immediate API call, offline: queue for sync)
 */
async function executeNotificationAction(
  endpoint: string,
  data: Record<string, string>
): Promise<void> {
  if (navigator.onLine) {
    try {
      const response = await fetch(`/api/${endpoint}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      if (response.ok) {
        // Show success notification
        await self.registration.showNotification('Comando eseguito', {
          body: getActionSuccessMessage(endpoint),
          icon: '/icons/icon-192.png',
          badge: '/icons/icon-72.png',
          tag: `action-success-${endpoint.replace('/', '-')}`,
        });
      } else {
        // Show failure notification
        await self.registration.showNotification('Errore comando', {
          body: `Impossibile eseguire il comando. Riprova dall'app.`,
          icon: '/icons/icon-192.png',
          badge: '/icons/icon-72.png',
          tag: `action-error-${endpoint.replace('/', '-')}`,
        });
      }
    } catch (error) {
      console.error('[sw.ts] Action execution failed:', error);
      // Network error - queue for later
      await queueActionForSync(endpoint, data);
    }
  } else {
    // Offline - queue for Background Sync
    await queueActionForSync(endpoint, data);
  }
}

/**
 * Queue an action for Background Sync execution
 * Uses existing IndexedDB commandQueue store
 */
async function queueActionForSync(
  endpoint: string,
  data: Record<string, string>
): Promise<void> {
  try {
    const db = await openDB();
    const transaction = db.transaction(COMMAND_QUEUE_STORE, 'readwrite');
    const store = transaction.objectStore(COMMAND_QUEUE_STORE);

    const command = {
      endpoint,
      method: 'POST',
      data: { ...data, source: 'notification-action-offline' },
      status: 'pending',
      timestamp: new Date().toISOString(),
      retries: 0,
      lastError: null,
    };

    store.add(command);

    await new Promise<void>((resolve, reject) => {
      transaction.oncomplete = () => resolve();
      transaction.onerror = () => reject(transaction.error);
    });

    // Register Background Sync
    try {
      await self.registration.sync.register(SYNC_TAG);
    } catch {
      // SyncManager not supported - will retry on next online event
    }

    // Show "queued" notification (tag prevents duplicates from repeated clicks)
    await self.registration.showNotification('Comando in coda', {
      body: 'Il comando verra eseguito al ripristino della connessione',
      icon: '/icons/icon-192.png',
      badge: '/icons/icon-72.png',
      tag: `action-queued-${endpoint.replace('/', '-')}`,
    });
  } catch (error) {
    console.error('[sw.ts] Failed to queue action:', error);
  }
}

/**
 * Get success message for action type
 */
function getActionSuccessMessage(endpoint: string): string {
  switch (endpoint) {
    case 'stove/shutdown':
      return 'Stufa spenta con successo';
    default:
      return 'Comando eseguito con successo';
  }
}

/**
 * Open app at specified URL, focusing existing window if available
 */
async function openAppUrl(url: string): Promise<void> {
  const clientList = await self.clients.matchAll({
    type: 'window',
    includeUncontrolled: true,
  });

  // If app is already open, focus it and navigate
  for (const client of clientList) {
    if (client.url.includes(self.location.origin) && 'focus' in client) {
      await client.focus();
      if ('navigate' in client) {
        await (client as WindowClient).navigate(url);
      }
      return;
    }
  }

  // Otherwise open new window
  if (self.clients.openWindow) {
    await self.clients.openWindow(url);
  }
}
```

**Step 5: Update the periodicsync stove error notification to include actions**

Find the `checkStoveStatusBackground()` function (around line 559). When it shows the "Errore Stufa" notification, add actions:

```typescript
if (data.error || data.errorCode) {
  await self.registration.showNotification('Errore Stufa', {
    body: data.errorMessage || `Codice errore: ${data.errorCode}`,
    icon: '/icons/icon-192.png',
    badge: '/icons/icon-72.png',
    tag: 'stove-error',
    requireInteraction: true,
    data: { url: '/' },
    vibrate: [200, 100, 200, 100, 200],
    // Add action buttons for quick shutdown
    actions: [
      { action: NOTIFICATION_ACTION_IDS.STOVE_SHUTDOWN, title: 'Spegni stufa' },
      { action: NOTIFICATION_ACTION_IDS.STOVE_VIEW_DETAILS, title: 'Dettagli' },
    ],
  } as NotificationOptions & { vibrate?: number[]; actions?: Array<{ action: string; title: string }> });

  await incrementBadge();
}
```

**IMPORTANT NOTES:**
- The `sync` property on ServiceWorkerRegistration is not in all TypeScript DOM libs. Use existing pattern in the file (it already calls `self.registration.sync.register`).
- Do NOT remove the duplicate push event listener at line 491 (`Enhanced Push Handler with Badge`) - it handles badge incrementing separately.
- Keep the `openAppUrl` function separate from the existing URL navigation code - the old notificationclick handler is being fully replaced.
  </action>
  <verify>
1. `npx tsc --noEmit` passes (or only pre-existing errors)
2. Check `app/sw.ts` contains `event.action` in notificationclick handler
3. Check `app/sw.ts` contains `NOTIFICATION_ACTION_IDS` constant
4. Check `app/sw.ts` push handler includes `actions` spread from payload
5. Check `queueActionForSync` writes to `commandQueue` store
6. Check `openAppUrl` function exists and is used by all notification click paths
  </verify>
  <done>Service worker shows action buttons on supported platforms, handles action clicks with online API call or offline Background Sync queue, and shows appropriate feedback notifications.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. Push handler includes actions from FCM payload in showNotification options
3. Notificationclick handler checks `event.action` for each defined action ID
4. Stove shutdown action calls `/api/stove/shutdown` when online
5. Thermostat manual action opens `/thermostat?mode=manual`
6. Offline actions queued to IndexedDB commandQueue with Background Sync registration
7. Queued notifications use `tag` to prevent duplicate "in coda" notifications
8. All async work wrapped in `event.waitUntil()`
9. Periodic sync stove error notification includes action buttons
</verification>

<success_criteria>
- Notification action buttons visible on Chrome/Android (2 buttons per notification)
- Action clicks execute API calls or queue for offline sync
- Tap on notification body still opens app at correct URL (backward compatible)
- No service worker crashes or unhandled promise rejections
</success_criteria>

<output>
After completion, create `.planning/phases/52-interactive-push-notifications/52-02-SUMMARY.md`
</output>
