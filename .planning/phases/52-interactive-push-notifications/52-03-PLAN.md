---
phase: 52-interactive-push-notifications
plan: 03
type: execute
wave: 2
depends_on: ["52-01"]
files_modified:
  - lib/notificationTriggersServer.ts
  - lib/notificationTriggers.ts
  - __tests__/lib/notificationActions.test.ts
autonomous: true

must_haves:
  truths:
    - "Stove error notifications automatically include 'Spegni stufa' action button when triggered server-side"
    - "Thermostat/Netatmo notifications automatically include 'Imposta manuale' action button when triggered server-side"
    - "Non-actionable notifications (scheduler, system) have no action buttons"
    - "Action constants, feature detection, and type-to-action mapping are covered by unit tests"
  artifacts:
    - path: "lib/notificationTriggersServer.ts"
      provides: "Automatic action button injection in notification payloads"
      contains: "getActionsForNotificationType"
    - path: "lib/notificationTriggers.ts"
      provides: "Updated NOTIFICATION_TYPES with action metadata"
      contains: "actions"
    - path: "__tests__/lib/notificationActions.test.ts"
      provides: "Tests for action constants, feature detection, type mapping"
      contains: "describe.*notificationActions"
  key_links:
    - from: "lib/notificationTriggersServer.ts"
      to: "lib/notificationActions.ts"
      via: "Imports getActionsForNotificationType to inject actions into payloads"
      pattern: "import.*getActionsForNotificationType.*notificationActions"
    - from: "lib/notificationTriggersServer.ts"
      to: "lib/firebaseAdmin.ts"
      via: "Passes actions in notification payload to sendNotificationToUser"
      pattern: "actions.*getActionsForNotificationType"
---

<objective>
Wire notification action buttons into the server-side trigger system so stove and thermostat notifications automatically include the correct action buttons. Create comprehensive unit tests for the notification actions module.

Purpose: Without this wiring, the server-side notification triggers won't include actions in the FCM payload. This plan connects Plan 01's action definitions to the existing notification trigger flow, making action buttons appear automatically for the right notification types.

Output: Enhanced `lib/notificationTriggersServer.ts`, enhanced `lib/notificationTriggers.ts`, new `__tests__/lib/notificationActions.test.ts`
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-interactive-push-notifications/52-RESEARCH.md
@.planning/phases/52-interactive-push-notifications/52-01-SUMMARY.md
@lib/notificationTriggersServer.ts
@lib/notificationTriggers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire action buttons into notification trigger system</name>
  <files>lib/notificationTriggersServer.ts, lib/notificationTriggers.ts</files>
  <action>
**In `lib/notificationTriggersServer.ts`:**

1. Add import at top:
```typescript
import { getActionsForNotificationType, type NotificationActionDef } from '@/lib/notificationActions';
```

2. In the `triggerNotificationServer()` function, after the notification object is built (around line 222-233), inject actions based on notification type. Find this block:

```typescript
const notification = {
  title: payload.notification.title,
  body: payload.notification.body,
  icon: payload.notification.icon,
  priority: payload.data.priority as 'high' | 'normal',
  data: {
    ...stringData,
    type: newTypeName,
    legacyTypeId: typeId,
  },
};
```

Replace with:

```typescript
// Determine action buttons for this notification type
const actions = getActionsForNotificationType(typeId);

const notification = {
  title: payload.notification.title,
  body: payload.notification.body,
  icon: payload.notification.icon,
  priority: payload.data.priority as 'high' | 'normal',
  data: {
    ...stringData,
    type: newTypeName,
    legacyTypeId: typeId,
  },
  // Include action buttons for supported notification types
  // Stove errors get "Spegni stufa", thermostat alerts get "Imposta manuale"
  ...(actions && { actions }),
};
```

That's it for the server-side wiring. The `sendNotificationToUser` -> `sendPushNotification` flow from Plan 01 will pick up the actions and include them in the FCM payload.

**In `lib/notificationTriggers.ts`:**

1. Add a JSDoc comment to the NOTIFICATION_TYPES explaining the action button behavior. Find the comment block before `export const NOTIFICATION_TYPES = {` and add:

```typescript
 * Action buttons:
 * - Stove error/status types automatically get "Spegni stufa" + "Dettagli" buttons
 * - Netatmo types automatically get "Imposta manuale" + "Dettagli" buttons
 * - Action mapping is in lib/notificationActions.ts (getActionsForNotificationType)
```

2. Add an `actionable` field to the stove error types to document which ones get actions. This is for documentation only (the actual logic is in `notificationActions.ts`). For each stove_error type, add a comment:

For `stove_error_critical`, `stove_error_error`, `stove_error_warning`:
```typescript
// Action buttons: "Spegni stufa", "Dettagli" (via lib/notificationActions.ts)
```

For `stove_unexpected_off`:
```typescript
// Action buttons: "Spegni stufa", "Dettagli" (via lib/notificationActions.ts)
```

For `netatmo_temperature_low`, `netatmo_temperature_high`, `netatmo_setpoint_reached`, `netatmo_connection_lost`:
```typescript
// Action buttons: "Imposta manuale", "Dettagli" (via lib/notificationActions.ts)
```

These are COMMENTS ONLY, not code changes. The runtime logic stays in `notificationActions.ts`.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Grep `lib/notificationTriggersServer.ts` for `getActionsForNotificationType` - must be imported and called
3. Grep `lib/notificationTriggersServer.ts` for `actions` in the notification object construction
4. The notification object spread `...(actions && { actions })` is present
  </verify>
  <done>Server-side notification triggers automatically inject action buttons for stove and thermostat notification types. Non-actionable types (scheduler, maintenance, system) get no actions.</done>
</task>

<task type="auto">
  <name>Task 2: Create unit tests for notification actions module</name>
  <files>__tests__/lib/notificationActions.test.ts</files>
  <action>
Create `__tests__/lib/notificationActions.test.ts` with comprehensive tests:

```typescript
import {
  NOTIFICATION_ACTIONS,
  ACTION_CATEGORIES,
  getStoveActions,
  getThermostatActions,
  getActionsForNotificationType,
  supportsNotificationActions,
  getNotificationCapabilities,
} from '@/lib/notificationActions';

describe('notificationActions', () => {
  describe('NOTIFICATION_ACTIONS constants', () => {
    it('defines stove shutdown action', () => {
      expect(NOTIFICATION_ACTIONS.STOVE_SHUTDOWN).toBe('stove-shutdown');
    });

    it('defines stove view details action', () => {
      expect(NOTIFICATION_ACTIONS.STOVE_VIEW_DETAILS).toBe('view-details');
    });

    it('defines thermostat manual action', () => {
      expect(NOTIFICATION_ACTIONS.THERMOSTAT_MANUAL).toBe('thermostat-manual');
    });

    it('defines thermostat view action', () => {
      expect(NOTIFICATION_ACTIONS.THERMOSTAT_VIEW).toBe('thermostat-view');
    });
  });

  describe('ACTION_CATEGORIES constants', () => {
    it('defines stove error category', () => {
      expect(ACTION_CATEGORIES.STOVE_ERROR).toBe('STOVE_ERROR_ACTIONS');
    });

    it('defines thermostat alert category', () => {
      expect(ACTION_CATEGORIES.THERMOSTAT_ALERT).toBe('THERMOSTAT_ALERT_ACTIONS');
    });

    it('defines maintenance category', () => {
      expect(ACTION_CATEGORIES.MAINTENANCE).toBe('MAINTENANCE_ACTIONS');
    });
  });

  describe('getStoveActions', () => {
    it('returns array with shutdown and view-details actions', () => {
      const actions = getStoveActions();
      expect(actions).toHaveLength(2);
      expect(actions[0]).toEqual({
        action: 'stove-shutdown',
        title: 'Spegni stufa',
      });
      expect(actions[1]).toEqual({
        action: 'view-details',
        title: 'Dettagli',
      });
    });
  });

  describe('getThermostatActions', () => {
    it('returns array with manual and view actions', () => {
      const actions = getThermostatActions();
      expect(actions).toHaveLength(2);
      expect(actions[0]).toEqual({
        action: 'thermostat-manual',
        title: 'Imposta manuale',
      });
      expect(actions[1]).toEqual({
        action: 'thermostat-view',  // Note: might be 'view-details' per spec, adjust to match actual
        title: 'Dettagli',
      });
    });
  });

  describe('getActionsForNotificationType', () => {
    it('returns stove actions for stove_error_critical', () => {
      const actions = getActionsForNotificationType('stove_error_critical');
      expect(actions).not.toBeNull();
      expect(actions![0]!.action).toBe(NOTIFICATION_ACTIONS.STOVE_SHUTDOWN);
    });

    it('returns stove actions for stove_error_error', () => {
      const actions = getActionsForNotificationType('stove_error_error');
      expect(actions).not.toBeNull();
      expect(actions![0]!.action).toBe(NOTIFICATION_ACTIONS.STOVE_SHUTDOWN);
    });

    it('returns stove actions for stove_error_warning', () => {
      const actions = getActionsForNotificationType('stove_error_warning');
      expect(actions).not.toBeNull();
      expect(actions![0]!.action).toBe(NOTIFICATION_ACTIONS.STOVE_SHUTDOWN);
    });

    it('returns stove actions for stove_unexpected_off', () => {
      const actions = getActionsForNotificationType('stove_unexpected_off');
      expect(actions).not.toBeNull();
      expect(actions![0]!.action).toBe(NOTIFICATION_ACTIONS.STOVE_SHUTDOWN);
    });

    it('returns stove actions for monitoring_stove_error', () => {
      const actions = getActionsForNotificationType('monitoring_stove_error');
      expect(actions).not.toBeNull();
      expect(actions![0]!.action).toBe(NOTIFICATION_ACTIONS.STOVE_SHUTDOWN);
    });

    it('returns thermostat actions for netatmo_temperature_low', () => {
      const actions = getActionsForNotificationType('netatmo_temperature_low');
      expect(actions).not.toBeNull();
      expect(actions![0]!.action).toBe(NOTIFICATION_ACTIONS.THERMOSTAT_MANUAL);
    });

    it('returns thermostat actions for netatmo_temperature_high', () => {
      const actions = getActionsForNotificationType('netatmo_temperature_high');
      expect(actions).not.toBeNull();
      expect(actions![0]!.action).toBe(NOTIFICATION_ACTIONS.THERMOSTAT_MANUAL);
    });

    it('returns thermostat actions for netatmo_connection_lost', () => {
      const actions = getActionsForNotificationType('netatmo_connection_lost');
      expect(actions).not.toBeNull();
      expect(actions![0]!.action).toBe(NOTIFICATION_ACTIONS.THERMOSTAT_MANUAL);
    });

    it('returns null for scheduler_ignition (no actions)', () => {
      expect(getActionsForNotificationType('scheduler_ignition')).toBeNull();
    });

    it('returns null for scheduler_shutdown (no actions)', () => {
      expect(getActionsForNotificationType('scheduler_shutdown')).toBeNull();
    });

    it('returns null for maintenance_80 (no actions)', () => {
      expect(getActionsForNotificationType('maintenance_80')).toBeNull();
    });

    it('returns null for system_update (no actions)', () => {
      expect(getActionsForNotificationType('system_update')).toBeNull();
    });

    it('returns null for unknown type', () => {
      expect(getActionsForNotificationType('unknown_type')).toBeNull();
    });
  });

  describe('supportsNotificationActions', () => {
    it('returns false on server (no window)', () => {
      // In Jest/Node, window is not undefined but Notification is not available
      // The function should handle this gracefully
      expect(typeof supportsNotificationActions()).toBe('boolean');
    });

    it('returns false when Notification API not available', () => {
      // Default test env doesn't have Notification
      expect(supportsNotificationActions()).toBe(false);
    });
  });

  describe('getNotificationCapabilities', () => {
    it('returns capabilities object', () => {
      const caps = getNotificationCapabilities();
      expect(caps).toHaveProperty('supported');
      expect(caps).toHaveProperty('actions');
      expect(caps).toHaveProperty('maxActions');
      expect(typeof caps.maxActions).toBe('number');
    });

    it('reports actions not supported in test environment', () => {
      const caps = getNotificationCapabilities();
      expect(caps.actions).toBe(false);
      expect(caps.maxActions).toBe(0);
    });
  });
});
```

**IMPORTANT NOTES:**
- Adjust the thermostat view action ID if the actual implementation uses a different value (check Plan 01 output)
- Use `!` non-null assertion after null check (the `expect(actions).not.toBeNull()` line above guarantees it)
- The test file verifies the mapping logic, not the FCM send (that's integration territory)
- Feature detection tests are limited in Jest/jsdom since Notification.maxActions isn't available
  </action>
  <verify>
1. `npx jest __tests__/lib/notificationActions.test.ts --no-coverage` - all tests pass
2. Test file covers: constants, factory functions, type-to-action mapping, feature detection edge cases
3. No import errors or TypeScript issues
  </verify>
  <done>Unit tests cover all notification action constants, factory functions, type-to-action mapping with positive and negative cases, and feature detection edge cases. Tests pass.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npx jest __tests__/lib/notificationActions.test.ts --no-coverage` passes
3. Stove error notification types get "Spegni stufa" action automatically
4. Netatmo notification types get "Imposta manuale" action automatically
5. Scheduler, maintenance, system types get no actions
6. No existing tests broken
</verification>

<success_criteria>
- Server-side triggers automatically include action buttons for stove and thermostat notifications
- Non-actionable notification types have no action buttons
- Unit tests validate all action mappings with at least 15 test cases
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/52-interactive-push-notifications/52-03-SUMMARY.md`
</output>
