---
phase: 53-pwa-offline-improvements
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/pwa/stalenessDetector.ts
  - lib/hooks/useDeviceStaleness.ts
  - lib/pwa/__tests__/stalenessDetector.test.ts
  - lib/hooks/__tests__/useDeviceStaleness.test.ts
autonomous: true

must_haves:
  truths:
    - "Staleness detector determines whether cached device data is older than 30 seconds"
    - "useDeviceStaleness hook provides real-time staleness info (isStale, cachedAt, ageSeconds) per device"
    - "Staleness info updates on a 5-second polling interval"
    - "Command expiration enforced: safety-critical commands (ignite, shutdown) expire after 1 hour"
  artifacts:
    - path: "lib/pwa/stalenessDetector.ts"
      provides: "Staleness detection logic and command expiration"
      exports: ["getDeviceStaleness", "isCommandExpired", "STALENESS_THRESHOLD"]
      min_lines: 30
    - path: "lib/hooks/useDeviceStaleness.ts"
      provides: "React hook for device staleness state"
      exports: ["useDeviceStaleness"]
      min_lines: 25
    - path: "lib/pwa/__tests__/stalenessDetector.test.ts"
      provides: "Tests for staleness detection and command expiration"
      min_lines: 40
    - path: "lib/hooks/__tests__/useDeviceStaleness.test.ts"
      provides: "Tests for useDeviceStaleness hook"
      min_lines: 30
  key_links:
    - from: "lib/pwa/stalenessDetector.ts"
      to: "lib/pwa/indexedDB.ts"
      via: "IndexedDB get for device state"
      pattern: "get.*STORES.DEVICE_STATE"
    - from: "lib/hooks/useDeviceStaleness.ts"
      to: "lib/pwa/stalenessDetector.ts"
      via: "import getDeviceStaleness"
      pattern: "getDeviceStaleness"
---

<objective>
Create staleness detection service and React hook for determining device data freshness, plus command expiration for safety-critical offline commands.

Purpose: Device cards need to know whether cached data is stale (>30s old) to show appropriate staleness UI, and offline commands need expiration to prevent dangerous stale-intent execution.
Output: stalenessDetector.ts service + useDeviceStaleness.ts hook + tests (TDD)
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@lib/pwa/indexedDB.ts
@lib/pwa/offlineStateCache.ts
@lib/pwa/backgroundSync.ts
</context>

<feature>
  <name>Staleness Detection and Command Expiration</name>
  <files>lib/pwa/stalenessDetector.ts, lib/hooks/useDeviceStaleness.ts, lib/pwa/__tests__/stalenessDetector.test.ts, lib/hooks/__tests__/useDeviceStaleness.test.ts</files>
  <behavior>
    **stalenessDetector.ts:**
    - `getDeviceStaleness(deviceId: string)` → `Promise<StalenessInfo>`
    - Reads from IndexedDB DEVICE_STATE store using `get(STORES.DEVICE_STATE, deviceId)`
    - Returns `{ isStale: boolean, cachedAt: Date | null, ageSeconds: number }`
    - `STALENESS_THRESHOLD = 30000` (30 seconds per PWA-02)
    - If no cached data or no timestamp → `{ isStale: true, cachedAt: null, ageSeconds: Infinity }`
    - If cached data exists → compare `Date.now() - cachedTimestamp` against threshold

    **Command expiration (Claude's discretion - safety):**
    - `isCommandExpired(command: { endpoint: string, timestamp: string })` → `boolean`
    - Safety-critical endpoints ('stove/ignite', 'stove/shutdown', 'stove/set-power'): expire after 1 hour (3600000ms)
    - Read-only endpoints: never expire
    - Returns true if command age exceeds threshold for its type

    **useDeviceStaleness hook:**
    - `useDeviceStaleness(deviceId: string)` → `StalenessInfo | null`
    - Calls `getDeviceStaleness` on mount and every 5 seconds
    - Returns null initially, then StalenessInfo
    - Cleans up interval on unmount

    Cases:
    - getDeviceStaleness('stove') with fresh data (5s old) → { isStale: false, cachedAt: Date, ageSeconds: 5 }
    - getDeviceStaleness('stove') with stale data (60s old) → { isStale: true, cachedAt: Date, ageSeconds: 60 }
    - getDeviceStaleness('unknown') with no data → { isStale: true, cachedAt: null, ageSeconds: Infinity }
    - isCommandExpired({ endpoint: 'stove/ignite', timestamp: 2hrsAgo }) → true
    - isCommandExpired({ endpoint: 'stove/ignite', timestamp: 30minsAgo }) → false
    - isCommandExpired({ endpoint: 'status/get', timestamp: 5hrsAgo }) → false (read-only)
  </behavior>
  <implementation>
    **stalenessDetector.ts:**
    - Import `get, STORES` from `./indexedDB`
    - Export StalenessInfo interface
    - Export STALENESS_THRESHOLD constant
    - Safety-critical endpoints list: `SAFETY_CRITICAL_ENDPOINTS = ['stove/ignite', 'stove/shutdown', 'stove/set-power']`
    - Command expiration: `COMMAND_EXPIRY_MS = 60 * 60 * 1000` (1 hour)

    **useDeviceStaleness.ts:**
    - Import from `@/lib/pwa/stalenessDetector`
    - useState for StalenessInfo | null
    - useEffect with setInterval(5000) calling getDeviceStaleness
    - Cleanup interval on unmount

    **Tests follow RED→GREEN→REFACTOR:**
    - Mock `lib/pwa/indexedDB` for staleness tests
    - Use `renderHook` from `@testing-library/react` for hook tests
    - Use `jest.useFakeTimers()` for interval testing
  </implementation>
</feature>

<verification>
1. `npx tsc --noEmit` passes
2. `npm test -- --testPathPattern="stalenessDetector" --no-coverage` passes
3. `npm test -- --testPathPattern="useDeviceStaleness" --no-coverage` passes
</verification>

<success_criteria>
- stalenessDetector correctly identifies stale vs fresh cached data
- Command expiration works for safety-critical vs read-only commands
- useDeviceStaleness hook polls every 5 seconds and returns correct staleness info
- All tests pass with TDD RED→GREEN→REFACTOR cycle
</success_criteria>

<output>
After completion, create `.planning/phases/53-pwa-offline-improvements/53-02-SUMMARY.md`
</output>
