---
phase: 55-retry-infrastructure
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/retry/idempotencyManager.ts
  - lib/retry/__tests__/idempotencyManager.test.ts
autonomous: true

must_haves:
  truths:
    - "Every device command gets a unique idempotency key before being sent"
    - "Same endpoint + same body within TTL returns the same idempotency key"
    - "Idempotency keys are stored in Firebase RTDB with 1-hour TTL"
    - "Expired keys are cleaned up and no longer match"
  artifacts:
    - path: "lib/retry/idempotencyManager.ts"
      provides: "Idempotency key generation, storage in Firebase RTDB, duplicate detection"
      exports: ["idempotencyManager", "IdempotencyManager"]
    - path: "lib/retry/__tests__/idempotencyManager.test.ts"
      provides: "Unit tests for idempotency logic"
      contains: "registerKey"
  key_links:
    - from: "lib/retry/idempotencyManager.ts"
      to: "lib/firebase.ts"
      via: "Firebase RTDB ref/get/set for key storage"
      pattern: "import.*from.*firebase"
---

<objective>
Create the idempotency key manager that generates and stores idempotency keys in Firebase RTDB to prevent duplicate physical actions across all device commands.

Purpose: Implements RETRY-04 (idempotency keys for device commands). Per locked decision, ALL device commands (stove, Hue, Netatmo) get idempotency protection, not just ignite/shutdown. Keys are stored in Firebase RTDB with a 1-hour TTL for distributed access across tabs and devices.

Output: Tested `idempotencyManager.ts` module ready for integration with the retry client and API routes.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-retry-infrastructure/55-RESEARCH.md

@lib/firebase.ts — Firebase client SDK with db export
@lib/core/apiErrors.ts — ERROR_CODES for reference
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement idempotencyManager with TDD</name>
  <files>lib/retry/idempotencyManager.ts, lib/retry/__tests__/idempotencyManager.test.ts</files>
  <action>
RED phase — Create `lib/retry/__tests__/idempotencyManager.test.ts` with these test cases:

Mock `firebase/database` module (ref, get, set, remove) — use `jest.mock('firebase/database')` and mock `@/lib/firebase` to export a fake db.

Test cases:
- `generateKey` returns a valid UUID string (crypto.randomUUID format)
- `registerKey` returns a new key for a fresh endpoint+body combination
- `registerKey` returns the SAME key when called again with same endpoint+body within TTL
- `registerKey` returns a NEW key when the existing key has expired (simulated by setting expiresAt in past)
- `registerKey` stores key in Firebase RTDB at `idempotency/keys/{key}` path
- `registerKey` stores lookup entry at `idempotency/lookup/{hash}` path
- `cleanupExpired` removes keys where `Date.now() > expiresAt`
- `cleanupExpired` does NOT remove keys that are still valid
- Keys include endpoint, body hash, createdAt, and expiresAt fields
- TTL defaults to 1 hour (3600000ms)

Use `jest.useFakeTimers()` for time-sensitive tests. Run tests: they MUST fail (RED).

GREEN phase — Create `lib/retry/idempotencyManager.ts`:

```typescript
import { ref, get, set, remove } from 'firebase/database';
import { db } from '@/lib/firebase';

interface IdempotencyRecord {
  key: string;
  endpoint: string;
  bodyHash: string;
  createdAt: number;
  expiresAt: number;
}

export class IdempotencyManager {
  private readonly TTL_MS = 60 * 60 * 1000; // 1 hour

  generateKey(): string { return crypto.randomUUID(); }

  async registerKey(endpoint: string, body: Record<string, unknown>): Promise<string> { ... }

  async cleanupExpired(): Promise<number> { ... } // Returns count of cleaned keys
}

export const idempotencyManager = new IdempotencyManager();
```

Implementation notes:
- `registerKey`: Create lookup hash from `endpoint:JSON.stringify(body)` — use a simple hash or the raw string as Firebase key (sanitize `/`, `.`, `$`, `#`, `[`, `]` characters for Firebase key compatibility)
- Check `idempotency/lookup/{sanitizedHash}` in Firebase RTDB. If exists and not expired, return existing key.
- If not found or expired, generate new UUID key, store both `idempotency/keys/{key}` and `idempotency/lookup/{sanitizedHash}` records.
- `cleanupExpired`: Iterate all keys, remove expired ones, return count.
- Use `Date.now()` for timestamps (can be mocked with fake timers).
- Sanitize Firebase keys by replacing forbidden chars with underscores.

Run tests: they MUST pass (GREEN).

REFACTOR — Add JSDoc to all exports. Ensure `IdempotencyRecord` type is exported for server-side use.
  </action>
  <verify>Run `npx jest lib/retry/__tests__/idempotencyManager.test.ts --no-coverage` — all tests pass</verify>
  <done>IdempotencyManager generates UUID keys, stores them in Firebase RTDB with 1-hour TTL, returns existing keys for duplicate endpoint+body combinations, and cleans up expired keys. All tests pass.</done>
</task>

</tasks>

<verification>
```bash
npx jest lib/retry/__tests__/idempotencyManager.test.ts --no-coverage --verbose
```
All idempotency tests pass. Module exports clean TypeScript interfaces.
</verification>

<success_criteria>
- idempotencyManager.ts exports idempotencyManager singleton, IdempotencyManager class, IdempotencyRecord type
- generateKey returns crypto.randomUUID() strings
- registerKey returns same key for same endpoint+body within TTL
- registerKey returns new key after TTL expires
- Firebase RTDB paths are properly sanitized
- cleanupExpired removes only expired keys
- All tests pass with mocked Firebase
</success_criteria>

<output>
After completion, create `.planning/phases/55-retry-infrastructure/55-02-SUMMARY.md`
</output>
