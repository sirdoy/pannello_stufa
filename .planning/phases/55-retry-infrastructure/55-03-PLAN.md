---
phase: 55-retry-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["55-01", "55-02"]
files_modified:
  - app/components/ui/ToastProvider.tsx
  - lib/hooks/useRetryableCommand.ts
  - lib/hooks/__tests__/useRetryableCommand.test.ts
autonomous: true

must_haves:
  truths:
    - "Error toasts are persistent until manually dismissed (not auto-disappear)"
    - "Error toasts have an inline Retry button that triggers the command again"
    - "Toast auto-dismisses after user taps Retry or X"
    - "useRetryableCommand hook orchestrates retry + toast + dedup + idempotency in one call"
  artifacts:
    - path: "app/components/ui/ToastProvider.tsx"
      provides: "Enhanced toast with persistent error support (duration 0)"
      exports: ["ToastProvider", "ToastContext"]
    - path: "lib/hooks/useRetryableCommand.ts"
      provides: "Hook combining retry, toast, dedup, and idempotency for device commands"
      exports: ["useRetryableCommand"]
    - path: "lib/hooks/__tests__/useRetryableCommand.test.ts"
      provides: "Unit tests for the retry hook"
      contains: "useRetryableCommand"
  key_links:
    - from: "lib/hooks/useRetryableCommand.ts"
      to: "lib/retry/retryClient.ts"
      via: "retryFetch import for auto-retry logic"
      pattern: "import.*retryFetch.*from.*retryClient"
    - from: "lib/hooks/useRetryableCommand.ts"
      to: "lib/retry/deduplicationManager.ts"
      via: "deduplicationManager import for double-tap prevention"
      pattern: "import.*deduplicationManager.*from.*deduplicationManager"
    - from: "lib/hooks/useRetryableCommand.ts"
      to: "lib/retry/idempotencyManager.ts"
      via: "idempotencyManager import for idempotency key injection"
      pattern: "import.*idempotencyManager.*from.*idempotencyManager"
    - from: "lib/hooks/useRetryableCommand.ts"
      to: "app/hooks/useToast.ts"
      via: "useToast for showing error/success toasts"
      pattern: "import.*useToast.*from.*useToast"
---

<objective>
Enhance the ToastProvider for persistent error toasts and create the `useRetryableCommand` hook that orchestrates retry, toast, deduplication, and idempotency into a single API for device components.

Purpose: This plan wires the infrastructure from Plans 01 and 02 into a React hook that device cards will consume. The hook is the SINGLE integration point (RETRY-06: single retry layer at API boundary), so device components do NOT need to know about retry logic, dedup, or idempotency. They just call `execute(url, options)` and get automatic retry, persistent error toasts, deduplication, and idempotency.

Output: Enhanced ToastProvider and a tested `useRetryableCommand` hook.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-retry-infrastructure/55-RESEARCH.md

@app/components/ui/ToastProvider.tsx — Current toast provider (needs persistent error support)
@app/components/ui/Toast.tsx — Toast component with action button support
@app/hooks/useToast.ts — useToast hook
@lib/retry/retryClient.ts — Will exist from Plan 01
@lib/retry/deduplicationManager.ts — Will exist from Plan 01
@lib/retry/idempotencyManager.ts — Will exist from Plan 02

Read 55-01-SUMMARY.md and 55-02-SUMMARY.md for actual exports and patterns.
@.planning/phases/55-retry-infrastructure/55-01-SUMMARY.md
@.planning/phases/55-retry-infrastructure/55-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance ToastProvider for persistent error toasts</name>
  <files>app/components/ui/ToastProvider.tsx</files>
  <action>
Modify `app/components/ui/ToastProvider.tsx` to properly support persistent error toasts:

1. **Persistent toast support**: When `duration` is `0`, the toast should NOT auto-dismiss. Radix Toast supports this natively — set `duration` to `Infinity` when the user passes `0` (Radix treats 0 as "no duration" which may dismiss immediately, so use `Infinity` for truly persistent behavior, OR check Radix docs and use the correct approach).

2. **Error toast defaults**: Change the error convenience method to use `duration: 0` (persistent) by default per locked user decision. Currently it defaults to 8000ms. Change:
   ```typescript
   // Before
   const defaultDuration = variant === 'error' ? 8000 : 5000;
   // After
   const defaultDuration = variant === 'error' ? 0 : 5000;
   ```
   Note: When duration is 0, convert to `Infinity` for Radix (or use the appropriate Radix API for no-auto-dismiss — research the `duration` prop behavior in `@radix-ui/react-toast`).

3. **Increase max visible toasts for errors**: Currently capped at 3. Increase to 5 to accommodate persistent error toasts that stack up. Change: `const visibleToasts = toasts.slice(-5);`

4. **Do NOT change the Toast.tsx component itself** — it already supports action buttons and close (X) button.

Verify: Error toasts created via `useToast().error('message')` are persistent (no auto-dismiss). Success/info/warning toasts still auto-dismiss after 5s.
  </action>
  <verify>Existing Toast tests still pass: `npx jest app/components/ui/__tests__/Toast.test.tsx --no-coverage`</verify>
  <done>Error toasts are persistent by default (duration: 0/Infinity). Other variants auto-dismiss at 5s. Max visible toasts increased to 5.</done>
</task>

<task type="auto">
  <name>Task 2: Create useRetryableCommand hook with tests</name>
  <files>lib/hooks/useRetryableCommand.ts, lib/hooks/__tests__/useRetryableCommand.test.ts</files>
  <action>
Create `lib/hooks/useRetryableCommand.ts` — the single integration point for device commands:

```typescript
'use client';

import { useState, useCallback, useRef } from 'react';
import { useToast } from '@/app/hooks/useToast';
import { retryFetch, isTransientError, RetryError } from '@/lib/retry/retryClient';
import { deduplicationManager, createRequestKey } from '@/lib/retry/deduplicationManager';
import { idempotencyManager } from '@/lib/retry/idempotencyManager';

interface CommandOptions {
  /** Device name for dedup key (e.g., 'stove', 'hue', 'netatmo') */
  device: string;
  /** Action name for dedup key (e.g., 'ignite', 'shutdown', 'setFan') */
  action: string;
  /** Show success toast after recovery from error (not on first success) */
  showSuccessOnRecovery?: boolean;
}

interface CommandResult {
  /** Execute a device command with retry + dedup + idempotency */
  execute: (url: string, fetchOptions?: RequestInit) => Promise<Response | null>;
  /** Whether a retry is currently in progress */
  isRetrying: boolean;
  /** Number of retry attempts made */
  attemptCount: number;
  /** Last error that occurred (null if none) */
  lastError: Error | null;
  /** Whether the command is currently executing (including retries) */
  isExecuting: boolean;
  /** Manual retry: re-execute the last failed command */
  retry: () => Promise<Response | null>;
  /** Clear error state */
  clearError: () => void;
}

export function useRetryableCommand(options: CommandOptions): CommandResult { ... }
```

Implementation:
1. **Deduplication check**: Before executing, call `deduplicationManager.isDuplicate(createRequestKey(device, action))`. If duplicate, return null silently (per Claude's discretion: silent block for dedup).
2. **Idempotency key injection**: Call `idempotencyManager.registerKey(url, JSON.parse(body))` to get key. Add `Idempotency-Key` header to fetch options.
3. **Execute with retryFetch**: Call `retryFetch(url, enhancedOptions)`. The retry client handles transient errors automatically.
4. **On success**: If `hadError` was true (previous attempt failed), show success toast: "Comando eseguito con successo" (only show success toast on recovery, not on first-try success). Clear error state. Clear dedup after completion.
5. **On RetryError (all retries exhausted)**:
   - Check if the error is transient (auto-retry failed) vs persistent (device offline):
     - Transient failure: Show persistent error toast with message from ERROR_MESSAGES + inline "Riprova" button. The button calls `retry()`.
     - Persistent failure (STOVE_OFFLINE, HUE_NOT_CONNECTED, NETATMO_NOT_CONNECTED): Show persistent error toast with "Riprova" button (same UX, but the error was never auto-retried).
   - Store the failed command reference (url + options) in a ref so `retry()` can re-execute.
   - Set `lastError` state.
6. **retry()**: Re-execute the stored command. Clear error state first. This is the "manual retry" path.
7. **clearError()**: Reset lastError, attemptCount, isRetrying states.
8. **Error state**: Expose `lastError` so device cards can show error state with their own retry button (locked decision: retry in BOTH toast AND card).

Create `lib/hooks/__tests__/useRetryableCommand.test.ts`:
- Use `@testing-library/react` `renderHook` to test the hook
- Mock `retryFetch`, `deduplicationManager`, `idempotencyManager`, `useToast`
- Test cases:
  - `execute` calls retryFetch with idempotency header
  - `execute` returns null when dedup blocks the request
  - `execute` shows persistent error toast on failure
  - `execute` shows success toast on recovery (after previous error)
  - `retry` re-executes the last failed command
  - `clearError` resets all error state
  - `isExecuting` is true during command execution
  - `isRetrying` reflects retry state from retryFetch
  </action>
  <verify>Run `npx jest lib/hooks/__tests__/useRetryableCommand.test.ts --no-coverage` — all tests pass</verify>
  <done>useRetryableCommand hook orchestrates retry + toast + dedup + idempotency. Error toasts are persistent with "Riprova" button. Manual retry via retry() method. Error state exposed for device card integration.</done>
</task>

</tasks>

<verification>
```bash
npx jest lib/hooks/__tests__/useRetryableCommand.test.ts app/components/ui/__tests__/Toast.test.tsx --no-coverage --verbose
```
All hook and toast tests pass.
</verification>

<success_criteria>
- Error toasts are persistent (duration: 0) per locked decision
- useRetryableCommand provides execute, retry, clearError, isExecuting, isRetrying, lastError
- Deduplication silently blocks duplicate requests within 2s window
- Idempotency-Key header injected into all device commands
- Persistent error toast shows "Riprova" inline button
- Success toast only shown on recovery from error (not first-try success)
- Manual retry via retry() re-executes last failed command
- Error state (lastError) exposed for device card error banner
</success_criteria>

<output>
After completion, create `.planning/phases/55-retry-infrastructure/55-03-SUMMARY.md`
</output>
