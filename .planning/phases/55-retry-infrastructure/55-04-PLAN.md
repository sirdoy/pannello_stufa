---
phase: 55-retry-infrastructure
plan: 04
type: execute
wave: 2
depends_on: ["55-02"]
files_modified:
  - lib/core/middleware.ts
  - lib/core/index.ts
  - lib/core/__tests__/middleware.test.ts
autonomous: true

must_haves:
  truths:
    - "API routes check Idempotency-Key header and return cached response for duplicate keys"
    - "First request with an idempotency key processes normally and caches the result"
    - "Second request with the same key returns the cached result without re-executing the command"
    - "Requests without Idempotency-Key header process normally (backwards compatible)"
  artifacts:
    - path: "lib/core/middleware.ts"
      provides: "withIdempotency middleware wrapper for API routes"
      exports: ["withIdempotency"]
    - path: "lib/core/index.ts"
      provides: "Re-export withIdempotency from barrel"
      exports: ["withIdempotency"]
    - path: "lib/core/__tests__/middleware.test.ts"
      provides: "Tests for idempotency middleware"
      contains: "withIdempotency"
  key_links:
    - from: "lib/core/middleware.ts"
      to: "lib/retry/idempotencyManager.ts"
      via: "Firebase RTDB check for existing idempotency key results"
      pattern: "idempotency/results"
---

<objective>
Add server-side idempotency checking middleware that verifies Idempotency-Key headers in API routes, returns cached responses for duplicate keys, and stores results for first-time keys.

Purpose: Completes RETRY-04 (idempotency protection) by adding the server-side counterpart to the client-side idempotency key generation from Plan 02. This ensures that even if a request reaches the server twice (retry or network duplicate), the physical action only executes once.

Output: `withIdempotency` middleware ready to be composed with existing `withAuthAndErrorHandler`.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-retry-infrastructure/55-RESEARCH.md

@lib/core/middleware.ts — Existing middleware (withAuthAndErrorHandler, withErrorHandler, etc.)
@lib/core/index.ts — Barrel exports
@lib/core/apiResponse.ts — success() response helper

Read 55-02-SUMMARY.md for idempotency key format and Firebase paths.
@.planning/phases/55-retry-infrastructure/55-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add withIdempotency middleware</name>
  <files>lib/core/middleware.ts, lib/core/index.ts</files>
  <action>
Add a new `withIdempotency` middleware to `lib/core/middleware.ts`:

```typescript
/**
 * Wraps a route handler with idempotency key checking.
 * If Idempotency-Key header is present:
 *   - Checks Firebase RTDB for cached result at `idempotency/results/{key}`
 *   - If found, returns cached result (200) without executing handler
 *   - If not found, executes handler, caches result, returns response
 * If no Idempotency-Key header, executes handler normally (backwards compatible).
 */
export function withIdempotency(handler: AuthedHandler, logContext?: string): AuthedHandler {
  return async (request, context, session) => {
    const idempotencyKey = request.headers.get('Idempotency-Key');

    if (!idempotencyKey) {
      // No key — process normally (backwards compatible)
      return handler(request, context, session);
    }

    // Check for cached result
    const { ref, get, set } = await import('firebase/database');
    const { db } = await import('@/lib/firebase');
    const resultRef = ref(db, `idempotency/results/${idempotencyKey}`);
    const existing = await get(resultRef);

    if (existing.exists()) {
      const cached = existing.val();
      // Return cached result
      return NextResponse.json(cached.data, { status: cached.status });
    }

    // Execute handler
    const response = await handler(request, context, session);

    // Cache result (only for successful responses)
    if (response.ok) {
      try {
        const cloned = response.clone();
        const data = await cloned.json();
        await set(resultRef, {
          data,
          status: response.status,
          timestamp: Date.now(),
          expiresAt: Date.now() + 60 * 60 * 1000, // 1 hour TTL (matches client)
        });
      } catch {
        // Cache failure should not break the response
        console.warn(`[Idempotency] Failed to cache result for key ${idempotencyKey}`);
      }
    }

    return response;
  };
}
```

Key implementation details:
- Use dynamic imports for Firebase to avoid importing in routes that don't use idempotency
- Only cache successful responses (2xx) — errors should be retried
- TTL matches client-side (1 hour)
- Cache failure is fire-and-forget (warn, don't throw)
- Backwards compatible: no Idempotency-Key header = normal processing

Update `lib/core/index.ts` to re-export `withIdempotency`:
```typescript
export {
  withErrorHandler,
  withAuthAndErrorHandler,
  withCronSecret,
  withHueHandler,
  withIdempotency,  // NEW
} from './middleware';
```

Note: Do NOT apply withIdempotency to routes yet — Plan 05 handles integration. This plan just creates the middleware.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit lib/core/middleware.ts` (or run existing tests)</verify>
  <done>withIdempotency middleware created, exported from lib/core barrel. Checks Idempotency-Key header, caches successful results in Firebase RTDB, returns cached results for duplicate keys.</done>
</task>

<task type="auto">
  <name>Task 2: Add middleware tests for withIdempotency</name>
  <files>lib/core/__tests__/middleware.test.ts</files>
  <action>
Add tests for `withIdempotency` to the existing `lib/core/__tests__/middleware.test.ts` test file (or create it if it doesn't exist).

Mock `firebase/database` (ref, get, set) and `@/lib/firebase` (db).

Test cases in a `describe('withIdempotency', ...)` block:
1. **No header**: Handler executes normally when no Idempotency-Key header present
2. **First request with key**: Handler executes, result is cached in Firebase at `idempotency/results/{key}`
3. **Duplicate request with key**: Returns cached result WITHOUT executing handler again
4. **Cache failure**: Handler still returns response even if Firebase cache write fails
5. **Error response not cached**: Handler returning 4xx/5xx does NOT cache the result
6. **Different keys**: Two different idempotency keys execute the handler independently

Create mock NextRequest with headers:
```typescript
const mockRequest = new NextRequest('http://localhost/api/test', {
  method: 'POST',
  headers: { 'Idempotency-Key': 'test-key-123' },
});
```

Use `jest.fn()` for the wrapped handler to verify it's called (or not called for duplicates).
  </action>
  <verify>Run `npx jest lib/core/__tests__/middleware.test.ts --no-coverage` — all tests pass</verify>
  <done>withIdempotency middleware tested: processes first request, returns cached for duplicate, handles missing header, handles cache failures gracefully.</done>
</task>

</tasks>

<verification>
```bash
npx jest lib/core/__tests__/middleware.test.ts --no-coverage --verbose
```
All middleware tests pass including new withIdempotency tests.
</verification>

<success_criteria>
- withIdempotency middleware exported from lib/core
- First request with Idempotency-Key executes handler and caches result
- Second request with same key returns cached result (handler NOT re-executed)
- No Idempotency-Key header = normal processing (backwards compatible)
- Only successful responses (2xx) are cached
- Cache failure is non-blocking (fire-and-forget)
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/55-retry-infrastructure/55-04-SUMMARY.md`
</output>
