---
phase: 55-retry-infrastructure
plan: 05
type: execute
wave: 3
depends_on: ["55-03", "55-04"]
files_modified:
  - app/components/devices/stove/StoveCard.tsx
  - app/components/devices/lights/LightsCard.tsx
  - app/components/devices/thermostat/ThermostatCard.tsx
  - app/api/stove/ignite/route.ts
  - app/api/stove/shutdown/route.ts
  - app/api/stove/fan/route.ts
  - app/api/stove/power/route.ts
  - app/api/hue/rooms/[id]/route.ts
  - app/api/hue/scenes/[id]/activate/route.ts
autonomous: false

must_haves:
  truths:
    - "User sees persistent toast notification when device command fails with network error"
    - "Transient network errors auto-retry up to 3 times without user intervention"
    - "Device-offline errors show persistent toast with manual Riprova button"
    - "Retry button appears in BOTH the error toast AND on the device card"
    - "Stove ignite/shutdown commands send Idempotency-Key header"
    - "Double-tap on any command button is silently blocked for 2 seconds"
    - "API routes check Idempotency-Key and return cached result for duplicates"
  artifacts:
    - path: "app/components/devices/stove/StoveCard.tsx"
      provides: "StoveCard with retry infrastructure integration"
      contains: "useRetryableCommand"
    - path: "app/components/devices/lights/LightsCard.tsx"
      provides: "LightsCard with retry infrastructure integration"
      contains: "useRetryableCommand"
    - path: "app/components/devices/thermostat/ThermostatCard.tsx"
      provides: "ThermostatCard with retry infrastructure integration"
      contains: "useRetryableCommand"
    - path: "app/api/stove/ignite/route.ts"
      provides: "Stove ignite route with idempotency middleware"
      contains: "withIdempotency"
  key_links:
    - from: "app/components/devices/stove/StoveCard.tsx"
      to: "lib/hooks/useRetryableCommand.ts"
      via: "useRetryableCommand hook for all device commands"
      pattern: "import.*useRetryableCommand"
    - from: "app/api/stove/ignite/route.ts"
      to: "lib/core/middleware.ts"
      via: "withIdempotency middleware wrapper"
      pattern: "withIdempotency"
---

<objective>
Integrate the retry infrastructure into device cards and API routes, connecting all the pieces built in Plans 01-04.

Purpose: This plan delivers the user-facing behavior for ALL requirements (RETRY-01 through RETRY-06). Device cards use `useRetryableCommand` for all command operations, API routes use `withIdempotency` middleware, and the user sees persistent error toasts with retry buttons on both toasts and cards.

Output: Fully integrated retry infrastructure across all device types with visual verification.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/55-retry-infrastructure/55-RESEARCH.md

@app/components/devices/stove/StoveCard.tsx — Stove card with manual fetch calls to refactor
@app/components/devices/lights/LightsCard.tsx — Lights card with manual fetch calls
@app/components/devices/thermostat/ThermostatCard.tsx — Thermostat card with manual fetch calls
@app/api/stove/ignite/route.ts — Example API route to wrap with idempotency
@lib/core/middleware.ts — withIdempotency middleware

Read all prior plan summaries for this phase:
@.planning/phases/55-retry-infrastructure/55-01-SUMMARY.md
@.planning/phases/55-retry-infrastructure/55-02-SUMMARY.md
@.planning/phases/55-retry-infrastructure/55-03-SUMMARY.md
@.planning/phases/55-retry-infrastructure/55-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate useRetryableCommand into StoveCard</name>
  <files>app/components/devices/stove/StoveCard.tsx</files>
  <action>
Refactor `StoveCard.tsx` to use `useRetryableCommand` for all device command operations.

**Import:**
```typescript
import { useRetryableCommand } from '@/lib/hooks/useRetryableCommand';
```

**Replace command handlers**: For each command (ignite, shutdown, setFan, setPower), replace the manual fetch+AbortController pattern with `useRetryableCommand`:

```typescript
// Create one hook instance per command type
const igniteCmd = useRetryableCommand({ device: 'stove', action: 'ignite' });
const shutdownCmd = useRetryableCommand({ device: 'stove', action: 'shutdown' });
const setFanCmd = useRetryableCommand({ device: 'stove', action: 'setFan' });
const setPowerCmd = useRetryableCommand({ device: 'stove', action: 'setPower' });
```

**Refactor handleIgnite:**
```typescript
const handleIgnite = async () => {
  setLoadingMessage('Accensione stufa...');
  setLoading(true);
  try {
    const response = await igniteCmd.execute(STOVE_ROUTES.ignite, {
      method: 'POST',
      body: JSON.stringify({ source: 'manual' }),
    });
    if (response) {
      await logStoveAction.ignite();
      await fetchStatusAndUpdate();
    }
    // If response is null, request was deduplicated (silently blocked)
  } finally {
    setLoading(false);
  }
};
```

Apply the same pattern for `handleShutdown`, `handleFanChange`, `handlePowerChange`.

**Remove old abort controller pattern**: Delete the `new AbortController()`, `setTimeout(() => controller.abort(), 10000)`, and the manual AbortError catch blocks from each handler. The retry client handles timeouts and error classification.

**Add error state banner**: Near the top of the card (below the existing `CronHealthBanner` and `MaintenanceBar`), add an error banner when any command has an error:

```tsx
{(igniteCmd.lastError || shutdownCmd.lastError || setFanCmd.lastError || setPowerCmd.lastError) && (
  <Banner variant="error">
    <div className="flex items-center justify-between w-full">
      <Text variant="small">
        {(igniteCmd.lastError || shutdownCmd.lastError || setFanCmd.lastError || setPowerCmd.lastError)?.message}
      </Text>
      <Button
        variant="ghost"
        size="sm"
        onClick={() => {
          // Retry the failed command
          const failedCmd = [igniteCmd, shutdownCmd, setFanCmd, setPowerCmd]
            .find(cmd => cmd.lastError);
          failedCmd?.retry();
        }}
      >
        Riprova
      </Button>
    </div>
  </Banner>
)}
```

**Disable buttons during execution**: Use `isExecuting` from the hook to disable buttons during retry:
```tsx
disabled={!isOnline || igniteCmd.isExecuting || loading}
```

**Keep existing offline behavior**: The `useBackgroundSync` / `useOnlineStatus` hooks remain unchanged. Offline queueing (Phase 53) is separate from retry. When `isOnline` is false, buttons are already disabled — no conflict with retry.

**Remove old local toast state**: The component currently has `const [toast, setToast] = useState(null)` for local toast. Replace all manual `setToast({ message, variant })` calls with the hook's built-in toast (via `useRetryableCommand`). Remove the local toast state and the local `<Toast>` component render at the bottom of the card — useRetryableCommand uses the global ToastProvider.
  </action>
  <verify>No TypeScript errors: `npx tsc --noEmit` (or component renders without crash in dev)</verify>
  <done>StoveCard uses useRetryableCommand for ignite, shutdown, setFan, setPower. Error banner with "Riprova" button shows on failed commands. Deduplication prevents double-tap. Idempotency-Key header sent with all commands.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate useRetryableCommand into LightsCard and ThermostatCard</name>
  <files>app/components/devices/lights/LightsCard.tsx, app/components/devices/thermostat/ThermostatCard.tsx</files>
  <action>
Apply the same pattern from Task 1 to LightsCard and ThermostatCard.

**LightsCard** — Identify all fetch calls for device commands (NOT status reads):
- Room brightness/on-off: `fetch(\`/api/hue/rooms/${roomId}\`, { method: 'PUT' ... })`
- Scene activation: `fetch(\`/api/hue/scenes/${sceneId}/activate\`, { method: 'POST' ... })`
- Multi-room operations

For each, create a useRetryableCommand instance. Since room/scene IDs vary, use a general hook:
```typescript
const hueCmd = useRetryableCommand({ device: 'hue', action: 'control' });
```

For unique deduplication per operation, pass specific action names:
```typescript
// In the handler, create action-specific dedup:
const response = await hueCmd.execute(`/api/hue/rooms/${roomId}`, { ... });
```

Actually, better approach: create ONE hook per command type and pass the specific action dynamically. But `useRetryableCommand` is called at component top-level (hooks rules). So use a single hook with a generic action, and the dedup key will include the URL which makes it unique per room/scene:

```typescript
const hueRoomCmd = useRetryableCommand({ device: 'hue', action: 'room' });
const hueSceneCmd = useRetryableCommand({ device: 'hue', action: 'scene' });
```

Add error banner same as StoveCard. Remove manual error handling/abort controllers.

**ThermostatCard** — Identify command fetch calls:
- Set therm mode: `fetch(NETATMO_ROUTES.setThermMode, { method: 'POST' ... })`
- Set room thermpoint: `fetch(NETATMO_ROUTES.setRoomThermpoint, { method: 'POST' ... })`
- Calibrate: `fetch(NETATMO_ROUTES.calibrate, { method: 'POST' ... })`
- Switch schedule: `fetch(NETATMO_ROUTES.schedules, { method: 'POST' ... })`

```typescript
const netatmoModeCmd = useRetryableCommand({ device: 'netatmo', action: 'setMode' });
const netatmoTempCmd = useRetryableCommand({ device: 'netatmo', action: 'setTemp' });
const netatmoCalibrateCmd = useRetryableCommand({ device: 'netatmo', action: 'calibrate' });
const netatmoScheduleCmd = useRetryableCommand({ device: 'netatmo', action: 'setSchedule' });
```

Add error banner same as StoveCard. Remove manual error handling.

**Important**: Do NOT wrap status/read fetch calls (GET requests for status polling) with retry. Only wrap command/mutation fetch calls (POST/PUT). Status reads are handled by existing polling logic and offline staleness indicators.
  </action>
  <verify>No TypeScript errors in changed files. Run `npx tsc --noEmit` to verify.</verify>
  <done>LightsCard and ThermostatCard use useRetryableCommand for all device commands. Error banners with "Riprova" button added. Deduplication and idempotency active on all command operations.</done>
</task>

<task type="auto">
  <name>Task 3: Apply withIdempotency to critical API routes</name>
  <files>app/api/stove/ignite/route.ts, app/api/stove/shutdown/route.ts, app/api/stove/fan/route.ts, app/api/stove/power/route.ts, app/api/hue/rooms/[id]/route.ts, app/api/hue/scenes/[id]/activate/route.ts</files>
  <action>
Wrap device command API routes with `withIdempotency` middleware.

**Pattern** — Compose withIdempotency inside withAuthAndErrorHandler:

For `app/api/stove/ignite/route.ts`:
```typescript
import { withAuthAndErrorHandler, withIdempotency, success, parseJson } from '@/lib/core';

export const POST = withAuthAndErrorHandler(
  withIdempotency(async (request, context, session) => {
    const body = await parseJson(request);
    const { power, source } = validateIgniteInput(body);
    const stoveService = getStoveService();
    const result = await stoveService.ignite(power, source);
    // ... analytics ...
    return success(result as Record<string, unknown>);
  }),
  'Stove/Ignite'
);
```

Apply the same pattern to:
- `app/api/stove/shutdown/route.ts` — POST handler
- `app/api/stove/fan/route.ts` — POST handler (setFan)
- `app/api/stove/power/route.ts` — POST handler (setPower)
- `app/api/hue/rooms/[id]/route.ts` — PUT handler (room control)
- `app/api/hue/scenes/[id]/activate/route.ts` — POST handler (scene activation)

**For Netatmo routes**: Check if they exist at similar paths and apply the same pattern. Netatmo commands are also device commands that need idempotency per locked decision.

**Do NOT apply to**:
- GET routes (status reads — no side effects)
- Scheduler/cron routes (internal, not user-initiated)
- Auth routes
- Health check routes

**Verify middleware composition works**: The `withIdempotency` middleware receives the already-authenticated handler (inside `withAuthAndErrorHandler`), so session is available. If `withIdempotency` needs to check the key before auth, adjust composition order — but idempotency check AFTER auth is correct (we don't want to cache unauthenticated requests).
  </action>
  <verify>No TypeScript errors in changed route files. Run `npx tsc --noEmit` to verify.</verify>
  <done>Critical device command API routes wrapped with withIdempotency. Duplicate requests with same Idempotency-Key return cached response. Normal requests without the header process as before.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 4: Visual verification of retry infrastructure</name>
  <files>app/components/devices/stove/StoveCard.tsx, app/components/devices/lights/LightsCard.tsx, app/components/devices/thermostat/ThermostatCard.tsx</files>
  <action>
User verifies the complete retry infrastructure across all device cards. All code is already implemented in Tasks 1-3 — this is purely visual/functional verification.

What was built:
- Persistent error toasts with "Riprova" button (all device types)
- Auto-retry on transient network errors (up to 3 times)
- Manual retry button on device card error banner AND in toast
- Double-tap deduplication (2-second window)
- Idempotency keys sent with all device commands
- Server-side idempotency checking on critical API routes

How to verify:
1. Start dev server: `npm run dev`
2. Open http://localhost:3000

Test error toast (RETRY-01):
- Open browser DevTools > Network tab
- Throttle to "Offline" mode
- Try to ignite stove or change a light setting
- Verify: Persistent error toast appears with "Riprova" button
- Verify: Toast does NOT auto-dismiss (stays until you tap X or Riprova)

Test auto-retry (RETRY-02):
- In DevTools, set "3G" throttle (slow, not offline)
- The stove command may timeout and auto-retry
- Check console for retry attempt logs (if visible)

Test device card error state (RETRY-03):
- With "Offline" throttle still active, try a command
- Verify: Device card shows error banner with "Riprova" button
- Switch back to "Online"
- Click "Riprova" on the card
- Verify: Command retries and error clears on success

Test deduplication (RETRY-05):
- Rapidly double-click any command button (ignite, light toggle)
- Verify: Only ONE request appears in Network tab (second click silently blocked)

Test toast + card dual retry (locked decision):
- Trigger an error (go offline, try command)
- Verify: BOTH the toast has a "Riprova" button AND the card shows error with "Riprova"
  </action>
  <verify>User confirms all retry behaviors work as expected</verify>
  <done>User types "approved" confirming all RETRY requirements verified visually.</done>
</task>

</tasks>

<verification>
```bash
# TypeScript compilation check
npx tsc --noEmit

# Run all retry-related tests
npx jest lib/retry/ lib/hooks/__tests__/useRetryableCommand lib/core/__tests__/middleware --no-coverage --verbose
```
All tests pass. No TypeScript errors.
</verification>

<success_criteria>
- RETRY-01: User sees persistent toast notification when device command fails
- RETRY-02: Transient network errors auto-retry up to 3 times with exponential backoff
- RETRY-03: Device-offline errors show persistent toast + card banner with manual "Riprova" button
- RETRY-04: All device commands send Idempotency-Key header; API routes return cached results for duplicates
- RETRY-05: Double-tap blocked within 2-second deduplication window
- RETRY-06: Single retry layer via useRetryableCommand hook (no retry in both hook AND component)
- Error toasts are persistent (locked decision)
- Retry button in both toast and card (locked decision)
- Idempotency covers ALL device commands (locked decision)
</success_criteria>

<output>
After completion, create `.planning/phases/55-retry-infrastructure/55-05-SUMMARY.md`
</output>
