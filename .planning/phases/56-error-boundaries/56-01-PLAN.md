---
phase: 56-error-boundaries
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/errors/ValidationError.ts
  - lib/errors/index.ts
  - lib/analyticsEventLogger.ts
  - types/analytics.ts
  - app/api/analytics/error/route.ts
  - app/error.tsx
  - lib/__tests__/ValidationError.test.ts
  - lib/__tests__/analyticsErrorLogger.test.ts
autonomous: true

must_haves:
  truths:
    - "ValidationError instances bypass error boundaries (instanceof check works)"
    - "Component errors are logged to Firebase Analytics via fire-and-forget API route"
    - "Global unhandled errors show fallback UI with 'Riprova' button at route level"
    - "ValidationError.maintenanceRequired() creates correctly typed error with MAINTENANCE_REQUIRED code"
  artifacts:
    - path: "lib/errors/ValidationError.ts"
      provides: "Custom error class that bypasses error boundaries"
      contains: "class ValidationError extends Error"
    - path: "lib/errors/index.ts"
      provides: "Barrel export for errors"
      exports: ["ValidationError"]
    - path: "app/api/analytics/error/route.ts"
      provides: "Client-side error logging API endpoint"
      exports: ["POST"]
    - path: "app/error.tsx"
      provides: "Next.js global route-level error boundary"
      contains: "'use client'"
    - path: "lib/__tests__/ValidationError.test.ts"
      provides: "Unit tests for ValidationError class"
  key_links:
    - from: "app/error.tsx"
      to: "/api/analytics/error"
      via: "fire-and-forget fetch POST"
      pattern: "fetch.*api/analytics/error"
    - from: "app/api/analytics/error/route.ts"
      to: "lib/analyticsEventLogger.ts"
      via: "logComponentError function"
      pattern: "logComponentError"
---

<objective>
Create the foundation layer for Phase 56 error boundaries: ValidationError custom class that bypasses error boundaries for safety alerts, extend analytics event logger with component error logging, create a client-accessible API route for error reporting, and implement the Next.js global error.tsx fallback.

Purpose: Establish the error classification (ValidationError vs runtime error) and logging infrastructure that feature-level error boundaries will depend on, plus the global route-level error fallback.

Output: ValidationError class, error logging API route, global error.tsx, and unit tests.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/56-error-boundaries/56-RESEARCH.md

@lib/analyticsEventLogger.ts
@lib/core/apiErrors.ts
@types/analytics.ts
@app/components/ui/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ValidationError class and error analytics infrastructure</name>
  <files>
    lib/errors/ValidationError.ts
    lib/errors/index.ts
    lib/analyticsEventLogger.ts
    types/analytics.ts
    app/api/analytics/error/route.ts
  </files>
  <action>
    **ValidationError class** (`lib/errors/ValidationError.ts`):
    - Create class extending Error with `code: string` and `details?: Record<string, unknown>` properties
    - Set `this.name = 'ValidationError'` in constructor
    - Use `Error.captureStackTrace` if available (V8 engines)
    - Add static factory: `ValidationError.maintenanceRequired(details?)` returning instance with code `MAINTENANCE_REQUIRED` and Italian message "Manutenzione richiesta - Conferma la pulizia prima di accendere"
    - Export from barrel `lib/errors/index.ts`

    **Extend AnalyticsEventType** (`types/analytics.ts`):
    - Add `'component_error'` to the AnalyticsEventType union: `'stove_ignite' | 'stove_shutdown' | 'power_change' | 'component_error'`
    - Add optional fields to AnalyticsEvent interface: `component?: string`, `errorMessage?: string`, `errorStack?: string`, `device?: string`

    **Extend analyticsEventLogger** (`lib/analyticsEventLogger.ts`):
    - Add new function `logComponentError(params: { device?: string; component: string; message: string; stack?: string; })`: Promise<void>
    - Implementation: call existing `logAnalyticsEvent` with `eventType: 'component_error'`, `source: 'error_boundary'` (add `'error_boundary'` to AnalyticsEventSource in types/analytics.ts)
    - Follow existing fire-and-forget pattern (try/catch, console.error on failure, never throw)

    **Error logging API route** (`app/api/analytics/error/route.ts`):
    - Create POST endpoint with `export const dynamic = 'force-dynamic'`
    - Accept JSON body: `{ device?: string; component: string; message: string; stack?: string; digest?: string }`
    - Validate required field `component` and `message` (return 400 if missing)
    - Call `logComponentError` from analyticsEventLogger
    - Return 200 `{ success: true }` on success
    - Fire-and-forget: do NOT check analytics consent for error logging (error logging is operational, not analytics tracking per GDPR)
    - Import from `@/lib/analyticsEventLogger`
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no type errors. Check that `lib/errors/ValidationError.ts`, `lib/errors/index.ts`, `app/api/analytics/error/route.ts` exist and export correctly.
  </verify>
  <done>
    ValidationError class exists with instanceof support and static factory. AnalyticsEventType includes 'component_error'. logComponentError function exists in analyticsEventLogger. API route at /api/analytics/error accepts POST requests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create global error.tsx and unit tests</name>
  <files>
    app/error.tsx
    lib/__tests__/ValidationError.test.ts
    lib/__tests__/analyticsErrorLogger.test.ts
  </files>
  <action>
    **Global error.tsx** (`app/error.tsx`):
    - Must have `'use client'` directive at top
    - Default export function `Error` accepting `{ error: Error & { digest?: string }; reset: () => void }`
    - Use `useEffect` to log error via fire-and-forget fetch to `/api/analytics/error` with `component: 'global'`, `message: error.message`, `stack: error.stack`, `digest: error.digest`. Use `.catch(() => {})` to suppress fetch failures.
    - Render centered fullscreen fallback with Ember Noir styling:
      - Use design system components: import `{ Button, Heading, Text }` from `@/app/components/ui`
      - Dark background: `bg-slate-950` (consistent with app theme)
      - Heading level={2} variant="ember": "Qualcosa e andato storto" (no accented characters in source to avoid encoding issues - use plain text)
      - Text variant="secondary": show `error.message` or fallback "Si e verificato un errore inaspettato"
      - Button variant="ember" onClick={() => reset()}: "Riprova"
    - Layout: `flex min-h-screen items-center justify-center p-4`, inner `max-w-md text-center`

    **ValidationError tests** (`lib/__tests__/ValidationError.test.ts`):
    - Test: constructor sets name, message, code, details correctly
    - Test: `instanceof ValidationError` returns true
    - Test: `instanceof Error` returns true (prototype chain)
    - Test: `ValidationError.maintenanceRequired()` creates correct instance with code 'MAINTENANCE_REQUIRED'
    - Test: `ValidationError.maintenanceRequired({ lastCleaning: '2026-02-01' })` passes details through
    - Test: default code is 'VALIDATION_ERROR'

    **Error logger tests** (`lib/__tests__/analyticsErrorLogger.test.ts`):
    - Mock `logAnalyticsEvent` from `@/lib/analyticsEventLogger`
    - Test: `logComponentError` calls `logAnalyticsEvent` with eventType 'component_error' and source 'error_boundary'
    - Test: `logComponentError` passes device, component, message fields
    - Test: `logComponentError` does not throw when `logAnalyticsEvent` rejects (fire-and-forget)
  </action>
  <verify>
    Run `npx jest lib/__tests__/ValidationError.test.ts lib/__tests__/analyticsErrorLogger.test.ts --no-coverage` — all tests pass. Run `npx tsc --noEmit` — no type errors. Verify `app/error.tsx` exists with 'use client' directive.
  </verify>
  <done>
    Global error.tsx renders Ember Noir fallback with Riprova button and logs errors via fire-and-forget. ValidationError has 6+ passing unit tests. logComponentError has 3+ passing unit tests.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx jest lib/__tests__/ValidationError.test.ts lib/__tests__/analyticsErrorLogger.test.ts --no-coverage` — all tests green
3. `lib/errors/ValidationError.ts` exports ValidationError class
4. `app/error.tsx` has `'use client'` directive and renders fallback UI
5. `app/api/analytics/error/route.ts` exports POST handler
6. AnalyticsEventType union includes 'component_error'
</verification>

<success_criteria>
- ValidationError class works with instanceof checks and has static factory methods
- logComponentError function logs component errors as fire-and-forget analytics events
- /api/analytics/error API route accepts POST with component error details
- Global error.tsx catches unhandled route-level errors with Ember Noir fallback UI
- All unit tests pass
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/56-error-boundaries/56-01-SUMMARY.md`
</output>
