---
phase: 56-error-boundaries
plan: 02
type: execute
wave: 2
depends_on: ["56-01"]
files_modified:
  - app/components/ErrorBoundary/ErrorFallback.tsx
  - app/components/ErrorBoundary/DeviceCardErrorBoundary.tsx
  - app/components/ErrorBoundary/index.ts
  - app/page.tsx
  - __tests__/components/ErrorBoundary/DeviceCardErrorBoundary.test.tsx
  - __tests__/components/ErrorBoundary/ErrorFallback.test.tsx
autonomous: true

must_haves:
  truths:
    - "Unhandled error in StoveCard displays ErrorFallback UI without crashing other device cards"
    - "Unhandled error in LightsCard displays ErrorFallback UI without crashing other device cards"
    - "ErrorFallback shows device name, icon, error message, and 'Riprova' button"
    - "Clicking 'Riprova' resets error boundary and re-mounts the crashed component"
    - "ValidationError in a device card re-throws (bypasses boundary) so safety alerts show properly"
    - "Device card errors are logged to /api/analytics/error via fire-and-forget fetch"
    - "Each device card on homepage is independently wrapped in DeviceCardErrorBoundary"
  artifacts:
    - path: "app/components/ErrorBoundary/ErrorFallback.tsx"
      provides: "Reusable error fallback UI with Ember Noir styling"
      contains: "'use client'"
    - path: "app/components/ErrorBoundary/DeviceCardErrorBoundary.tsx"
      provides: "Feature-level error boundary wrapper using react-error-boundary"
      contains: "ErrorBoundary"
    - path: "app/components/ErrorBoundary/index.ts"
      provides: "Barrel exports for error boundary components"
      exports: ["DeviceCardErrorBoundary", "ErrorFallback"]
    - path: "app/page.tsx"
      provides: "Homepage with device cards wrapped in error boundaries"
      contains: "DeviceCardErrorBoundary"
    - path: "__tests__/components/ErrorBoundary/DeviceCardErrorBoundary.test.tsx"
      provides: "Tests for error boundary crash isolation, reset, and ValidationError bypass"
    - path: "__tests__/components/ErrorBoundary/ErrorFallback.test.tsx"
      provides: "Tests for fallback UI rendering"
  key_links:
    - from: "app/components/ErrorBoundary/DeviceCardErrorBoundary.tsx"
      to: "lib/errors/ValidationError.ts"
      via: "instanceof check in onError"
      pattern: "instanceof ValidationError"
    - from: "app/components/ErrorBoundary/DeviceCardErrorBoundary.tsx"
      to: "/api/analytics/error"
      via: "fire-and-forget fetch in onError"
      pattern: "fetch.*api/analytics/error"
    - from: "app/page.tsx"
      to: "app/components/ErrorBoundary/DeviceCardErrorBoundary.tsx"
      via: "wrapping each device card"
      pattern: "DeviceCardErrorBoundary"
---

<objective>
Create feature-level error boundary components using react-error-boundary library and integrate them into the homepage to isolate device card crashes. Each device card (StoveCard, LightsCard, ThermostatCard, CameraCard, WeatherCardWrapper) gets independently wrapped so one crash does not affect others.

Purpose: Achieve crash isolation per device card with user-friendly fallback UI, automatic error logging, and one-click recovery.

Output: ErrorFallback component, DeviceCardErrorBoundary wrapper, homepage integration, unit tests.

**PREREQUISITE:** `react-error-boundary` must be installed before this plan executes. Run `npm install react-error-boundary` first.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/56-error-boundaries/56-RESEARCH.md
@.planning/phases/56-error-boundaries/56-01-SUMMARY.md

@app/page.tsx
@app/components/ui/index.ts
@lib/errors/ValidationError.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorFallback and DeviceCardErrorBoundary components</name>
  <files>
    app/components/ErrorBoundary/ErrorFallback.tsx
    app/components/ErrorBoundary/DeviceCardErrorBoundary.tsx
    app/components/ErrorBoundary/index.ts
  </files>
  <action>
    **ErrorFallback component** (`app/components/ErrorBoundary/ErrorFallback.tsx`):
    - `'use client'` directive at top
    - Import `FallbackProps` from `react-error-boundary`
    - Import `{ Card, Button, Heading, Text }` from `@/app/components/ui`
    - Interface `ErrorFallbackProps extends FallbackProps` with `deviceName: string` and `deviceIcon: string`
    - Render Card variant="elevated" with centered content:
      - Device icon (text-4xl mb-4)
      - Heading level={3} variant="ember": "Errore: {deviceName}"
      - Text variant="secondary": show `error.message` or fallback "Si e verificato un errore imprevisto"
      - Button variant="ember" onClick={resetErrorBoundary}: "Riprova"
    - Use `space-y-4` for vertical spacing within the card
    - Ensure the card visually matches the size of other device cards (p-6 padding)

    **DeviceCardErrorBoundary component** (`app/components/ErrorBoundary/DeviceCardErrorBoundary.tsx`):
    - `'use client'` directive at top
    - Import `{ ErrorBoundary }` from `react-error-boundary`
    - Import `{ ValidationError }` from `@/lib/errors`
    - Import `ErrorFallback` from `./ErrorFallback`
    - Props interface: `{ children: React.ReactNode; deviceName: string; deviceIcon: string }`
    - In `onError` handler:
      1. Check `if (error instanceof ValidationError)` and re-throw it (let it bubble up past boundary for proper safety alert UI)
      2. For all other errors: fire-and-forget fetch POST to `/api/analytics/error` with body `{ device: deviceName, component: 'DeviceCard', message: error.message, stack: error.stack }`. Use `.catch(() => {})`.
    - Render `<ErrorBoundary>` wrapping `{children}` with:
      - `FallbackComponent` prop: render `<ErrorFallback {...props} deviceName={deviceName} deviceIcon={deviceIcon} />`
      - `onError` prop: the handler above
    - Default export the component

    **Barrel export** (`app/components/ErrorBoundary/index.ts`):
    - Export `DeviceCardErrorBoundary` (default from file) and `ErrorFallback` (default from file)
    - Pattern: `export { default as DeviceCardErrorBoundary } from './DeviceCardErrorBoundary'` and same for ErrorFallback
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no type errors. Verify files exist: `app/components/ErrorBoundary/ErrorFallback.tsx`, `app/components/ErrorBoundary/DeviceCardErrorBoundary.tsx`, `app/components/ErrorBoundary/index.ts`.
  </verify>
  <done>
    ErrorFallback renders Ember Noir fallback card with device name, icon, error message, and Riprova button. DeviceCardErrorBoundary wraps children with react-error-boundary, re-throws ValidationError, and logs other errors via fire-and-forget.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wrap homepage device cards and write tests</name>
  <files>
    app/page.tsx
    __tests__/components/ErrorBoundary/DeviceCardErrorBoundary.test.tsx
    __tests__/components/ErrorBoundary/ErrorFallback.test.tsx
  </files>
  <action>
    **Homepage integration** (`app/page.tsx`):
    - Import `{ DeviceCardErrorBoundary }` from `./components/ErrorBoundary`
    - Create a device metadata map for icon/name lookup (used by error boundary):
      ```typescript
      const DEVICE_META: Record<string, { name: string; icon: string }> = {
        stove: { name: 'Stufa', icon: 'üî•' },
        thermostat: { name: 'Termostato', icon: 'üå°Ô∏è' },
        weather: { name: 'Meteo', icon: '‚òÄÔ∏è' },
        lights: { name: 'Luci', icon: 'üí°' },
        camera: { name: 'Camera', icon: 'üì∑' },
      };
      ```
    - In the `.map()` render loop, wrap each `<CardComponent />` with `<DeviceCardErrorBoundary>`:
      ```tsx
      <div key={card.id} className="animate-spring-in" style={{ animationDelay: `${index * 100}ms` }}>
        <DeviceCardErrorBoundary
          deviceName={DEVICE_META[card.id]?.name ?? card.id}
          deviceIcon={DEVICE_META[card.id]?.icon ?? '‚ö†Ô∏è'}
        >
          <CardComponent />
        </DeviceCardErrorBoundary>
      </div>
      ```
    - Keep existing Grid wrapper, EmptyState, and SandboxPanel unchanged
    - Note: page.tsx is a Server Component but DeviceCardErrorBoundary is 'use client' - this is fine, Server Components can render Client Components as children

    **ErrorFallback tests** (`__tests__/components/ErrorBoundary/ErrorFallback.test.tsx`):
    - Mock `@/app/components/ui` exports (Card, Button, Heading, Text) as simple div/button wrappers
    - Test: renders device name in heading (e.g., "Errore: Stufa")
    - Test: renders device icon
    - Test: renders error message from error prop
    - Test: renders "Riprova" button
    - Test: calls resetErrorBoundary when Riprova button is clicked
    - Test: shows fallback message when error has no message

    **DeviceCardErrorBoundary tests** (`__tests__/components/ErrorBoundary/DeviceCardErrorBoundary.test.tsx`):
    - Mock `react-error-boundary` or use it directly (prefer direct use for integration accuracy)
    - Mock `@/lib/errors` to provide ValidationError
    - Mock global `fetch` for analytics assertions
    - Create a test component `BrokenComponent` that throws Error on render
    - Create a test component `ValidationBrokenComponent` that throws ValidationError on render
    - Test: renders children when no error occurs
    - Test: shows ErrorFallback when child throws Error (crash isolation)
    - Test: does NOT show ErrorFallback when child throws ValidationError (re-thrown, bypasses boundary)
    - Test: calls fetch to /api/analytics/error when error is caught (fire-and-forget logging)
    - Test: fetch body includes device name and error message
    - Test: clicking "Riprova" resets boundary and re-renders children
    - Suppress console.error in tests (error boundaries log to console)

    Important: For the ValidationError bypass test, wrap the test in a parent error boundary to catch the re-thrown error, or use `jest.spyOn(console, 'error')` and expect the error to propagate.
  </action>
  <verify>
    Run `npx tsc --noEmit` ‚Äî zero errors. Run `npx jest __tests__/components/ErrorBoundary/ --no-coverage` ‚Äî all tests pass. Verify app/page.tsx imports DeviceCardErrorBoundary and wraps each device card.
  </verify>
  <done>
    Homepage wraps each device card (stove, thermostat, weather, lights, camera) with DeviceCardErrorBoundary providing device-specific name and icon. ErrorFallback has 6+ tests passing. DeviceCardErrorBoundary has 6+ tests passing including crash isolation, ValidationError bypass, analytics logging, and reset functionality.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx jest __tests__/components/ErrorBoundary/ --no-coverage` ‚Äî all tests green
3. `app/page.tsx` wraps each device card in `<DeviceCardErrorBoundary>` with correct deviceName and deviceIcon
4. Crash in one device card does not crash other cards (verified via tests)
5. ValidationError bypasses error boundary (verified via tests)
6. Error logging via fetch to /api/analytics/error (verified via tests)
7. Riprova button resets boundary (verified via tests)
</verification>

<success_criteria>
- ErrorFallback displays device-specific Ember Noir fallback UI with Riprova button
- DeviceCardErrorBoundary isolates crashes per device card, re-throws ValidationError, logs errors
- Homepage wraps all 5 device card types with independent error boundaries
- 12+ unit tests passing across ErrorFallback and DeviceCardErrorBoundary test files
- Zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/56-error-boundaries/56-02-SUMMARY.md`
</output>
