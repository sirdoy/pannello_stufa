---
phase: 57-adaptive-polling
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/hooks/useVisibility.ts
  - lib/hooks/useNetworkQuality.ts
  - lib/hooks/useAdaptivePolling.ts
  - lib/hooks/__tests__/useVisibility.test.ts
  - lib/hooks/__tests__/useNetworkQuality.test.ts
  - lib/hooks/__tests__/useAdaptivePolling.test.ts
autonomous: true

must_haves:
  truths:
    - "useVisibility returns true when document is not hidden and false when hidden"
    - "useAdaptivePolling pauses interval when tab is hidden (unless alwaysActive)"
    - "useAdaptivePolling fires callback immediately when tab becomes visible again"
    - "useAdaptivePolling with alwaysActive:true never pauses regardless of visibility"
    - "useNetworkQuality returns 'slow' for slow-2g/2g and 'fast' for 3g/4g"
    - "useNetworkQuality returns 'unknown' when Network Information API unavailable"
  artifacts:
    - path: "lib/hooks/useVisibility.ts"
      provides: "Page Visibility API wrapper hook"
      exports: ["useVisibility"]
    - path: "lib/hooks/useNetworkQuality.ts"
      provides: "Network Information API wrapper hook"
      exports: ["useNetworkQuality", "NetworkQuality"]
    - path: "lib/hooks/useAdaptivePolling.ts"
      provides: "Centralized polling hook with visibility awareness"
      exports: ["useAdaptivePolling", "UseAdaptivePollingOptions"]
    - path: "lib/hooks/__tests__/useVisibility.test.ts"
      provides: "Tests for useVisibility hook"
      min_lines: 40
    - path: "lib/hooks/__tests__/useNetworkQuality.test.ts"
      provides: "Tests for useNetworkQuality hook"
      min_lines: 40
    - path: "lib/hooks/__tests__/useAdaptivePolling.test.ts"
      provides: "Tests for useAdaptivePolling hook"
      min_lines: 80
  key_links:
    - from: "lib/hooks/useAdaptivePolling.ts"
      to: "lib/hooks/useVisibility.ts"
      via: "import useVisibility"
      pattern: "import.*useVisibility.*from.*useVisibility"
---

<objective>
Create the three foundational hooks for adaptive polling: useVisibility (Page Visibility API), useNetworkQuality (Network Information API), and useAdaptivePolling (centralized polling with visibility awareness).

Purpose: These hooks provide the building blocks for all polling integration in device cards. TDD ensures the visibility/pause/resume behavior is correct before integrating into components.
Output: Three tested hooks in lib/hooks/ with comprehensive test coverage.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/57-adaptive-polling/57-RESEARCH.md
@lib/hooks/useDeviceStaleness.ts
@lib/hooks/__tests__/useDeviceStaleness.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useVisibility and useNetworkQuality hooks with TDD</name>
  <files>
    lib/hooks/useVisibility.ts
    lib/hooks/useNetworkQuality.ts
    lib/hooks/__tests__/useVisibility.test.ts
    lib/hooks/__tests__/useNetworkQuality.test.ts
  </files>
  <action>
**RED phase first** - write failing tests, then implement.

**useVisibility hook** (`lib/hooks/useVisibility.ts`):
- `'use client'` directive at top
- Returns `boolean` (true = tab visible, false = hidden)
- Uses `document.hidden` and `visibilitychange` event
- SSR-safe: check `typeof document === 'undefined'` before accessing
- Initialize state to `true` (assume visible on SSR/mount)
- On mount: set actual `!document.hidden` value
- Cleanup: remove event listener on unmount

**Tests** (`lib/hooks/__tests__/useVisibility.test.ts`):
- `@jest-environment jsdom` header
- Returns true initially (tab visible by default)
- Returns false when `document.hidden` is true and `visibilitychange` fires
- Returns true again when `document.hidden` becomes false and `visibilitychange` fires
- Cleans up event listener on unmount (use spy on `document.removeEventListener`)

**useNetworkQuality hook** (`lib/hooks/useNetworkQuality.ts`):
- `'use client'` directive at top
- Export type `NetworkQuality = 'slow' | 'fast' | 'unknown'`
- Returns `NetworkQuality`
- Access `(navigator as any).connection` with feature detection
- Map `effectiveType`: `'slow-2g'` and `'2g'` = `'slow'`, `'3g'` and `'4g'` = `'fast'`
- If API not available: return `'unknown'` (progressive enhancement - do NOT assume fast)
- Listen to `connection.addEventListener('change', ...)` for updates
- Cleanup: remove listener on unmount

**Tests** (`lib/hooks/__tests__/useNetworkQuality.test.ts`):
- `@jest-environment jsdom` header
- Returns 'unknown' when navigator.connection not available
- Returns 'fast' when effectiveType is '4g'
- Returns 'fast' when effectiveType is '3g'
- Returns 'slow' when effectiveType is '2g'
- Returns 'slow' when effectiveType is 'slow-2g'
- Updates when connection change event fires
- Mock navigator.connection: `Object.defineProperty(navigator, 'connection', { ... })`
  </action>
  <verify>
Run: `npm test -- --testPathPattern='lib/hooks/__tests__/(useVisibility|useNetworkQuality)' --no-coverage`
All tests pass.
  </verify>
  <done>
useVisibility correctly tracks document.hidden state. useNetworkQuality returns proper NetworkQuality based on effectiveType with fallback to 'unknown'. Both have comprehensive tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useAdaptivePolling hook with TDD</name>
  <files>
    lib/hooks/useAdaptivePolling.ts
    lib/hooks/__tests__/useAdaptivePolling.test.ts
  </files>
  <action>
**RED phase first** - write failing tests, then implement.

**useAdaptivePolling hook** (`lib/hooks/useAdaptivePolling.ts`):
- `'use client'` directive at top
- Export interface `UseAdaptivePollingOptions`:
  - `callback: () => void | Promise<void>` - function to call each interval
  - `interval: number | null` - ms between calls (null = paused)
  - `alwaysActive?: boolean` - if true, never pause (default: false)
  - `immediate?: boolean` - if true, run callback on mount (default: true)
- Export function `useAdaptivePolling(options: UseAdaptivePollingOptions): void`
- Uses `useRef` for callback storage (Dan Abramov pattern - avoids stale closures)
- Uses `useVisibility()` from `./useVisibility`
- Logic:
  1. Update `savedCallback.current` whenever `callback` changes
  2. On mount: if `immediate && interval !== null`, call `savedCallback.current()`
  3. Interval management effect (deps: `[interval, isVisible, alwaysActive]`):
     - If `interval === null` => no interval (explicitly paused)
     - If `!alwaysActive && !isVisible` => no interval (tab hidden, not safety-critical)
     - Otherwise: `setInterval(tick, interval)` with cleanup
  4. Visibility restore effect (deps: `[isVisible]`):
     - If `isVisible && !alwaysActive && interval !== null` => call `savedCallback.current()` immediately
     - This ensures fresh data when returning to tab without waiting for next interval tick

**Tests** (`lib/hooks/__tests__/useAdaptivePolling.test.ts`):
- `@jest-environment jsdom` header
- Use `jest.useFakeTimers()` / `jest.useRealTimers()` in before/afterEach
- Mock `useVisibility` via `jest.mock('../useVisibility')` returning controlled value

Test cases (minimum):
1. Calls callback immediately on mount when `immediate: true`
2. Does NOT call callback on mount when `immediate: false`
3. Calls callback at regular interval
4. Stops calling when `interval` changes to `null`
5. Pauses polling when tab becomes hidden (`useVisibility` returns false)
6. Resumes polling AND calls immediately when tab becomes visible again
7. Does NOT pause when `alwaysActive: true` even if tab hidden
8. Cleans up interval on unmount
9. Uses latest callback (no stale closures) - update callback prop, verify new one is called

For mocking visibility changes, mock `useVisibility` to return a controlled value, then use `rerender` to trigger state changes.
  </action>
  <verify>
Run: `npm test -- --testPathPattern='lib/hooks/__tests__/useAdaptivePolling' --no-coverage`
All tests pass.
  </verify>
  <done>
useAdaptivePolling correctly pauses on hidden tab, resumes with immediate fetch on visible, respects alwaysActive flag, and avoids stale closures. All 9+ test cases pass.
  </done>
</task>

</tasks>

<verification>
```bash
# Run all hook tests
npm test -- --testPathPattern='lib/hooks/__tests__/(useVisibility|useNetworkQuality|useAdaptivePolling)' --no-coverage

# Verify TypeScript compilation
npx tsc --noEmit --strict lib/hooks/useVisibility.ts lib/hooks/useNetworkQuality.ts lib/hooks/useAdaptivePolling.ts 2>&1 | head -20

# Verify exports
grep -n 'export' lib/hooks/useVisibility.ts lib/hooks/useNetworkQuality.ts lib/hooks/useAdaptivePolling.ts
```
</verification>

<success_criteria>
- All 3 hooks created with proper TypeScript types
- useVisibility correctly wraps Page Visibility API
- useNetworkQuality handles missing API gracefully (returns 'unknown')
- useAdaptivePolling pauses on hidden, resumes on visible, respects alwaysActive
- All tests pass (15+ test cases across 3 test files)
</success_criteria>

<output>
After completion, create `.planning/phases/57-adaptive-polling/57-01-SUMMARY.md`
</output>
