---
phase: 58-stovecard-refactoring
plan: 03
type: execute
wave: 3
depends_on: ["58-02"]
files_modified:
  - app/components/devices/stove/components/StoveModeControl.tsx
  - app/components/devices/stove/components/StoveAdjustments.tsx
  - app/components/devices/stove/components/StoveMaintenance.tsx
  - app/components/devices/stove/StoveCard.tsx
  - __tests__/components/devices/stove/components/StoveModeControl.test.tsx
  - __tests__/components/devices/stove/components/StoveAdjustments.test.tsx
  - __tests__/components/devices/stove/StoveCard.orchestrator.test.tsx
autonomous: true

must_haves:
  truths:
    - "StoveCard.tsx is ~200 LOC orchestrator with no inline business logic or complex JSX"
    - "StoveModeControl renders Manuale/Automatica/Semi-manuale mode buttons and next scheduled action"
    - "StoveAdjustments renders fan and power level controls with increment/decrement buttons"
    - "StoveMaintenance renders the maintenance progress bar via MaintenanceBar component"
    - "All 6 sub-components are purely presentational (no state/effects)"
    - "Single polling loop preserved â€” only useStoveData contains polling/Firebase side effects"
  artifacts:
    - path: "app/components/devices/stove/components/StoveModeControl.tsx"
      provides: "Mode selector and next action display"
      exports: ["default"]
    - path: "app/components/devices/stove/components/StoveAdjustments.tsx"
      provides: "Fan and power level controls"
      exports: ["default"]
    - path: "app/components/devices/stove/components/StoveMaintenance.tsx"
      provides: "Maintenance progress bar wrapper"
      exports: ["default"]
    - path: "app/components/devices/stove/StoveCard.tsx"
      provides: "Final ~200 LOC orchestrator"
      exports: ["default"]
  key_links:
    - from: "app/components/devices/stove/StoveCard.tsx"
      to: "app/components/devices/stove/components/StoveModeControl.tsx"
      via: "component import"
      pattern: "import StoveModeControl"
    - from: "app/components/devices/stove/StoveCard.tsx"
      to: "app/components/devices/stove/components/StoveAdjustments.tsx"
      via: "component import"
      pattern: "import StoveAdjustments"
    - from: "app/components/devices/stove/StoveCard.tsx"
      to: "app/components/devices/stove/components/StoveMaintenance.tsx"
      via: "component import"
      pattern: "import StoveMaintenance"
---

<objective>
Extract the remaining three sub-components (StoveModeControl, StoveAdjustments, StoveMaintenance) and finalize StoveCard.tsx as a ~200 LOC orchestrator.

Purpose: Complete the orchestrator pattern refactoring. After this plan, StoveCard.tsx contains ONLY hook calls and component composition â€” no inline logic, no complex JSX, no data fetching.

Output: 3 final sub-components + final orchestrator + orchestrator integration test.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/58-stovecard-refactoring/58-RESEARCH.md
@.planning/phases/58-stovecard-refactoring/58-01-SUMMARY.md
@.planning/phases/58-stovecard-refactoring/58-02-SUMMARY.md
@app/components/devices/stove/StoveCard.tsx
@app/components/devices/stove/hooks/useStoveData.ts
@app/components/devices/stove/hooks/useStoveCommands.ts
@app/components/devices/stove/stoveStatusUtils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StoveModeControl, StoveAdjustments, StoveMaintenance and finalize orchestrator</name>
  <files>
    app/components/devices/stove/components/StoveModeControl.tsx
    app/components/devices/stove/components/StoveAdjustments.tsx
    app/components/devices/stove/components/StoveMaintenance.tsx
    app/components/devices/stove/StoveCard.tsx
  </files>
  <action>
    **1. StoveModeControl.tsx** (~200 LOC) â€” Extract from StoveCard.tsx lines 1187-1298 (mode control section):
    - Define `StoveModeControlProps` interface:
      ```typescript
      interface StoveModeControlProps {
        schedulerEnabled: boolean;
        semiManualMode: boolean;
        returnToAutoAt: number | null;
        nextScheduledAction: any;
        onSetManualMode: () => void;
        onSetAutomaticMode: () => void;
        onClearSemiManual: () => void;
        onNavigateToScheduler: () => void;
      }
      ```
    - 'use client' directive.
    - Import Button, Text, Heading, Divider from UI components.
    - Import CronHealthBanner from '../../CronHealthBanner'.
    - Copy EXACT JSX from lines 1189-1298: Divider "ModalitÃ  Controllo", mode indicator box with icon, Button.Group (Manuale/Automatica/Semi-man.), next action display, "Torna in Automatico" button, "Configura Pianificazione" button, and CronHealthBanner.
    - Replace handler refs with props: handleSetManualMode â†’ onSetManualMode, handleSetAutomaticMode â†’ onSetAutomaticMode, handleClearSemiManual â†’ onClearSemiManual, router.push('/stove/scheduler') â†’ onNavigateToScheduler.
    - The date formatting logic for returnToAutoAt and nextScheduledAction stays inline in this component (it's purely presentational rendering logic, not state).
    - NO useState, NO useEffect.

    **2. StoveAdjustments.tsx** (~200 LOC) â€” Extract from StoveCard.tsx lines 1333-1452 (adjustments section):
    - Define `StoveAdjustmentsProps` interface:
      ```typescript
      interface StoveAdjustmentsProps {
        fanLevel: number | null;
        powerLevel: number | null;
        schedulerEnabled: boolean;
        semiManualMode: boolean;
        onFanChange: (e: { target: { value: string } }) => void;
        onPowerChange: (e: { target: { value: string } }) => void;
      }
      ```
    - 'use client' directive.
    - Import ControlButton, Banner, Heading, Text, Divider from UI components.
    - Copy EXACT JSX from lines 1333-1452: Divider "Regolazioni", semi-manual info banner, fan control (header + 3-column grid with ControlButton decrement/increment + level display), power control (same pattern).
    - The increment/decrement handlers are inline arrow functions that call onFanChange/onPowerChange with value string â€” these are purely UI event wiring, not business logic.
    - NO useState, NO useEffect.

    **3. StoveMaintenance.tsx** (~50 LOC) â€” Extract from StoveCard.tsx lines 1325-1332:
    - Define `StoveMaintenanceProps` interface:
      ```typescript
      interface StoveMaintenanceProps {
        maintenanceStatus: any;
      }
      ```
    - 'use client' directive.
    - Import MaintenanceBar from '../../MaintenanceBar' and Divider from '../../ui'.
    - Copy EXACT JSX: Divider "Manutenzione" + MaintenanceBar component.
    - Conditional rendering (only when maintenanceStatus is truthy) handled by parent orchestrator, NOT inside this component.
    - NO useState, NO useEffect.

    **4. Finalize StoveCard.tsx as ~200 LOC orchestrator:**

    Remove ALL remaining inline JSX sections that were extracted. The final StoveCard.tsx should have this structure:

    ```typescript
    'use client';

    import { useRouter } from 'next/navigation';
    import { useUser } from '@auth0/nextjs-auth0/client';
    import { useVersion } from '@/app/context/VersionContext';
    import { useStoveData } from './hooks/useStoveData';
    import { useStoveCommands } from './hooks/useStoveCommands';
    import StoveStatus from './components/StoveStatus';
    import StovePrimaryActions from './components/StovePrimaryActions';
    import StoveBanners from './components/StoveBanners';
    import StoveModeControl from './components/StoveModeControl';
    import StoveAdjustments from './components/StoveAdjustments';
    import StoveMaintenance from './components/StoveMaintenance';
    import Card from '../../ui/Card';
    import Skeleton from '../../ui/Skeleton';
    import LoadingOverlay from '../../ui/LoadingOverlay';
    import CardAccentBar from '../../ui/CardAccentBar';
    import ErrorAlert from '../../ui/ErrorAlert';

    export default function StoveCard() {
      const router = useRouter();
      const { checkVersion } = useVersion();
      const { user } = useUser();

      const stoveData = useStoveData({ checkVersion, user });
      const commands = useStoveCommands({ ...relevantStateAndSetters, router, user });

      if (stoveData.initialLoading) {
        return <Skeleton.StovePanel />;
      }

      return (
        <div className="space-y-4 sm:space-y-6">
          <LoadingOverlay show={stoveData.loading} message={stoveData.loadingMessage} icon="ðŸ”¥" />

          {stoveData.errorCode !== 0 && (
            <ErrorAlert errorCode={stoveData.errorCode} errorDescription={stoveData.errorDescription} showDetailsButton showSuggestion />
          )}

          <Card variant="elevated" padding={false} className="overflow-visible transition-all duration-500">
            <div className="relative">
              <CardAccentBar colorTheme="ember" animated pulse={stoveData.isAccesa} size="md" />
              <div className="p-6 sm:p-8">
                <StoveBanners
                  needsMaintenance={stoveData.needsMaintenance}
                  maintenanceStatus={stoveData.maintenanceStatus}
                  cleaningInProgress={stoveData.cleaningInProgress}
                  isFirebaseConnected={stoveData.isFirebaseConnected}
                  hasPendingCommands={stoveData.hasPendingCommands}
                  pendingCommands={stoveData.pendingCommands}
                  igniteCmd={commands.igniteCmd}
                  shutdownCmd={commands.shutdownCmd}
                  setFanCmd={commands.setFanCmd}
                  setPowerCmd={commands.setPowerCmd}
                  onConfirmCleaning={commands.handleConfirmCleaning}
                  onNavigateToMaintenance={() => router.push('/stove/maintenance')}
                />

                {/* Header */}
                <div className="flex items-center justify-between gap-3 mb-6">
                  ... header JSX (8 lines) ...
                </div>

                <StoveStatus
                  status={stoveData.status}
                  fanLevel={stoveData.fanLevel}
                  powerLevel={stoveData.powerLevel}
                  errorCode={stoveData.errorCode}
                  sandboxMode={stoveData.sandboxMode}
                  staleness={stoveData.staleness}
                  isVisible={stoveData.isVisible}
                  statusInfo={stoveData.statusInfo}
                  statusDisplay={stoveData.statusDisplay}
                />

                <StovePrimaryActions
                  isAccesa={stoveData.isAccesa}
                  isSpenta={stoveData.isSpenta}
                  isOnline={stoveData.isOnline}
                  needsMaintenance={stoveData.needsMaintenance}
                  loading={stoveData.loading}
                  igniteCmd={commands.igniteCmd}
                  shutdownCmd={commands.shutdownCmd}
                  onIgnite={commands.handleIgnite}
                  onShutdown={commands.handleShutdown}
                />

                {stoveData.isOnline && (
                  <StoveModeControl
                    schedulerEnabled={stoveData.schedulerEnabled}
                    semiManualMode={stoveData.semiManualMode}
                    returnToAutoAt={stoveData.returnToAutoAt}
                    nextScheduledAction={stoveData.nextScheduledAction}
                    onSetManualMode={commands.handleSetManualMode}
                    onSetAutomaticMode={commands.handleSetAutomaticMode}
                    onClearSemiManual={commands.handleClearSemiManual}
                    onNavigateToScheduler={() => router.push('/stove/scheduler')}
                  />
                )}

                {stoveData.isOnline && stoveData.status?.toUpperCase().includes('WORK') && (
                  <StoveAdjustments
                    fanLevel={stoveData.fanLevel}
                    powerLevel={stoveData.powerLevel}
                    schedulerEnabled={stoveData.schedulerEnabled}
                    semiManualMode={stoveData.semiManualMode}
                    onFanChange={commands.handleFanChange}
                    onPowerChange={commands.handlePowerChange}
                  />
                )}

                {stoveData.maintenanceStatus && (
                  <StoveMaintenance maintenanceStatus={stoveData.maintenanceStatus} />
                )}
              </div>
            </div>
          </Card>
        </div>
      );
    }
    ```

    - The header section (~8 lines: icon + "Stufa" heading + Badge + HealthIndicator) stays inline in the orchestrator â€” it's too small to warrant a separate component and it uses statusDisplay data directly.
    - Target: StoveCard.tsx should be approximately 150-200 LOC (imports + hook calls + JSX composition).
    - Verify final line count with `wc -l`.

    CRITICAL CONSTRAINTS:
    - Every Tailwind class and spacing from original must be preserved.
    - Conditional rendering logic (isOnline, status.includes('WORK'), maintenanceStatus truthy) must match original exactly.
    - CronHealthBanner is inside StoveModeControl (it appears after the mode buttons within the isOnline block).
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `wc -l app/components/devices/stove/StoveCard.tsx` shows approximately 150-200 lines
    - `grep -r "useState\|useEffect" app/components/devices/stove/components/` returns NO matches
    - All 6 sub-component files exist in components/ directory
    - StoveCard.tsx contains NO getStatusInfo, NO fetchFanLevel, NO handleIgnite functions
  </verify>
  <done>
    StoveCard.tsx is a ~200 LOC orchestrator. All 6 sub-components extracted. No inline business logic remains. Single polling loop preserved in useStoveData hook.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for orchestrator and remaining sub-components</name>
  <files>
    __tests__/components/devices/stove/components/StoveModeControl.test.tsx
    __tests__/components/devices/stove/components/StoveAdjustments.test.tsx
    __tests__/components/devices/stove/StoveCard.orchestrator.test.tsx
  </files>
  <action>
    **1. StoveModeControl.test.tsx:**
    - Test renders "ModalitÃ  Controllo" divider label.
    - Test renders Manuale button with ember variant when schedulerEnabled=false.
    - Test renders Automatica button with ember variant when schedulerEnabled=true and semiManualMode=false.
    - Test renders Semi-man. button with ember variant when schedulerEnabled=true and semiManualMode=true.
    - Test renders "Torna in Automatico" button when semiManualMode=true.
    - Test renders next scheduled action time when schedulerEnabled and nextScheduledAction provided.
    - Test calls onSetManualMode when Manuale button clicked.
    - Test calls onSetAutomaticMode when Automatica button clicked.
    - Test renders CronHealthBanner component.

    **2. StoveAdjustments.test.tsx:**
    - Test renders "Regolazioni" divider label.
    - Test renders fan level display with correct value.
    - Test renders power level display with correct value.
    - Test renders semi-manual info banner when schedulerEnabled=true and semiManualMode=false.
    - Test increment button calls onFanChange with level+1.
    - Test decrement button calls onPowerChange with level-1.
    - Test decrement button disabled when level=1.
    - Test increment button disabled when fanLevel=6.

    **3. StoveCard.orchestrator.test.tsx:**
    - Mock useStoveData to return controlled state object.
    - Mock useStoveCommands to return mock handlers.
    - Mock useRouter, useVersion, useUser.
    - Test: renders Skeleton.StovePanel when initialLoading=true.
    - Test: renders ErrorAlert when errorCode > 0.
    - Test: renders StoveStatus component (check for status label text).
    - Test: renders StovePrimaryActions (check for ACCENDI/SPEGNI button).
    - Test: renders StoveModeControl when isOnline=true.
    - Test: does NOT render StoveModeControl when isOnline=false.
    - Test: renders StoveAdjustments when isOnline=true AND status includes 'WORK'.
    - Test: does NOT render StoveAdjustments when status is 'OFF'.
    - Test: renders StoveMaintenance when maintenanceStatus is truthy.
    - Test: StoveCard.tsx line count is <= 250 lines (enforcement test).

    Run: `npx jest __tests__/components/devices/stove/ --no-coverage`
  </action>
  <verify>
    - `npx jest __tests__/components/devices/stove/ --no-coverage` â€” ALL tests pass (Plans 01 + 02 + 03)
    - Total test count >= 40 across all test files
    - StoveCard.orchestrator.test.tsx proves orchestrator composes sub-components correctly
    - Zero TypeScript errors: `npx tsc --noEmit`
  </verify>
  <done>
    Complete test suite for all sub-components and orchestrator. Tests verify composition, conditional rendering, and prop drilling. Line count enforcement test ensures orchestrator stays lean. Phase 58 refactoring complete.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npx jest __tests__/components/devices/stove/ --no-coverage` â€” all tests green (40+ tests)
3. `wc -l app/components/devices/stove/StoveCard.tsx` <= 250 LOC
4. `wc -l app/components/devices/stove/components/*.tsx` â€” each file 50-250 LOC
5. `grep -r "useState\|useEffect" app/components/devices/stove/components/` â€” 0 matches
6. `ls app/components/devices/stove/components/` shows 6 files
7. `ls app/components/devices/stove/hooks/` shows 2 files
8. Original StoveCard behavior preserved (single polling loop, retry infrastructure, error boundaries)
</verification>

<success_criteria>
- StoveCard.tsx reduced to ~200 LOC orchestrator (from 1458 LOC)
- 6 sub-components: StoveStatus, StovePrimaryActions, StoveBanners, StoveModeControl, StoveAdjustments, StoveMaintenance
- 2 custom hooks: useStoveData, useStoveCommands
- 1 utility module: stoveStatusUtils
- All sub-components are purely presentational (no state/effects)
- 40+ unit tests across all modules
- Phase 58 success criteria fully met
</success_criteria>

<output>
After completion, create `.planning/phases/58-stovecard-refactoring/58-03-SUMMARY.md`
</output>
