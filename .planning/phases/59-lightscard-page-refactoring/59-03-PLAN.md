---
phase: 59-lightscard-page-refactoring
plan: 03
type: execute
wave: 3
depends_on: ["59-01", "59-02"]
files_modified:
  - app/components/devices/lights/LightsCard.tsx
  - __tests__/components/devices/lights/LightsCard.test.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "LightsCard.tsx reduced from 1225 LOC to ~150-200 LOC orchestrator"
    - "LightsCard imports and calls useLightsData() and useLightsCommands()"
    - "LightsCard renders LightsHouseControl, LightsRoomControl, LightsScenes sub-components"
    - "LightsCard passes buildLightsBanners() output to DeviceCard banners prop"
    - "All extracted inline logic removed from LightsCard"
    - "Visual output unchanged after refactoring"
  artifacts:
    - path: "app/components/devices/lights/LightsCard.tsx"
      provides: "Orchestrator wiring hooks to sub-components"
      max_lines: 200
    - path: "__tests__/components/devices/lights/LightsCard.test.tsx"
      provides: "Integration test for orchestrator"
  key_links:
    - from: "LightsCard.tsx"
      to: "hooks/useLightsData"
      via: "import { useLightsData } and call at top level"
      pattern: "useLightsData\\(\\)"
    - from: "LightsCard.tsx"
      to: "hooks/useLightsCommands"
      via: "import { useLightsCommands } and call at top level"
      pattern: "useLightsCommands\\("
    - from: "LightsCard.tsx"
      to: "components/LightsHouseControl"
      via: "import and render as JSX"
      pattern: "<LightsHouseControl"
    - from: "LightsCard.tsx"
      to: "components/LightsRoomControl"
      via: "import and render as JSX"
      pattern: "<LightsRoomControl"
    - from: "LightsCard.tsx"
      to: "components/LightsScenes"
      via: "import and render as JSX"
      pattern: "<LightsScenes"
    - from: "LightsCard.tsx"
      to: "components/LightsBanners"
      via: "import { buildLightsBanners } and call to build banner array"
      pattern: "buildLightsBanners\\("
---

<objective>
Refactor LightsCard.tsx from 1225 LOC monolith to ~150-200 LOC orchestrator by wiring the hooks (useLightsData, useLightsCommands) and sub-components (LightsHouseControl, LightsRoomControl, LightsScenes, buildLightsBanners) created in Plans 01 and 02.

Purpose: Close the primary gap â€” hooks and components exist but LightsCard.tsx hasn't been refactored to use them. This is the final wiring step that transforms LightsCard into the orchestrator pattern established by StoveCard in Phase 58.

Output: LightsCard.tsx reduced to ~150-200 LOC orchestrator + integration test
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# CRITICAL: The finished pattern to follow exactly
@app/components/devices/stove/StoveCard.tsx

# Source file to refactor
@app/components/devices/lights/LightsCard.tsx

# Hooks to import and call
@app/components/devices/lights/hooks/useLightsData.ts
@app/components/devices/lights/hooks/useLightsCommands.ts

# Components to import and render
@app/components/devices/lights/components/LightsBanners.tsx
@app/components/devices/lights/components/LightsHouseControl.tsx
@app/components/devices/lights/components/LightsRoomControl.tsx
@app/components/devices/lights/components/LightsScenes.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite LightsCard.tsx as orchestrator</name>
  <files>app/components/devices/lights/LightsCard.tsx</files>
  <action>
Rewrite LightsCard.tsx following the EXACT pattern from StoveCard.tsx (app/components/devices/stove/StoveCard.tsx). The StoveCard orchestrator is ~188 LOC. LightsCard should be similar.

**Step 1: Replace ALL imports.** Remove all current imports. Add only:
```typescript
'use client';
import { useRouter } from 'next/navigation';
import Skeleton from '../../ui/Skeleton';
import DeviceCard from '../../ui/DeviceCard';
import RoomSelector from '../../ui/RoomSelector';
import { EmptyState } from '../../ui';
import { useLightsData } from './hooks/useLightsData';
import { useLightsCommands } from './hooks/useLightsCommands';
import { buildLightsBanners } from './components/LightsBanners';
import LightsHouseControl from './components/LightsHouseControl';
import LightsRoomControl from './components/LightsRoomControl';
import LightsScenes from './components/LightsScenes';
```

**Step 2: Hook calls at top of function.**
```typescript
export default function LightsCard() {
  const router = useRouter();
  const lightsData = useLightsData();
  const commands = useLightsCommands({
    lightsData: {
      setRefreshing: lightsData.setRefreshing,
      setLoadingMessage: lightsData.setLoadingMessage,
      setError: lightsData.setError,
      fetchData: lightsData.fetchData,
      rooms: lightsData.rooms,
      setPairing: lightsData.setPairing,
      setPairingStep: lightsData.setPairingStep,
      setDiscoveredBridges: lightsData.setDiscoveredBridges,
      setSelectedBridge: lightsData.setSelectedBridge,
      setPairingCountdown: lightsData.setPairingCountdown,
      setPairingError: lightsData.setPairingError,
      pairingTimerRef: lightsData.pairingTimerRef,
      selectedBridge: lightsData.selectedBridge,
      checkConnection: lightsData.checkConnection,
      connected: lightsData.connected,
    },
    router,
  });
```

**Step 3: Build banners using utility.**
```typescript
  const banners = buildLightsBanners({
    hueRoomCmd: commands.hueRoomCmd,
    hueSceneCmd: commands.hueSceneCmd,
    pairing: lightsData.pairing,
    pairingStep: lightsData.pairingStep,
    pairingCountdown: lightsData.pairingCountdown,
    pairingError: lightsData.pairingError,
    discoveredBridges: lightsData.discoveredBridges,
    selectedBridge: lightsData.selectedBridge,
    error: lightsData.error,
    onRemoteAuth: commands.handleRemoteAuth,
    onCancelPairing: commands.handleCancelPairing,
    onConfirmButtonPressed: commands.handleConfirmButtonPressed,
    onSelectBridge: commands.handleSelectBridge,
    onRetryPairing: commands.handleRetryPairing,
    onDismissError: () => lightsData.setError(null),
    onDismissPairingError: () => lightsData.setPairingError(null),
  });
```

**Step 4: Build derived props (infoBoxes, footerActions, statusBadge).**
Keep the same logic currently in LightsCard for `infoBoxes`, `footerActions`, and `getStatusBadge()` â€” these are small ~10-line sections that stay inline in the orchestrator (same as StoveCard keeps its header inline).

**Step 5: Skeleton/loading guard.**
```typescript
  if (lightsData.loading) {
    return <Skeleton.LightsCard />;
  }
```
Note: use `lightsData.loading` for the initial loading state only. Check whether Skeleton.LightsCard exists â€” if the current code uses `loading ? <Skeleton.LightsCard /> : null` as skeletonComponent prop to DeviceCard, then keep the same pattern. Don't change rendering behavior.

**Step 6: Return DeviceCard with sub-components.** The JSX should be:
```tsx
  return (
    <DeviceCard
      icon="ðŸ’¡"
      title="Luci"
      colorTheme="warning"
      connected={lightsData.connected}
      onConnect={commands.handleStartPairing}
      connectButtonLabel="Connetti Bridge Hue"
      connectInfoRoute="/lights"
      loading={lightsData.loading || lightsData.refreshing || lightsData.pairing}
      loadingMessage={lightsData.pairingStep === 'discovering' ? 'Ricerca bridge...' : lightsData.pairingStep === 'pairing' ? `Pairing in corso... ${lightsData.pairingCountdown}s` : lightsData.loadingMessage}
      skeletonComponent={lightsData.loading ? <Skeleton.LightsCard /> : null}
      statusBadge={statusBadge}
      banners={banners}
      infoBoxes={infoBoxes}
      infoBoxesTitle="Informazioni"
      footerActions={footerActions}
    >
      <LightsHouseControl
        hasAnyLights={lightsData.hasAnyLights}
        totalLightsOn={lightsData.totalLightsOn}
        totalLights={lightsData.lights.length}
        allHouseLightsOn={lightsData.allHouseLightsOn}
        allHouseLightsOff={lightsData.allHouseLightsOff}
        refreshing={lightsData.refreshing}
        onAllLightsToggle={commands.handleAllLightsToggle}
      />

      <RoomSelector
        rooms={lightsData.rooms.map((room: any) => ({
          id: room.id,
          name: room.metadata?.name || 'Stanza'
        }))}
        selectedRoomId={lightsData.selectedRoomId || undefined}
        onChange={(e: React.ChangeEvent<HTMLSelectElement>) => lightsData.setSelectedRoomId(e.target.value)}
      />

      {lightsData.selectedRoom ? (
        <div className="space-y-4 sm:space-y-6">
          <LightsRoomControl
            selectedRoom={lightsData.selectedRoom}
            selectedRoomGroupedLightId={lightsData.selectedRoomGroupedLightId}
            roomLights={lightsData.roomLights}
            isRoomOn={lightsData.isRoomOn}
            lightsOnCount={lightsData.lightsOnCount}
            lightsOffCount={lightsData.lightsOffCount}
            allLightsOn={lightsData.allLightsOn}
            allLightsOff={lightsData.allLightsOff}
            avgBrightness={lightsData.avgBrightness}
            localBrightness={lightsData.localBrightness}
            hasColorLights={lightsData.hasColorLights}
            refreshing={lightsData.refreshing}
            dynamicRoomStyle={lightsData.dynamicRoomStyle}
            adaptive={lightsData.adaptive}
            onRoomToggle={commands.handleRoomToggle}
            onBrightnessChange={commands.handleBrightnessChange}
            setLocalBrightness={lightsData.setLocalBrightness}
            onColorControlClick={() => router.push('/lights')}
          />

          <LightsScenes
            roomScenes={lightsData.roomScenes}
            refreshing={lightsData.refreshing}
            onSceneActivate={commands.handleSceneActivate}
          />
        </div>
      ) : (
        <EmptyState
          icon="ðŸ’¡"
          title="Nessuna stanza disponibile"
        />
      )}
    </DeviceCard>
  );
```

**Step 7: Remove ALL extracted code.** The entire function body should be ~150-200 lines. All state declarations, useEffect hooks, async functions, inline JSX for room controls, brightness sliders, scene rendering, pairing flow, banner building, color calculations, adaptive classes, etc. are GONE â€” they live in hooks and components now.

**IMPORTANT:** Do NOT change any prop values or rendering behavior. The orchestrator must produce IDENTICAL visual output. Verify each prop name matches the component interface. Check LightsRoomControl props interface carefully â€” it may use `onColorControlClick` or similar name.
  </action>
  <verify>
1. `wc -l app/components/devices/lights/LightsCard.tsx` shows < 200 lines
2. `grep -c "useState\|useEffect\|useRef\|useCallback" app/components/devices/lights/LightsCard.tsx` shows 0 (no React state hooks in orchestrator)
3. `grep "useLightsData\|useLightsCommands\|buildLightsBanners" app/components/devices/lights/LightsCard.tsx` confirms all hooks/utilities imported
4. `grep "LightsHouseControl\|LightsRoomControl\|LightsScenes" app/components/devices/lights/LightsCard.tsx` confirms all components used
5. `npx tsc --noEmit` passes with no errors related to LightsCard
  </verify>
  <done>
LightsCard.tsx is ~150-200 LOC orchestrator that imports useLightsData, useLightsCommands, buildLightsBanners, and renders LightsHouseControl, LightsRoomControl, LightsScenes. All inline state management, effects, handlers, and JSX removed. Visual output identical to pre-refactoring.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create LightsCard orchestrator integration test</name>
  <files>__tests__/components/devices/lights/LightsCard.test.tsx</files>
  <action>
Create or update `__tests__/components/devices/lights/LightsCard.test.tsx` to test the orchestrator wiring. This is NOT a comprehensive test of each sub-component (those already have 75+ tests). This tests the orchestrator:

1. **Mocks:** Mock `useLightsData` and `useLightsCommands` hooks, and `buildLightsBanners` utility. Return sensible defaults from mocks.

2. **Test cases (5-7 tests):**
   - Renders Skeleton.LightsCard when `lightsData.loading` is true
   - Renders DeviceCard with correct props when connected
   - Renders LightsHouseControl when `hasAnyLights` is true
   - Renders RoomSelector with room names
   - Renders LightsRoomControl when selectedRoom exists
   - Renders LightsScenes when selectedRoom exists
   - Renders EmptyState when no selectedRoom

3. **Pattern:** Follow existing test patterns in `__tests__/components/devices/` directory. Use `@testing-library/react` render + screen.

4. **Mock pattern:**
```typescript
jest.mock('@/app/components/devices/lights/hooks/useLightsData', () => ({
  useLightsData: jest.fn(),
}));
jest.mock('@/app/components/devices/lights/hooks/useLightsCommands', () => ({
  useLightsCommands: jest.fn(),
}));
jest.mock('@/app/components/devices/lights/components/LightsBanners', () => ({
  buildLightsBanners: jest.fn(() => []),
}));
```

Also mock sub-components as simple pass-through renders to isolate orchestrator logic:
```typescript
jest.mock('@/app/components/devices/lights/components/LightsHouseControl', () => {
  return function MockLightsHouseControl() { return <div data-testid="lights-house-control" />; };
});
// Same for LightsRoomControl, LightsScenes
```
  </action>
  <verify>
`npx jest --testPathPattern="LightsCard.test" --no-coverage` â€” all tests pass
  </verify>
  <done>
LightsCard orchestrator has 5-7 integration tests verifying hook wiring and sub-component rendering. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `wc -l app/components/devices/lights/LightsCard.tsx` â€” target < 200 LOC
2. `npx tsc --noEmit` â€” no TypeScript errors
3. `npx jest --testPathPattern="lights" --no-coverage` â€” all lights tests pass (hooks + components + orchestrator)
4. No `useState`, `useEffect`, `useRef`, `useCallback` in LightsCard.tsx (only `useLightsData`, `useLightsCommands`, `useRouter`)
5. LightsCard renders same visual output as before (verify with `npm run dev` at localhost:3000)
</verification>

<success_criteria>
- LightsCard.tsx is < 200 LOC
- LightsCard.tsx has 0 inline state hooks (useState, useEffect, useRef, useCallback)
- LightsCard.tsx imports and calls useLightsData() + useLightsCommands()
- LightsCard.tsx renders LightsHouseControl, LightsRoomControl, LightsScenes
- LightsCard.tsx calls buildLightsBanners() and passes result to DeviceCard
- All 100+ lights tests pass (hooks: 47, components: 75, orchestrator: 5-7)
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/59-lightscard-page-refactoring/59-03-SUMMARY.md`
</output>
