---
phase: 59-lightscard-page-refactoring
plan: 04
type: execute
wave: 3  # Wave 3 for execution timing (after Plans 01-02), no dependency on lights plans â€” reuses StoveCard hooks from Phase 58
depends_on: []
files_modified:
  - app/stove/page.tsx
  - app/stove/components/StovePageHero.tsx
  - app/stove/components/StovePageAdjustments.tsx
  - app/stove/components/StovePageNavigation.tsx
  - app/stove/components/StovePageBanners.tsx
  - app/stove/stovePageTheme.ts
  - __tests__/stove/StovePage.test.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "stove/page.tsx reduced from 1066 LOC to ~200 LOC orchestrator"
    - "stove/page.tsx reuses useStoveData and useStoveCommands from StoveCard hooks"
    - "stove/page.tsx renders 4 page-specific sub-components (Hero, Adjustments, Navigation, Banners)"
    - "Page-specific theme mapping extracted to stovePageTheme.ts utility"
    - "Visual output and functionality unchanged after refactoring"
  artifacts:
    - path: "app/stove/page.tsx"
      provides: "Page orchestrator reusing StoveCard hooks"
      max_lines: 250
    - path: "app/stove/components/StovePageHero.tsx"
      provides: "Hero section with immersive status display, metrics grid, primary actions, mode control"
    - path: "app/stove/components/StovePageAdjustments.tsx"
      provides: "Fan and power level controls for full-page layout"
    - path: "app/stove/components/StovePageNavigation.tsx"
      provides: "Quick nav cards (Scheduler, Maintenance, Errors) + System Status + Back button"
    - path: "app/stove/components/StovePageBanners.tsx"
      provides: "Page-level banners (error alert, maintenance, connection, pending commands)"
    - path: "app/stove/stovePageTheme.ts"
      provides: "Theme color mapping and status config for page layout"
    - path: "__tests__/stove/StovePage.test.tsx"
      provides: "Orchestrator integration tests"
  key_links:
    - from: "app/stove/page.tsx"
      to: "app/components/devices/stove/hooks/useStoveData"
      via: "import { useStoveData } and call at top level"
      pattern: "useStoveData\\("
    - from: "app/stove/page.tsx"
      to: "app/components/devices/stove/hooks/useStoveCommands"
      via: "import { useStoveCommands } and call at top level"
      pattern: "useStoveCommands\\("
    - from: "app/stove/page.tsx"
      to: "app/stove/components/StovePageHero"
      via: "import and render"
      pattern: "<StovePageHero"
    - from: "app/stove/page.tsx"
      to: "app/stove/components/StovePageAdjustments"
      via: "conditional render when isWorking"
      pattern: "<StovePageAdjustments"
    - from: "app/stove/page.tsx"
      to: "app/stove/components/StovePageNavigation"
      via: "import and render"
      pattern: "<StovePageNavigation"
---

<objective>
Refactor stove/page.tsx from 1066 LOC monolith to ~200 LOC orchestrator by reusing the existing useStoveData and useStoveCommands hooks from StoveCard (Phase 58), extracting page-specific layout into 4 sub-components, and extracting theme mapping to a utility.

Purpose: Close the second major gap â€” stove/page.tsx duplicates 100% of StoveCard's state management and commands. By reusing existing hooks and extracting only the page-specific layout, we eliminate code duplication and achieve the orchestrator pattern.

Output: stove/page.tsx reduced to ~200 LOC + 4 page-specific layout components + theme utility + integration test
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# CRITICAL: The orchestrator pattern to follow
@app/components/devices/stove/StoveCard.tsx

# Source file to refactor
@app/stove/page.tsx

# REUSABLE hooks (from Phase 58)
@app/components/devices/stove/hooks/useStoveData.ts
@app/components/devices/stove/hooks/useStoveCommands.ts

# REUSABLE status utils (from Phase 58)
@app/components/devices/stove/stoveStatusUtils.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract page-specific utilities and components</name>
  <files>
    app/stove/stovePageTheme.ts
    app/stove/components/StovePageBanners.tsx
    app/stove/components/StovePageHero.tsx
    app/stove/components/StovePageAdjustments.tsx
    app/stove/components/StovePageNavigation.tsx
  </files>
  <action>
Create the page-specific utilities and presentational components that stove/page.tsx needs. These are layout-specific â€” they don't exist in StoveCard because StoveCard uses a card layout while stove/page.tsx uses a full-page immersive layout.

**All components are presentational: props in, JSX out. No useState, useEffect, useCallback.**

### File 1: `app/stove/stovePageTheme.ts` (~80 LOC)
Extract the theme color mapping and `getStatusConfig` function from stove/page.tsx (lines 479-545). This is a pure utility file, no React.

```typescript
/**
 * Theme utilities for StovePage
 * Pure functions for status-to-theme mapping (immersive volcanic design)
 */

export interface StovePageStatusConfig {
  label: string;
  icon: string;
  theme: string;
  pulse: boolean;
}

export interface StovePageTheme {
  bg: string;
  glow: string;
  accent: string;
  accentBg: string;
  border: string;
}

export function getStovePageStatusConfig(status: string): StovePageStatusConfig {
  // Extract the getStatusConfig logic from stove/page.tsx lines 479-491
}

export function getStovePageTheme(themeKey: string): StovePageTheme {
  // Extract the themeColors object from stove/page.tsx lines 500-543
  // Return matching theme or fallback to 'slate'
}
```

### File 2: `app/stove/components/StovePageBanners.tsx` (~100 LOC)
Presentational component rendering the page-level banners: ErrorAlert, maintenance warning, connection status, pending commands. Extract from stove/page.tsx lines 592-659.

Props: errorCode, errorDescription, needsMaintenance, maintenanceStatus, cleaningInProgress, isFirebaseConnected, hasPendingCommands, pendingCommands, onConfirmCleaning, onNavigateToMaintenance.

The stove/page.tsx uses `Banner` component directly (not `StoveBanners` from StoveCard) and renders `ErrorAlert` outside the card. Keep this page-specific layout.

### File 3: `app/stove/components/StovePageHero.tsx` (~280 LOC)
The largest component. Renders the immersive hero section: decorative background pattern, sandbox/error badges, large status icon, status label, metrics grid (fan + power gauges), primary action buttons (ACCENDI/SPEGNI), and mode indicator with scheduler controls.

Extract from stove/page.tsx lines 662-835.

Props: status, statusConfig, theme, fanLevel, powerLevel, errorCode, sandboxMode, isAccesa, isSpenta, isOnline (from useOnlineStatus), needsMaintenance, loading, schedulerEnabled, semiManualMode, returnToAutoAt, nextScheduledAction, onIgnite, onShutdown, onClearSemiManual, onNavigateToScheduler.

**IMPORTANT:** The stove/page.tsx uses direct handleIgnite/handleShutdown that include `queueStoveCommand` for offline â€” this is handled by the page orchestrator before calling commands, OR the commands can be adapted. The simplest approach: keep the page-level handleIgnite/handleShutdown wrappers in the orchestrator that add offline queueing, then pass them to StovePageHero.

### File 4: `app/stove/components/StovePageAdjustments.tsx` (~100 LOC)
Fan and power level controls in full-page layout. Visible only when stove is WORK. Extract from stove/page.tsx lines 840-920.

Props: fanLevel, powerLevel, schedulerEnabled, semiManualMode, loading, onFanChange, onPowerChange.

**Note:** stove/page.tsx calls `handleFanChange(newLevel)` with a raw number, but useStoveCommands exposes `handleFanChange(event)` that extracts `Number(e.target.value)`. The orchestrator should wrap this: `onFanChange={(level) => commands.handleFanChange({ target: { value: String(level) } })}`. Alternatively, StovePageAdjustments can accept a `(level: number) => void` prop and the orchestrator wraps the adapter.

### File 5: `app/stove/components/StovePageNavigation.tsx` (~120 LOC)
Quick navigation cards (Scheduler, Maintenance, Errors) + System Status section (MaintenanceBar + CronHealthBanner) + Back to Home button. Extract from stove/page.tsx lines 925-1049.

Props: schedulerEnabled, maintenanceStatus, errorCode, formatHoursToHHMM (import directly in component).

Note: This component uses `Link` from next/link for navigation cards and `Button` for back nav, plus `Badge` for status indicators. It also renders `MaintenanceBar` and `CronHealthBanner`. Import these directly in the component (they're independent presentational dependencies).

**Ensure:** `MaintenanceBar` and `CronHealthBanner` are imported using the same paths as stove/page.tsx currently uses. The `formatHoursToHHMM` utility is imported from `@/lib/formatUtils`.
  </action>
  <verify>
1. All 5 files exist and compile: `npx tsc --noEmit` (no errors in app/stove/)
2. Each component has explicit TypeScript interface for props
3. None of the components use useState, useEffect, or useCallback (grep check)
4. `wc -l app/stove/stovePageTheme.ts app/stove/components/*.tsx` â€” all files < 300 LOC
  </verify>
  <done>
5 files created: stovePageTheme.ts (~80 LOC), StovePageBanners.tsx (~100 LOC), StovePageHero.tsx (~280 LOC), StovePageAdjustments.tsx (~100 LOC), StovePageNavigation.tsx (~120 LOC). All presentational with typed props interfaces.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite stove/page.tsx as orchestrator and create test</name>
  <files>
    app/stove/page.tsx
    __tests__/stove/StovePage.test.tsx
  </files>
  <action>
### Part A: Rewrite stove/page.tsx as orchestrator (~200-250 LOC)

Rewrite stove/page.tsx following the StoveCard.tsx orchestrator pattern but adapted for a full-page component.

**Step 1: Replace ALL imports.** Remove all current imports (30+ lines). Add only:
```typescript
'use client';
import { useState, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { useUser } from '@auth0/nextjs-auth0/client';
import { useVersion } from '@/app/context/VersionContext';
import { Heading, Skeleton, LoadingOverlay, Toast } from '@/app/components/ui';
import { useStoveData } from '@/app/components/devices/stove/hooks/useStoveData';
import { useStoveCommands } from '@/app/components/devices/stove/hooks/useStoveCommands';
import { getStovePageStatusConfig, getStovePageTheme } from './stovePageTheme';
import StovePageBanners from './components/StovePageBanners';
import StovePageHero from './components/StovePageHero';
import StovePageAdjustments from './components/StovePageAdjustments';
import StovePageNavigation from './components/StovePageNavigation';
```

NOTE: stove/page.tsx needs `useState` for toast state and `useCallback` for offline wrappers â€” that is acceptable since the page adds page-specific behavior on top of shared hooks. This is different from LightsCard which has zero extra state.

**Step 2: Hook calls at top of function.**
```typescript
export default function StovePage() {
  const router = useRouter();
  const { checkVersion } = useVersion();
  const { user } = useUser();

  // Reuse StoveCard hooks â€” SAME state management, polling, Firebase
  const stoveData = useStoveData({ checkVersion, userId: user?.sub });
  const commands = useStoveCommands({
    stoveData: {
      setLoading: stoveData.setLoading,
      setLoadingMessage: stoveData.setLoadingMessage,
      fetchStatusAndUpdate: stoveData.fetchStatusAndUpdate,
      setSchedulerEnabled: stoveData.setSchedulerEnabled,
      setSemiManualMode: stoveData.setSemiManualMode,
      setReturnToAutoAt: stoveData.setReturnToAutoAt,
      setNextScheduledAction: stoveData.setNextScheduledAction,
      setCleaningInProgress: stoveData.setCleaningInProgress,
      fetchMaintenanceStatus: stoveData.fetchMaintenanceStatus,
      semiManualMode: stoveData.semiManualMode,
    },
    router,
    user,
  });
```

**Step 3: Page-specific toast state and offline wrappers.**

The stove/page.tsx has toast state and offline command queueing via `useBackgroundSync().queueStoveCommand`. However, `useStoveData` already calls `useBackgroundSync` internally and exposes `hasPendingCommands` and `pendingCommands`. The page currently wraps ignite/shutdown to queue commands when offline.

Keep a small `[toast, setToast]` state in the orchestrator for page-specific toasts. Create page-level handleIgnite/handleShutdown wrappers that check `stoveData.isOnline` and either queue or delegate to `commands.handleIgnite/handleShutdown`.

**However**, reviewing useStoveData more carefully â€” it exposes `isOnline` but NOT `queueStoveCommand`. The `useBackgroundSync` hook is called inside useStoveData but only `hasPendingCommands`, `pendingCommands`, and `lastSyncedCommand` are exposed.

**Solution:** Import `useBackgroundSync` directly in the page orchestrator for `queueStoveCommand`. This is acceptable â€” the page adds offline-queue behavior that the card doesn't have:

```typescript
  import { useBackgroundSync } from '@/lib/hooks/useBackgroundSync';
  // In component:
  const { queueStoveCommand } = useBackgroundSync();
  const [toast, setToast] = useState<{ message: string; icon?: string; variant?: 'success' | 'error' | 'warning' | 'info' } | null>(null);
```

**Step 4: Derive display properties.**
```typescript
  const statusConfig = getStovePageStatusConfig(stoveData.status);
  const theme = getStovePageTheme(statusConfig.theme);
  const isWorking = stoveData.status?.toUpperCase().includes('WORK');
```

**Step 5: Page-level ignite/shutdown with offline queueing.**
```typescript
  const handlePageIgnite = useCallback(async () => {
    if (!stoveData.isOnline) {
      await queueStoveCommand('ignite', { source: 'manual' });
      setToast({ message: 'Comando in coda - eseguito al ripristino connessione', variant: 'warning' });
      return;
    }
    await commands.handleIgnite();
  }, [stoveData.isOnline, queueStoveCommand, commands]);

  const handlePageShutdown = useCallback(async () => {
    if (!stoveData.isOnline) {
      await queueStoveCommand('shutdown', { source: 'manual' });
      setToast({ message: 'Comando in coda - eseguito al ripristino connessione', variant: 'warning' });
      return;
    }
    await commands.handleShutdown();
  }, [stoveData.isOnline, queueStoveCommand, commands]);
```

**Step 6: Fan/Power wrappers to adapt number â†’ event interface.**
```typescript
  const handlePageFanChange = useCallback(async (newLevel: number) => {
    await commands.handleFanChange({ target: { value: String(newLevel) } });
  }, [commands]);

  const handlePagePowerChange = useCallback(async (newLevel: number) => {
    await commands.handlePowerChange({ target: { value: String(newLevel) } });
  }, [commands]);
```

**Step 7: Loading skeleton guard.**
```typescript
  if (stoveData.initialLoading) {
    return (
      <div className="space-y-8">
        <Skeleton className="h-[500px] rounded-3xl" />
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {[1, 2, 3].map((i) => (
            <Skeleton key={i} className="h-32 rounded-2xl" />
          ))}
        </div>
      </div>
    );
  }
```

**Step 8: Return JSX composing sub-components.**
```tsx
  return (
    <div className="relative">
      <Heading level={1} className="sr-only">Controllo Stufa</Heading>

      {/* Full-screen ambient gradient + glow */}
      <div className={`fixed inset-0 -z-10 bg-gradient-to-br ${theme.bg} transition-all duration-1000`} />
      <div className={`fixed inset-0 -z-10 pointer-events-none transition-all duration-1000 ${theme.glow}`} />

      <LoadingOverlay show={stoveData.loading} message={stoveData.loadingMessage} icon="ðŸ”¥" />

      <div className="relative space-y-6 sm:space-y-8">
        <StovePageBanners
          errorCode={stoveData.errorCode}
          errorDescription={stoveData.errorDescription}
          needsMaintenance={stoveData.needsMaintenance}
          maintenanceStatus={stoveData.maintenanceStatus}
          cleaningInProgress={stoveData.cleaningInProgress}
          isFirebaseConnected={stoveData.isFirebaseConnected}
          hasPendingCommands={stoveData.hasPendingCommands}
          pendingCommands={stoveData.pendingCommands}
          onConfirmCleaning={commands.handleConfirmCleaning}
          onNavigateToMaintenance={() => router.push('/stove/maintenance')}
        />

        <StovePageHero
          status={stoveData.status}
          statusConfig={statusConfig}
          theme={theme}
          fanLevel={stoveData.fanLevel}
          powerLevel={stoveData.powerLevel}
          errorCode={stoveData.errorCode}
          sandboxMode={stoveData.sandboxMode}
          isAccesa={stoveData.isAccesa}
          isSpenta={stoveData.isSpenta}
          isOnline={stoveData.isOnline}
          needsMaintenance={stoveData.needsMaintenance}
          loading={stoveData.loading}
          schedulerEnabled={stoveData.schedulerEnabled}
          semiManualMode={stoveData.semiManualMode}
          returnToAutoAt={stoveData.returnToAutoAt}
          nextScheduledAction={stoveData.nextScheduledAction}
          onIgnite={handlePageIgnite}
          onShutdown={handlePageShutdown}
          onClearSemiManual={commands.handleClearSemiManual}
          onNavigateToScheduler={() => router.push('/stove/scheduler')}
        />

        {isWorking && (
          <StovePageAdjustments
            fanLevel={stoveData.fanLevel}
            powerLevel={stoveData.powerLevel}
            schedulerEnabled={stoveData.schedulerEnabled}
            semiManualMode={stoveData.semiManualMode}
            loading={stoveData.loading}
            onFanChange={handlePageFanChange}
            onPowerChange={handlePagePowerChange}
          />
        )}

        <StovePageNavigation
          schedulerEnabled={stoveData.schedulerEnabled}
          maintenanceStatus={stoveData.maintenanceStatus}
          errorCode={stoveData.errorCode}
        />
      </div>

      {toast && (
        <Toast
          variant={toast.variant}
          open={!!toast}
          onOpenChange={(open) => !open && setToast(null)}
          duration={3000}
        >
          {toast.icon && <span>{toast.icon}</span>}
          {toast.message}
        </Toast>
      )}
    </div>
  );
```

**Step 9: Remove ALL extracted code.** The entire page should be ~200-250 LOC. All state declarations (30+ useState calls), all useEffect hooks (5 effects), all async functions (fetchFanLevel, fetchPowerLevel, fetchSchedulerMode, etc.), all handlers (handleFanChange, handlePowerChange, handleIgnite, etc.), status mapping, theme objects, and all inline JSX are GONE.

### Part B: Create orchestrator integration test

Create `__tests__/stove/StovePage.test.tsx` with 5-7 tests:

1. Mock `useStoveData`, `useStoveCommands`, sub-components
2. Tests: renders skeleton during initial loading, renders StovePageHero with correct props, renders StovePageAdjustments only when isWorking, renders StovePageNavigation, ambient gradient uses correct theme class, calls handleIgnite when StovePageHero fires onIgnite
  </action>
  <verify>
1. `wc -l app/stove/page.tsx` shows < 250 lines
2. `npx tsc --noEmit` passes with no errors
3. `npx jest --testPathPattern="StovePage" --no-coverage` â€” all tests pass
4. `grep -c "useEffect\|useRef" app/stove/page.tsx` shows 0 (no direct effects/refs in orchestrator)
5. `grep "useStoveData\|useStoveCommands" app/stove/page.tsx` confirms hooks imported from StoveCard
6. `grep "StovePageHero\|StovePageAdjustments\|StovePageNavigation\|StovePageBanners" app/stove/page.tsx` confirms all 4 sub-components imported and used
7. `grep "getStovePageStatusConfig\|getStovePageTheme" app/stove/page.tsx` confirms theme utilities imported
  </verify>
  <done>
stove/page.tsx is ~200-250 LOC orchestrator that reuses useStoveData + useStoveCommands from StoveCard and renders 4 page-specific sub-components. All inline state management, effects, handlers, and verbose JSX removed. Visual output identical to pre-refactoring. Integration test passes.
  </done>
</task>

</tasks>

<verification>
1. `wc -l app/stove/page.tsx` â€” target < 250 LOC
2. `wc -l app/stove/components/*.tsx app/stove/stovePageTheme.ts` â€” each < 300 LOC
3. `npx tsc --noEmit` â€” no TypeScript errors
4. `npx jest --testPathPattern="stove|Stove" --no-coverage` â€” all stove tests pass
5. stove/page.tsx imports useStoveData + useStoveCommands from `@/app/components/devices/stove/hooks/`
6. stove/page.tsx has NO inline state declarations for stove data (only toast state)
7. stove/page.tsx renders same visual output as before (verify with `npm run dev` at localhost:3000/stove)
</verification>

<success_criteria>
- stove/page.tsx is < 250 LOC
- stove/page.tsx reuses useStoveData and useStoveCommands from StoveCard hooks (zero duplication)
- 4 page-specific sub-components created under app/stove/components/
- Theme utility extracted to app/stove/stovePageTheme.ts
- All existing stove tests still pass
- New integration test for StovePage passes
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/59-lightscard-page-refactoring/59-04-SUMMARY.md`
</output>
