---
phase: 60-critical-path-testing-token-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/services/tokenCleanupService.ts
  - lib/firebaseAdmin.ts
  - app/api/scheduler/check/route.ts
  - app/api/notifications/cleanup/route.ts
autonomous: true

must_haves:
  truths:
    - "Token cleanup logic lives in a single reusable service, not duplicated across routes"
    - "Successful FCM notification delivery updates lastUsed timestamp on the token"
    - "Token cleanup logs each deletion to Firebase audit trail"
    - "Active tokens with recent delivery timestamps are never deleted"
    - "Scheduler route and cleanup API route both delegate to the shared service"
  artifacts:
    - path: "lib/services/tokenCleanupService.ts"
      provides: "Extracted token cleanup logic with audit trail"
      exports: ["cleanupStaleTokens"]
    - path: "lib/firebaseAdmin.ts"
      provides: "lastUsed update after successful FCM delivery"
      contains: "lastUsed"
  key_links:
    - from: "app/api/scheduler/check/route.ts"
      to: "lib/services/tokenCleanupService.ts"
      via: "import cleanupStaleTokens"
      pattern: "import.*cleanupStaleTokens.*tokenCleanupService"
    - from: "app/api/notifications/cleanup/route.ts"
      to: "lib/services/tokenCleanupService.ts"
      via: "import cleanupStaleTokens"
      pattern: "import.*cleanupStaleTokens.*tokenCleanupService"
    - from: "lib/firebaseAdmin.ts"
      to: "users/{userId}/fcmTokens/{tokenKey}/lastUsed"
      via: "adminDbUpdate after successful messaging.send"
      pattern: "lastUsed.*new Date"
---

<objective>
Extract token cleanup logic to a shared service, add audit trail logging, and update lastUsed on successful FCM delivery.

Purpose: TOKEN-01 through TOKEN-04 require testable token cleanup with delivery-based staleness detection and audit trail. Currently, token cleanup is duplicated between the scheduler route (inline, lines 201-312) and /api/notifications/cleanup (standalone route). Neither updates lastUsed on delivery, and neither logs deletions for audit. Extracting to a service enables TDD testing in Plan 03.

Output: `lib/services/tokenCleanupService.ts` with `cleanupStaleTokens()`, updated `sendPushNotification` in `firebaseAdmin.ts` to update `lastUsed`, both routes refactored to use the service.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@app/api/scheduler/check/route.ts
@app/api/notifications/cleanup/route.ts
@lib/firebaseAdmin.ts
@lib/environmentHelper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tokenCleanupService and update lastUsed in sendPushNotification</name>
  <files>
    lib/services/tokenCleanupService.ts
    lib/firebaseAdmin.ts
  </files>
  <action>
**Create `lib/services/tokenCleanupService.ts`:**

Extract the token cleanup logic from scheduler route lines 201-312. The service function should:

```typescript
interface CleanupResult {
  cleaned: boolean;
  reason?: string;
  tokensScanned: number;
  tokensRemoved: number;
  errorsRemoved: number;
  deletedTokens: Array<{ userId: string; tokenKey: string; lastActivity: string | null; ageDays: number }>;
  nextCleanup?: string;
  timestamp?: number;
  error?: string;
}

export async function cleanupStaleTokens(): Promise<CleanupResult>
```

Key differences from current inline implementation:
1. **Audit trail (TOKEN-03):** Collect deleted token details in `deletedTokens` array. After batch deletion, log to Firebase at `tokenCleanupHistory/{ISO timestamp}` with: `{ timestamp, tokensScanned, tokensRemoved, errorsRemoved, deletedTokens }`.
2. **Use lastUsed for staleness (TOKEN-02):** Keep existing logic that checks `lastUsed || createdAt`, but now `lastUsed` will actually be updated by delivery (see below).
3. **Active token protection (TOKEN-04):** Keep 90-day STALE_THRESHOLD_MS. Tokens with `lastUsed` within 90 days are safe.
4. Use `getAdminDatabase()` and `adminDbSet()` from `@/lib/firebaseAdmin` (same as current).
5. Keep error log cleanup (30-day retention) in the same function.
6. Do NOT include the 7-day interval check logic (that stays in the caller).

Import `getEnvironmentPath` from `@/lib/environmentHelper` for the `lastCleanupPath`.

**Update `lib/firebaseAdmin.ts` - `sendPushNotification` function:**

After a successful `getMessaging().send()` call (around line 428 for single token, and in the multi-token success path), update `lastUsed` for successfully delivered tokens. Add a fire-and-forget update:

```typescript
// After successful single-token send (around line 428):
// Update lastUsed for successful delivery (fire-and-forget, TOKEN-02)
adminDbUpdate(`users/${userId}/fcmTokens`, {
  // Find the token key and update lastUsed
}).catch(() => {});
```

The challenge is that `sendPushNotification` receives raw token strings, not token keys. The function already has access to `userId`. Use `adminDbGet(`users/${userId}/fcmTokens`)` to look up the token key by matching the token string, then update `lastUsed` for that key. This lookup is already done at line 607 in `sendNotificationToUser`. To avoid a second fetch, add a helper function `updateTokenLastUsed(userId: string, tokenString: string)` that:
1. Gets `users/{userId}/fcmTokens`
2. Finds the entry where `.token === tokenString`
3. Updates `lastUsed` to `new Date().toISOString()` on that entry
4. Fire-and-forget (`.catch(() => {})`)

Call `updateTokenLastUsed` after successful send in both single-token and multi-token paths.
  </action>
  <verify>
- `lib/services/tokenCleanupService.ts` exists and exports `cleanupStaleTokens`
- `lib/firebaseAdmin.ts` contains `updateTokenLastUsed` function
- `npx tsc --noEmit` passes (no type errors)
  </verify>
  <done>
- tokenCleanupService exports cleanupStaleTokens with audit trail support
- sendPushNotification updates lastUsed after successful FCM delivery
- No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor scheduler route and cleanup API to use shared service</name>
  <files>
    app/api/scheduler/check/route.ts
    app/api/notifications/cleanup/route.ts
  </files>
  <action>
**Refactor `app/api/scheduler/check/route.ts`:**

1. Remove the inline `cleanupTokensIfNeeded()` function (lines 201-312).
2. Import `cleanupStaleTokens` from `@/lib/services/tokenCleanupService`.
3. Replace the `cleanupTokensIfNeeded()` call (line 941) with a new `cleanupTokensIfNeeded()` that wraps the service:

```typescript
async function cleanupTokensIfNeeded(): Promise<any> {
  try {
    const lastCleanupPath = getEnvironmentPath('cron/lastTokenCleanup');
    const lastCleanup = await adminDbGet(lastCleanupPath) as number | null;

    const now = Date.now();
    const SEVEN_DAYS = 7 * 24 * 60 * 60 * 1000;

    if (lastCleanup && (now - lastCleanup) < SEVEN_DAYS) {
      return { cleaned: false, reason: 'too_soon', nextCleanup: new Date(lastCleanup + SEVEN_DAYS).toISOString() };
    }

    const result = await cleanupStaleTokens();

    if (result.cleaned) {
      await adminDbSet(lastCleanupPath, now);
    }

    return result;
  } catch (error) {
    console.error('Errore cleanup token:', error);
    return { cleaned: false, reason: 'exception', error: error instanceof Error ? error.message : 'Unknown error' };
  }
}
```

This keeps the 7-day interval check in the scheduler (TOKEN-01: cron schedule) while delegating actual cleanup to the service.

**Refactor `app/api/notifications/cleanup/route.ts`:**

1. Import `cleanupStaleTokens` from `@/lib/services/tokenCleanupService`.
2. Replace the inline token scanning logic (lines 85-145) with:
```typescript
const result = await cleanupStaleTokens();
```
3. Map the result to the existing response format: `{ success: true, removed: result.tokensRemoved, scanned: result.tokensScanned, errorsRemoved: result.errorsRemoved, timestamp }`.
4. Keep the auth check (Bearer token) and GET health check as-is.
  </action>
  <verify>
- `app/api/scheduler/check/route.ts` no longer contains inline token scanning logic (no `usersRef.once('value')` for cleanup)
- `app/api/scheduler/check/route.ts` imports from `@/lib/services/tokenCleanupService`
- `app/api/notifications/cleanup/route.ts` imports from `@/lib/services/tokenCleanupService`
- `npx tsc --noEmit` passes
  </verify>
  <done>
- Both routes delegate to shared tokenCleanupService
- 7-day interval check remains in scheduler route
- Cleanup API route simplified to service call + auth
- No TypeScript errors
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `grep -r "cleanupStaleTokens" lib/services/ app/api/scheduler/ app/api/notifications/cleanup/` shows imports in both routes
3. `grep "tokenCleanupHistory" lib/services/tokenCleanupService.ts` confirms audit trail
4. `grep "updateTokenLastUsed" lib/firebaseAdmin.ts` confirms lastUsed update
</verification>

<success_criteria>
- Token cleanup logic exists in exactly one place (lib/services/tokenCleanupService.ts)
- Both consumer routes (scheduler/check, notifications/cleanup) import and use the service
- Audit trail logs deleted tokens to Firebase tokenCleanupHistory path
- FCM delivery success updates lastUsed timestamp on the token record
- All TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/60-critical-path-testing-token-cleanup/60-01-SUMMARY.md`
</output>
