---
phase: 60-critical-path-testing-token-cleanup
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/scheduler/check/__tests__/route.test.ts
autonomous: true

must_haves:
  truths:
    - "Scheduler check route has unit tests for all three modes (manual, semi-manual, automatic)"
    - "Tests cover early returns: no schedule, status unavailable, maintenance required"
    - "Tests verify fetchStoveData handles API failures with safe defaults"
    - "All mocks are established for 15+ external dependencies"
  artifacts:
    - path: "app/api/scheduler/check/__tests__/route.test.ts"
      provides: "Comprehensive test file for scheduler check route - modes and early returns"
      contains: "describe.*Scheduler.*Check"
  key_links:
    - from: "app/api/scheduler/check/__tests__/route.test.ts"
      to: "app/api/scheduler/check/route.ts"
      via: "import { GET } from '../route'"
      pattern: "import.*GET.*from.*route"
---

<objective>
Create comprehensive unit tests for /api/scheduler/check covering all scheduler modes and early return paths.

Purpose: TEST-01 requires unit tests covering all execution paths. This plan establishes the test file with mock setup for all 15+ dependencies and covers the first half of execution paths: scheduler modes (manual returns early, semi-manual with time check, automatic proceeds), early returns (no schedule found, status unavailable safety check, maintenance blocks ignition), and stove data fetching (parallel API calls, null handling, default values). Plan 04 will add state transition and error scenario tests on top of this foundation.

Output: `app/api/scheduler/check/__tests__/route.test.ts` with ~25 test cases covering modes and early returns.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@app/api/scheduler/check/route.ts
@lib/core/middleware.ts
@lib/__tests__/schedulerService.test.ts
@lib/retry/__tests__/idempotencyManager.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test file with mock setup and scheduler mode tests</name>
  <files>app/api/scheduler/check/__tests__/route.test.ts</files>
  <action>
Create `app/api/scheduler/check/__tests__/route.test.ts`.

**Mock Setup (must be BEFORE imports):**

Mock ALL external dependencies. Use `jest.mock()` at top of file:

```typescript
// Mock ALL external dependencies BEFORE importing route
jest.mock('@/lib/firebaseAdmin');
jest.mock('@/lib/maintenanceServiceAdmin');
jest.mock('@/lib/environmentHelper');
jest.mock('@/lib/services/pidTuningLogService');
jest.mock('@/lib/notificationTriggersServer');
jest.mock('@/lib/stoveApi');
jest.mock('@/lib/stoveStateService');
jest.mock('@/lib/netatmoStoveSync');
jest.mock('@/lib/netatmoCalibrationService');
jest.mock('@/lib/hue/hueRemoteTokenHelper');
jest.mock('@/lib/openMeteo');
jest.mock('@/lib/weatherCacheService');
jest.mock('@/lib/utils/pidController');
jest.mock('@/lib/cronExecutionLogger');
jest.mock('@/lib/analyticsEventLogger');
// Note: Plan 01 may add tokenCleanupService import - mock it too:
jest.mock('@/lib/services/tokenCleanupService', () => ({
  cleanupStaleTokens: jest.fn().mockResolvedValue({ cleaned: false, reason: 'mocked', tokensScanned: 0, tokensRemoved: 0, errorsRemoved: 0, deletedTokens: [] }),
}));
```

After mocks, import the route and all mocked modules:

```typescript
import { GET } from '../route';
import { adminDbGet, adminDbSet, adminDbUpdate, getAdminDatabase } from '@/lib/firebaseAdmin';
import { canIgnite, trackUsageHours } from '@/lib/maintenanceServiceAdmin';
import { getEnvironmentPath } from '@/lib/environmentHelper';
import { getStoveStatus, getFanLevel, getPowerLevel, igniteStove, shutdownStove, setPowerLevel, setFanLevel } from '@/lib/stoveApi';
// ... etc
```

Create typed mock references using `jest.mocked()`:

```typescript
const mockAdminDbGet = jest.mocked(adminDbGet);
const mockAdminDbSet = jest.mocked(adminDbSet);
const mockGetStoveStatus = jest.mocked(getStoveStatus);
// ... etc for all used mocks
```

**Environment setup in beforeEach:**
```typescript
beforeEach(() => {
  jest.clearAllMocks();
  process.env.CRON_SECRET = 'test-secret';
  process.env.ADMIN_USER_ID = 'admin-test-user';

  // Mock console methods
  jest.spyOn(console, 'log').mockImplementation(() => {});
  jest.spyOn(console, 'error').mockImplementation(() => {});
  jest.spyOn(console, 'warn').mockImplementation(() => {});

  // Mock getEnvironmentPath to return path as-is
  jest.mocked(getEnvironmentPath).mockImplementation((path: string) => path);

  // Mock logCronExecution as fire-and-forget
  jest.mocked(logCronExecution).mockResolvedValue(undefined as any);

  // Mock logAnalyticsEvent as fire-and-forget
  jest.mocked(logAnalyticsEvent).mockResolvedValue(undefined as any);

  // Default stove data mocks (happy path)
  mockGetStoveStatus.mockResolvedValue({ StatusDescription: 'Spento', Result: 0 } as any);
  jest.mocked(getFanLevel).mockResolvedValue({ Result: 3 } as any);
  jest.mocked(getPowerLevel).mockResolvedValue({ Result: 2 } as any);

  // Default maintenance mock
  jest.mocked(trackUsageHours).mockResolvedValue({ tracked: false } as any);
  jest.mocked(canIgnite).mockResolvedValue(true);

  // Default Netatmo sync mocks
  jest.mocked(enforceStoveSyncSetpoints).mockResolvedValue({ enforced: false, synced: false } as any);
  jest.mocked(syncLivingRoomWithStove).mockResolvedValue({ synced: false } as any);

  // Default fire-and-forget mocks
  jest.mocked(calibrateValvesServer).mockResolvedValue({ calibrated: false } as any);
  jest.mocked(proactiveTokenRefresh).mockResolvedValue({ refreshed: false } as any);

  // Default notification mocks
  jest.mocked(triggerSchedulerActionServer).mockResolvedValue({ success: true, skipped: false } as any);
  jest.mocked(triggerMaintenanceAlertServer).mockResolvedValue({ success: true, skipped: false } as any);
  jest.mocked(triggerStoveStatusWorkServer).mockResolvedValue({ success: true } as any);
  jest.mocked(triggerStoveUnexpectedOffServer).mockResolvedValue({ success: true } as any);
});
```

**Helper function for creating mock requests:**
```typescript
function createMockRequest(): Request {
  return new Request('http://localhost/api/scheduler/check?secret=test-secret');
}
```

**Helper to parse JSON response:**
```typescript
async function getResponseData(response: Response): Promise<any> {
  return response.json();
}
```

**Test describe blocks:**

**1. `describe('Scheduler Modes')` — TEST-02:**

- `it('returns MODALITA_MANUALE when scheduler is disabled')` — Mock `adminDbGet` for `schedules-v2/mode` to return `{ enabled: false, semiManual: false }`. Verify response status 200, body contains `status: 'MODALITA_MANUALE'`. Verify `logCronExecution` called with `mode: 'manual'`.

- `it('returns MODALITA_SEMI_MANUALE when in semi-manual before returnToAutoAt')` — Mock mode as `{ enabled: true, semiManual: true, returnToAutoAt: futureISO }`. Verify response contains `status: 'MODALITA_SEMI_MANUALE'` and `returnToAutoAt`.

- `it('proceeds to automatic when semi-manual but returnToAutoAt has passed')` — Mock mode as `{ enabled: true, semiManual: true, returnToAutoAt: pastISO }`. Mock schedule data to exist. Verify response does NOT have `MODALITA_SEMI_MANUALE`.

- `it('proceeds to automatic when semi-manual but returnToAutoAt is null')` — Edge case where returnToAutoAt is not set. Verify semi-manual behavior (stays in semi-manual).

- `it('proceeds normally when scheduler is enabled and not semi-manual')` — Mock mode `{ enabled: true, semiManual: false }`. Mock schedule data. Verify reaches schedule processing.

**2. `describe('Schedule Lookup')` — TEST-01:**

- `it('returns NO_SCHEDULE when no intervals exist for today')` — Mock `adminDbGet` for schedule slots to return `null`. Verify response message contains 'Nessuno scheduler'.

- `it('finds active schedule when current time falls within interval')` — Mock time to 19:00 Rome, intervals with 18:00-22:00. Verify `activeSchedule` in response is not null.

- `it('finds no active schedule when current time is outside all intervals')` — Mock time to 08:00 Rome, intervals only at 18:00-22:00. Verify stove is not ignited when already off (shutdown not called since stove already off per default mock).

**3. `describe('Stove Data Fetching')` — TEST-01, TEST-03:**

- `it('fetches status, fan, and power in parallel')` — Verify all three API functions called.

- `it('handles status fetch failure with safe defaults')` — Mock `getStoveStatus` to reject. Verify `statusFetchFailed` behavior: when active schedule exists and stove appears off, returns `STATUS_UNAVAILABLE` (safety skip). Verify `igniteStove` NOT called.

- `it('uses default fan level (3) when getFanLevel returns null')` — Mock `getFanLevel` to resolve with `null`. Verify no crash, processing continues.

- `it('uses default power level (2) when getPowerLevel returns null')` — Mock `getPowerLevel` to resolve with `null`. Verify no crash.

- `it('detects stove as ON when status includes WORK')` — Mock status `{ StatusDescription: 'WORK 1' }`. Verify no ignition attempt when schedule is active.

- `it('detects stove as ON when status includes START')` — Mock status `{ StatusDescription: 'START' }`. Similar verification.

For the `adminDbGet` mock, use `mockResolvedValueOnce` in sequence to simulate the multiple Firebase reads the route does:
1. First call: `schedules-v2/mode` → mode data
2. Second call: `cronHealth/lastCall` is SET not GET (via adminDbSet)
3. After mode checks: `schedules-v2/activeScheduleId` → 'default'
4. Then: `schedules-v2/schedules/default/slots/{day}` → intervals

**Important**: The route calls `adminDbSet('cronHealth/lastCall', ...)` first, then reads mode. Use ordered `mockResolvedValueOnce` carefully. Consider a helper that sets up the mock chain:

```typescript
function setupSchedulerMocks(options: {
  mode?: { enabled: boolean; semiManual: boolean; returnToAutoAt?: string };
  intervals?: any[] | null;
  activeScheduleId?: string;
}) {
  // adminDbGet calls in order:
  // 1. schedules-v2/mode
  mockAdminDbGet.mockResolvedValueOnce(options.mode ?? { enabled: true, semiManual: false });
  // 2. schedules-v2/activeScheduleId
  mockAdminDbGet.mockResolvedValueOnce(options.activeScheduleId ?? 'default');
  // 3. schedules-v2/schedules/{id}/slots/{day}
  mockAdminDbGet.mockResolvedValueOnce(options.intervals ?? null);

  // adminDbSet for cronHealth is fine (already mocked)
  mockAdminDbSet.mockResolvedValue(undefined as any);
}
```

All tests should verify response is 200 (withCronSecret passes due to `?secret=test-secret` and `CRON_SECRET=test-secret`).
  </action>
  <verify>
Run: `npx jest app/api/scheduler/check/__tests__/route.test.ts --no-coverage`
All tests pass.
  </verify>
  <done>
- Test file exists with proper mock setup for all 15+ dependencies
- Scheduler mode tests cover manual, semi-manual (before/after returnToAutoAt), and automatic
- Early return tests cover no schedule, status unavailable safety check
- Stove data fetch tests cover null handling and defaults
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cron health, fire-and-forget side effects, and maintenance tests</name>
  <files>app/api/scheduler/check/__tests__/route.test.ts</files>
  <action>
Add the following test blocks to the existing test file:

**4. `describe('Cron Health Tracking')`:**

- `it('saves cronHealth/lastCall timestamp on every invocation')` — Verify `adminDbSet` called with `'cronHealth/lastCall'` and an ISO timestamp string. This happens before any other logic.

**5. `describe('Fire-and-Forget Side Effects')`:**

- `it('triggers stove status WORK notification when status includes WORK')` — Mock stove status as 'WORK 1', mock mode enabled, mock active schedule. Verify `triggerStoveStatusWorkServer` is called (but don't await its result — it's fire-and-forget).

- `it('does not trigger WORK notification when status is not WORK')` — Mock status 'Spento'. Verify `triggerStoveStatusWorkServer` not called (it should check internally, but verify the outer call is made and the function internally guards).

- `it('calls calibrateValvesIfNeeded as fire-and-forget')` — Verify `calibrateValvesServer` is called (it's invoked via the internal wrapper).

Actually, since `calibrateValvesIfNeeded` is an internal function that calls the mocked `calibrateValvesServer`, we verify the external mock is called. Same for weather refresh, token cleanup, and Hue token refresh.

- `it('calls proactiveTokenRefresh as fire-and-forget')` — Verify mock called.

- `it('tracks maintenance hours')` — Verify `trackUsageHours` called with current status string.

- `it('sends maintenance notification when notificationData present')` — Mock `trackUsageHours` to return `{ tracked: true, notificationData: { notificationLevel: 90, percentage: 90, remainingHours: 5 } }`. Verify `triggerMaintenanceAlertServer` called.

- `it('calls enforceStoveSyncSetpoints')` — Verify Netatmo sync enforcement called with `isOn` value.

**6. `describe('Maintenance Blocks Ignition')` — TEST-03:**

- `it('returns MANUTENZIONE_RICHIESTA when canIgnite returns false')` — Mock active schedule, stove OFF, `canIgnite` returns `false`. Verify response status is `'MANUTENZIONE_RICHIESTA'`. Verify `igniteStove` NOT called.

- `it('proceeds to ignition when canIgnite returns true')` — Mock active schedule, stove OFF, `canIgnite` returns `true`. Set up ignition mocks. Verify `igniteStove` IS called.

**7. `describe('Unexpected Off Detection')`:**

- `it('does not notify when stove is on during active schedule')` — Verify `triggerStoveUnexpectedOffServer` not called.

- `it('does not notify when no active schedule')` — Verify no unexpected off notification.

For the cron health test, verify using:
```typescript
expect(mockAdminDbSet).toHaveBeenCalledWith('cronHealth/lastCall', expect.any(String));
```
  </action>
  <verify>
Run: `npx jest app/api/scheduler/check/__tests__/route.test.ts --no-coverage`
All tests (including Task 1 tests) pass.
  </verify>
  <done>
- Cron health tracking verified
- Fire-and-forget side effects verified (notifications, calibration, weather, token cleanup, Hue refresh)
- Maintenance blocking ignition tested
- Unexpected off detection tested
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. `npx jest app/api/scheduler/check/__tests__/route.test.ts --no-coverage` — all tests pass
2. Test file has at least 15 test cases covering modes, early returns, side effects
3. Mock setup covers all external dependencies (no real API calls or Firebase access)
</verification>

<success_criteria>
- Test file exists at app/api/scheduler/check/__tests__/route.test.ts
- All scheduler modes tested (manual, semi-manual, automatic)
- Early returns tested (no schedule, status unavailable, maintenance required)
- Stove data fetch error handling tested
- Fire-and-forget side effects verified
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/60-critical-path-testing-token-cleanup/60-02-SUMMARY.md`
</output>
