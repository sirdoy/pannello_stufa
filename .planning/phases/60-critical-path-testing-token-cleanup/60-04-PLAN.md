---
phase: 60-critical-path-testing-token-cleanup
plan: 04
type: execute
wave: 2
depends_on: ["60-01", "60-02"]
files_modified:
  - app/api/scheduler/check/__tests__/route.test.ts
autonomous: true

must_haves:
  truths:
    - "Tests cover OFF to START state transition via ignition"
    - "Tests cover active schedule with stove already on (level adjustments)"
    - "Tests cover shutdown when stove is on but no active schedule"
    - "Tests cover error scenarios: API timeout, confirmation failure"
    - "Tests verify PID automation is invoked when stove is in WORK state"
    - "Tests verify semi-manual to automatic transition after change applied"
    - "Scheduler route achieves 80%+ branch coverage"
  artifacts:
    - path: "app/api/scheduler/check/__tests__/route.test.ts"
      provides: "Complete test coverage for scheduler check route"
      contains: "describe.*State Transitions"
  key_links:
    - from: "app/api/scheduler/check/__tests__/route.test.ts"
      to: "app/api/scheduler/check/route.ts"
      via: "full branch coverage verification"
      pattern: "coverage.*branch"
---

<objective>
Add state transition tests, error scenario tests, and verify 80%+ branch coverage for the scheduler check route.

Purpose: TEST-02 (state transitions OFF/START/WORK), TEST-03 (error scenarios), and TEST-04 (80%+ branch coverage) complete the scheduler testing requirements. Plan 02 covered modes and early returns; this plan covers the core scheduler logic: ignition flow, shutdown flow, level adjustments, PID automation mocking, and edge cases needed to reach the coverage target.

Output: Extended `app/api/scheduler/check/__tests__/route.test.ts` with ~20 additional test cases, total 80%+ branch coverage.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/60-critical-path-testing-token-cleanup/60-02-SUMMARY.md
@app/api/scheduler/check/route.ts
@app/api/scheduler/check/__tests__/route.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add state transition and ignition tests</name>
  <files>app/api/scheduler/check/__tests__/route.test.ts</files>
  <action>
Add the following test blocks to the existing test file created in Plan 02.

**8. `describe('State Transitions - Ignition')` — TEST-02:**

All ignition tests need: mode enabled, active schedule matching current time, stove status OFF, maintenance allowed.

Use the `setupSchedulerMocks` helper from Plan 02, extending it as needed for additional `adminDbGet` calls (e.g., PID boost state, ignition tracking).

- `it('ignites stove when schedule is active and stove is OFF')` — Mock stove OFF (`StatusDescription: 'Spento'`), active schedule `{ start: matching, end: future, power: 4, fan: 3 }`, `canIgnite` true. Mock `getStoveStatus` to return OFF on first call (fetchStoveData) and OFF again on second call (handleIgnition confirmation). Mock `igniteStove` to resolve successfully. Verify:
  - `igniteStove` called with power level `4`
  - `updateStoveState` called with `{ status: 'START', source: 'scheduler' }`
  - `triggerSchedulerActionServer` called with `'ignition'`
  - `syncLivingRoomWithStove` called with `true`
  - Response status is `'ACCESA'`

- `it('skips ignition when confirmation status shows stove already ON (ALREADY_ON race condition)')` — First `getStoveStatus` returns OFF, second returns `'WORK 1'` (changed between fetch and confirm). Verify `igniteStove` NOT called. Verify response status `'ALREADY_ON'`.

- `it('skips ignition when confirmation status fetch fails (CONFIRMATION_FAILED)')` — First `getStoveStatus` returns OFF, second rejects with error. Verify `igniteStove` NOT called. Response status `'CONFIRMATION_FAILED'`.

- `it('tracks ignition interval for unexpected off detection')` — After successful ignition, verify `adminDbSet` called with `'scheduler/lastIgnitionInterval'` containing the active interval string.

- `it('logs analytics event on successful ignition')` — Verify `logAnalyticsEvent` called with `{ eventType: 'stove_ignite', source: 'scheduler' }`.

**9. `describe('State Transitions - Shutdown')` — TEST-02:**

- `it('shuts down stove when no active schedule and stove is ON')` — Mock stove ON (`'WORK 1'`), no active schedule (current time outside all intervals). Verify:
  - `shutdownStove` called
  - `updateStoveState` called with `{ status: 'STANDBY', source: 'scheduler' }`
  - `triggerSchedulerActionServer` called with `'shutdown'`
  - `syncLivingRoomWithStove` called with `false`

- `it('does not shutdown when no active schedule and stove already OFF')` — Mock stove OFF, no active schedule. Verify `shutdownStove` NOT called.

- `it('logs analytics event on successful shutdown')` — Verify `logAnalyticsEvent` called with `{ eventType: 'stove_shutdown', source: 'scheduler' }`.

**10. `describe('Level Adjustments')` — TEST-02:**

- `it('adjusts power level when schedule power differs from current')` — Mock stove ON at power 2, active schedule with power 4. Verify `setPowerLevel(4)` called.

- `it('adjusts fan level when schedule fan differs from current')` — Mock stove ON at fan 2, active schedule with fan 4. Verify `setFanLevel(4)` called.

- `it('skips power adjustment when PID boost is active')` — Mock `adminDbGet` for `pidAutomation/boost` to return `{ active: true, powerLevel: 3 }`. Verify `setPowerLevel` NOT called for scheduled power change. Fan adjustment should still proceed.

- `it('does not adjust levels when already matching schedule')` — Mock stove at power 4 fan 3, schedule power 4 fan 3. Verify neither `setPowerLevel` nor `setFanLevel` called.

For level adjustment tests, the stove needs to be ON and within an active schedule. The `adminDbGet` mock chain will need additional calls for PID boost state. Use `mockResolvedValueOnce` carefully or switch to a more flexible mock approach if needed:

```typescript
// Flexible mock approach for tests needing many adminDbGet calls:
mockAdminDbGet.mockImplementation((path: string) => {
  if (path === 'schedules-v2/mode') return Promise.resolve({ enabled: true, semiManual: false });
  if (path === 'schedules-v2/activeScheduleId') return Promise.resolve('default');
  if (path.includes('slots/')) return Promise.resolve([{ start: '18:00', end: '22:00', power: 4, fan: 3 }]);
  if (path.includes('pidAutomation/boost')) return Promise.resolve({ active: false });
  if (path.includes('pidAutomation')) return Promise.resolve(null);
  return Promise.resolve(null);
});
```

This approach is more maintainable for complex tests.
  </action>
  <verify>
Run: `npx jest app/api/scheduler/check/__tests__/route.test.ts --no-coverage`
All tests pass (including Plan 02 tests).
  </verify>
  <done>
- Ignition state transition tested (OFF to START, including confirmation checks)
- Shutdown state transition tested (WORK to STANDBY)
- Level adjustment tested (power, fan, PID boost skip)
- Race condition handling tested (ALREADY_ON, CONFIRMATION_FAILED)
- All tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add error scenarios, PID tests, and verify 80%+ branch coverage</name>
  <files>app/api/scheduler/check/__tests__/route.test.ts</files>
  <action>
Add the following test blocks and then run coverage to verify 80%+ target.

**11. `describe('Error Scenarios')` — TEST-03:**

- `it('handles igniteStove failure gracefully')` — Mock `igniteStove` to reject with Error. Verify response is still 200 (the route catches errors internally). Verify `igniteStove` was called but failure logged.

- `it('handles shutdownStove failure gracefully')` — Mock `shutdownStove` to reject. Verify response is 200, failure logged.

- `it('handles setPowerLevel failure without crashing')` — Mock `setPowerLevel` to reject. Verify other operations (fan level, etc.) still proceed.

- `it('handles setFanLevel failure without crashing')` — Mock `setFanLevel` to reject. Verify response still succeeds.

- `it('handles enforceStoveSyncSetpoints error gracefully')` — Mock to reject. Verify response still succeeds (caught in try/catch).

**12. `describe('PID Automation')` — TEST-01:**

PID automation (`runPidAutomationIfEnabled`) is complex but called from the main handler. We only need to verify it's called with correct arguments and doesn't block the response. The internal PID logic is tested separately.

- `it('invokes PID automation when stove is in WORK state during active schedule')` — Mock stove WORK, active schedule, mode enabled. Mock `adminDbGet` for PID config to return `{ enabled: true, targetRoomId: '123', kp: 0.5, ki: 0.1, kd: 0.05, manualSetpoint: 21 }`. Mock Netatmo status with rooms. Mock `PIDController` constructor and `compute` method. Verify PID-related `adminDbGet` calls are made for config and state.

- `it('skips PID when stove is not in WORK state')` — Mock stove in START. Verify PID automation skips (check adminDbSet for pidBoost `{ active: false }`).

- `it('skips PID when scheduler is in semi-manual mode')` — Verify PID automation skips.

- `it('skips PID when PID config is disabled')` — Mock PID config as `{ enabled: false }`. Verify skips.

For PID tests, mock the `PIDController` class:
```typescript
// At the top with other mocks:
jest.mock('@/lib/utils/pidController', () => ({
  PIDController: jest.fn().mockImplementation(() => ({
    compute: jest.fn().mockReturnValue(3),
    setState: jest.fn(),
    getState: jest.fn().mockReturnValue({ integral: 0, prevError: 0, initialized: true }),
  })),
}));
```

**13. `describe('Semi-Manual to Automatic Transition')`:**

- `it('clears semi-manual mode when change is applied during semi-manual')` — Mock mode as `{ enabled: true, semiManual: true, returnToAutoAt: pastISO }` (so it proceeds past semi-manual check). Active schedule, stove OFF, ignition succeeds. Verify `adminDbSet('schedules-v2/mode', ...)` called with `semiManual: false`.

- `it('does not clear semi-manual mode when no change applied')` — Mock semi-manual expired, but stove already at correct state. Verify mode not updated.

**14. `describe('Response Structure')`:**

- `it('includes giorno and ora in response for active schedule')` — Verify response body has `giorno` (Italian day name), `ora` (HH:MM format).

- `it('includes activeSchedule in response when schedule is active')` — Verify response has `activeSchedule` with `start`, `end`, `power`, `fan`.

- `it('logs cron execution at the end')` — Verify `logCronExecution` called with `status: 'ACCESA'` or `'SPENTA'` and `duration` >= 0.

**Coverage Verification:**

After all tests pass, run coverage:
```bash
npx jest app/api/scheduler/check/__tests__/route.test.ts --coverage --collectCoverageFrom='app/api/scheduler/check/route.ts'
```

Review the coverage output. If branch coverage is below 80%, identify uncovered branches from the coverage report and add targeted tests. Common uncovered branches:
- Error path in `sendSchedulerNotification` (missing ADMIN_USER_ID)
- Various null checks in helper functions
- Edge cases in time parsing (midnight crossover)
- PID automation branches (no Netatmo data, invalid setpoint, etc.)

Add tests for any uncovered critical branches until 80%+ achieved. Priority branches to cover:
- `sendSchedulerNotification` without ADMIN_USER_ID → early return
- `sendMaintenanceNotificationIfNeeded` at different thresholds (100, 90, else)
- `sendStoveStatusWorkNotification` cooldown check
- `checkAndNotifyUnexpectedOff` various skip conditions
  </action>
  <verify>
Run: `npx jest app/api/scheduler/check/__tests__/route.test.ts --coverage --collectCoverageFrom='app/api/scheduler/check/route.ts'`
Verify: Branch coverage >= 80% in the output.
All tests pass.
  </verify>
  <done>
- Error scenarios tested (ignition, shutdown, power, fan, sync failures)
- PID automation tested (invoked when WORK, skipped when not applicable)
- Semi-manual to automatic transition tested
- Response structure verified
- Branch coverage >= 80% on route.ts confirmed by Jest coverage report
- All tests pass
  </done>
</task>

</tasks>

<verification>
1. `npx jest app/api/scheduler/check/__tests__/route.test.ts --coverage --collectCoverageFrom='app/api/scheduler/check/route.ts'` — all tests pass, branch coverage >= 80%
2. Test file has 35+ test cases total (Plan 02 + Plan 04)
3. State transitions: OFF → START (ignition), WORK → STANDBY (shutdown), level adjustments
4. Error scenarios: API timeout, confirmation failure, power/fan set failure
5. PID automation: invoked correctly, skipped when appropriate
</verification>

<success_criteria>
- All state transition paths tested (OFF/START/WORK)
- All error scenarios tested (API failures, confirmation failures)
- PID automation integration tested
- Semi-manual mode transition tested
- Branch coverage >= 80% on scheduler check route.ts confirmed
- Total test count: 35+ across Plan 02 and Plan 04
</success_criteria>

<output>
After completion, create `.planning/phases/60-critical-path-testing-token-cleanup/60-04-SUMMARY.md`
</output>
