---
phase: 60-critical-path-testing-token-cleanup
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/scheduler/check/__tests__/route.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Scheduler route achieves 80%+ branch coverage per Jest coverage report"
    - "All 63 existing tests still pass after adding new tests"
    - "Fire-and-forget helper function branches are tested (calibration, weather, cleanup, notifications)"
  artifacts:
    - path: "app/api/scheduler/check/__tests__/route.test.ts"
      provides: "Extended tests reaching fire-and-forget helper internals"
      min_lines: 2200
  key_links:
    - from: "app/api/scheduler/check/__tests__/route.test.ts"
      to: "app/api/scheduler/check/route.ts"
      via: "import GET, mock dependencies"
      pattern: "import.*GET.*from.*route"
---

<objective>
Close the TEST-04 gap: raise scheduler check route branch coverage from 67.15% to 80%+ by testing fire-and-forget helper function branches and main route catch blocks.

Purpose: The verification found 67.15% branch coverage (below 80% target). The uncovered 33% is in fire-and-forget helper functions (calibrateValvesIfNeeded, refreshWeatherIfNeeded, cleanupTokensIfNeeded, sendStoveStatusWorkNotification, checkAndNotifyUnexpectedOff, runPidAutomationIfEnabled internals) and main route catch blocks. These functions ARE invoked synchronously by the route handler — their internal branches can be covered by carefully configuring mock return values so the functions take different code paths, then flushing microtasks so promises settle within the test.

Output: Extended route.test.ts with ~25-30 additional tests covering helper function branches, achieving 80%+ branch coverage.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/60-critical-path-testing-token-cleanup/60-VERIFICATION.md
@.planning/phases/60-critical-path-testing-token-cleanup/60-04-SUMMARY.md
@app/api/scheduler/check/route.ts
@app/api/scheduler/check/__tests__/route.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test fire-and-forget helper function branches via microtask flushing</name>
  <files>app/api/scheduler/check/__tests__/route.test.ts</files>
  <action>
Add new test describe blocks to route.test.ts that cover the uncovered branches in fire-and-forget helper functions. The key technique is:

1. **Microtask flushing:** After `await GET(request)`, add `await new Promise(resolve => setImmediate(resolve))` (or `await new Promise(r => setTimeout(r, 0))`) to let fire-and-forget promises settle. This allows mock assertions on internal function calls.

2. **Target the following uncovered helper branches (by route.ts line number):**

**calibrateValvesIfNeeded (lines 93-134):**
- Test "too_soon" branch: Mock `lastCalibration` to a recent timestamp (within 12 hours). Verify calibrateValvesServer is NOT called. Set up mock via `setupSchedulerMocks` or `mockAdminDbGet.mockImplementation` with `lastAutoCalibration` path returning `Date.now() - 1000`.
- Test successful calibration: Mock `lastCalibration` as null (already default), mock `calibrateValvesServer` to return `{ calibrated: true }`. Verify `adminDbSet` called with calibration timestamp.
- Test failed calibration: Mock `calibrateValvesServer` to return `{ calibrated: false, error: 'No valves' }`. Verify console.error called with calibration error message.
- Test exception branch: Mock `calibrateValvesServer` to reject. The `.catch()` on the fire-and-forget handles it — verify console.error called.

**refreshWeatherIfNeeded (lines 140-196):**
- Test "too_soon" branch: Mock `lastWeatherRefresh` to recent timestamp (within 30 min). Verify `fetchWeatherForecast` NOT called.
- Test "no_location" branch: Mock `lastWeatherRefresh` as null, mock `config/location` path to return null. Verify console.warn called with "location not configured".
- Test successful refresh: Mock location present, mock `fetchWeatherForecast` to return weather data, mock `saveWeatherToCache` to resolve. Verify `adminDbSet` called with refresh timestamp.
- Test exception branch: Mock `fetchWeatherForecast` to reject. Verify console.error with "weather" message.

**cleanupTokensIfNeeded (lines 202-235):**
- Test "too_soon" branch: Mock `lastTokenCleanup` to recent timestamp (within 7 days). Verify `cleanupStaleTokens` NOT called.
- Test successful cleanup: Mock `lastTokenCleanup` as null, mock `cleanupStaleTokens` to return `{ cleaned: true }`. Verify `adminDbSet` called with cleanup timestamp.
- Test cleanup returns cleaned:false: Mock `cleanupStaleTokens` to return `{ cleaned: false }`. Verify `adminDbSet` NOT called for lastTokenCleanup path.

**sendMaintenanceNotificationIfNeeded (lines 240-277):**
Already partially tested but uncovered branches:
- Test when notification result is `{ skipped: true }` (line 269): Mock `triggerMaintenanceAlertServer` to return `{ skipped: true, success: false }`. Verify no error logged.
- Test when notification result is `{ success: false, error: 'Rate limited' }` (line 271): Mock trigger to return `{ success: false, error: 'Rate limited' }`. Verify console.error called.
- Test exception branch (line 274-275): Mock `triggerMaintenanceAlertServer` to reject. Verify console.error with "manutenzione" message.

**sendStoveStatusWorkNotification (lines 284-313):**
- Test successful notification: Mock stove as WORK, mock `lastWorkNotification` as null (past cooldown), mock `triggerStoveStatusWorkServer` to resolve. Verify `adminDbSet` called to save notification timestamp.
- Test error branch (line 311): Mock `triggerStoveStatusWorkServer` to reject. Verify console.error with "stove_status_work" message.
- Test non-WORK status: Mock stove as "START" — verify `triggerStoveStatusWorkServer` NOT called.

**checkAndNotifyUnexpectedOff (lines 320-359):**
- Test successful unexpected off notification saving timestamp (line 354): Already partially tested, but verify `adminDbSet` called with `lastUnexpectedOffNotification` path.
- Test error branch (line 357): Mock `triggerStoveUnexpectedOffServer` to reject. Verify console.error with "stove_unexpected_off" message.
- Test no previous ignition tracked (line 332): Active schedule, stove off, but no `lastIgnitionInterval` in Firebase. Verify notification NOT sent.

**sendSchedulerNotification (lines 64-91):**
- Test skipped result (line 82): Mock `triggerSchedulerActionServer` to return `{ skipped: true }`. No console.error expected.
- Test error result (line 85): Mock `triggerSchedulerActionServer` to return `{ success: false, error: 'Failed' }`. Verify console.error.
- Test exception (line 88-89): Mock `triggerSchedulerActionServer` to reject. Verify console.error.

**Implementation notes:**
- Add a helper function `flushPromises` at the top of the test file: `const flushPromises = () => new Promise(resolve => setImmediate(resolve));`
- After `await GET(request)`, call `await flushPromises()` to let fire-and-forget promises settle before asserting on mock calls.
- Use `jest.useFakeTimers()` and `jest.advanceTimersByTime(0)` combined with manual promise flushing when needed.
- For fire-and-forget functions that read from `adminDbGet`, configure the mock implementation to return specific values for the helper's Firebase paths (e.g., `netatmo/lastAutoCalibration`, `cron/lastWeatherRefresh`, `cron/lastTokenCleanup`, `config/location`, `scheduler/lastWorkNotification`).
- The `mockAdminDbGet.mockImplementation` in `setupSchedulerMocks` already handles many paths — extend it with additional path handlers for helper-specific reads.
- Keep each test focused: one uncovered branch per test. Name tests descriptively.
- CRITICAL: Do NOT modify any existing tests. Only ADD new describe blocks.
  </action>
  <verify>
Run: `npx jest app/api/scheduler/check/__tests__/route.test.ts` — all tests pass (63 existing + new tests).
Run: `npx jest --coverage --collectCoverageFrom='app/api/scheduler/check/route.ts' app/api/scheduler/check/__tests__/route.test.ts` — check branch coverage has increased from 67.15%.
  </verify>
  <done>New tests pass, existing 63 tests still pass, branch coverage has increased significantly toward 80%.</done>
</task>

<task type="auto">
  <name>Task 2: Test PID deep internals and main route catch blocks to reach 80%+</name>
  <files>app/api/scheduler/check/__tests__/route.test.ts</files>
  <action>
Add additional tests covering the remaining uncovered branches to push total coverage past 80%.

**runPidAutomationIfEnabled deep internals (lines 552-736):**

Currently tested: skip conditions (not WORK, not auto, no admin, disabled config, no Netatmo, room not found, no temp, invalid setpoint). What's uncovered:

- Test PID power level adjustment (lines 686-714): Mock PIDController.compute() to return a value DIFFERENT from currentPowerLevel (e.g., compute returns 3, currentPowerLevel is 4). Verify `setPowerLevel` called with 3, `updateStoveState` called with `source: 'pid_automation'`, `adminDbSet` called with boost state `{ active: true, powerLevel: 3, scheduledPower: 4, appliedAt: expect.any(Number) }`, and `logAnalyticsEvent` called with `eventType: 'power_change'`.
- Test PID no change needed (lines 717-729): Mock PIDController.compute() to return SAME as currentPowerLevel. Verify `setPowerLevel` NOT called.
- Test PID boost cleared when targetPower equals scheduledPower (line 718-719): Mock compute to return value equal to schedule's power level. Verify `adminDbSet` called with `{ active: false }` for pidBoost path.
- Test PID state restoration from previous run (lines 637-643): Mock `pidAutomation/state` to return `{ integral: 1.5, prevError: 0.3, initialized: true, lastRun: Date.now() - 300000 }`. Verify PIDController.setState called with these values.
- Test PID dt calculation (lines 619-624): Provide pidState with lastRun, verify dt is calculated and clamped between 1-30 minutes. (This is internal to PIDController.compute call — verify compute is called.)
- Test PID tuning log entry (lines 658-673): Verify `logPidTuningEntry` called with correct parameters after compute. Also test log failure branch (line 670-672): mock `logPidTuningEntry` to reject, verify console.error with "Failed to log PID tuning data".
- Test PID old log cleanup (lines 676-683): Mock `pidState.lastCleanup` to >24h ago. Verify `cleanupOldLogs` called. Also verify `adminDbSet` called with `lastCleanup` path.
- Test PID exception handler (lines 731-734): Mock a critical PID function (e.g., `adminDbGet` for users path) to reject. Verify return includes `reason: 'exception'`.

**Test no targetRoomId (line 589-591):** Mock PID config with `enabled: true` but NO `targetRoomId`. Verify PID skips with `no_target_room` reason.

**Main route catch blocks (fire-and-forget .catch handlers on lines 843-874):**
These are the `.catch(err => console.error(...))` handlers on fire-and-forget calls in the main handler. Some are already covered by exception tests above. Additional ones:
- Test `logCronExecution` error handler (line 766, 786, etc.): Mock `logCronExecution` to reject. Verify console.error called with "Cron execution log error". This covers multiple catch blocks on lines 766, 786, 825, 911, 931, 950, 1022.
- Test `syncLivingRoomWithStove` then/catch in ignition (line 463-466): Mock to resolve with `{ synced: true }` to cover the .then branch. Mock to reject to cover the .catch branch.
- Test `syncLivingRoomWithStove` then/catch in shutdown (line 493-496): Same pattern.
- Test `logAnalyticsEvent` catch during power change (lines 515-519): Mock `logAnalyticsEvent` to reject. Verify no crash.

**Implementation notes:**
- For PID tests that need to check internal function calls, configure the full PID mock chain:
  ```typescript
  const { PIDController } = require('@/lib/utils/pidController');
  const mockCompute = jest.fn().mockReturnValue(3); // or whatever target
  const mockGetState = jest.fn().mockReturnValue({ integral: 0, prevError: 0, initialized: true });
  const mockSetState = jest.fn();
  jest.mocked(PIDController).mockImplementation(() => ({
    compute: mockCompute,
    setState: mockSetState,
    getState: mockGetState,
  }));
  ```
- For `logCronExecution` rejection tests, the mock already returns resolved by default. Override with `mockLogCronExecution.mockRejectedValue(new Error('DB error'))` for specific tests.
- After all tests added, run coverage report. If still below 80%, identify remaining uncovered lines and add targeted tests.
- CRITICAL: Do NOT modify any existing tests. Only ADD new describe blocks.
  </action>
  <verify>
Run: `npx jest app/api/scheduler/check/__tests__/route.test.ts` — ALL tests pass.
Run: `npx jest --coverage --collectCoverageFrom='app/api/scheduler/check/route.ts' app/api/scheduler/check/__tests__/route.test.ts` — branch coverage >= 80%.
  </verify>
  <done>Scheduler route branch coverage reaches 80%+ per Jest coverage report. All existing and new tests pass. TEST-04 requirement satisfied.</done>
</task>

</tasks>

<verification>
1. Run full test suite: `npx jest app/api/scheduler/check/__tests__/route.test.ts` — all tests pass
2. Run coverage: `npx jest --coverage --collectCoverageFrom='app/api/scheduler/check/route.ts' app/api/scheduler/check/__tests__/route.test.ts` — branch coverage >= 80%
3. Verify existing 63 tests still pass unchanged
4. No new test file created — all tests added to existing route.test.ts
</verification>

<success_criteria>
- Branch coverage on `app/api/scheduler/check/route.ts` reaches 80%+ (up from 67.15%)
- All existing 63 tests pass unchanged
- New tests cover fire-and-forget helper function branches (calibration, weather, cleanup, notifications, PID)
- TEST-04 requirement ("Tests achieve 80%+ branch coverage on scheduler check route") is satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/60-critical-path-testing-token-cleanup/60-05-SUMMARY.md`
</output>
