---
phase: 61-foundation-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - types/api/errors.ts
  - lib/core/apiErrors.ts
  - lib/devices/deviceTypes.ts
  - lib/fritzbox/fritzboxClient.ts
  - lib/fritzbox/fritzboxCache.ts
  - lib/fritzbox/fritzboxRateLimiter.ts
  - lib/fritzbox/fritzboxErrors.ts
  - lib/fritzbox/index.ts
  - lib/fritzbox/__tests__/fritzboxClient.test.ts
  - lib/fritzbox/__tests__/fritzboxCache.test.ts
  - lib/fritzbox/__tests__/fritzboxRateLimiter.test.ts
autonomous: true
must_haves:
  truths:
    - "Fritz!Box credentials read from process.env only, never returned in any response"
    - "Rate limiter enforces 10 req/min per user via Firebase RTDB transactions"
    - "Cache returns cached data when within 60s TTL, fetches fresh when expired"
    - "Network device type appears in DEVICE_CONFIG with routes and features"
    - "Fritz!Box-specific error codes (TR064_NOT_ENABLED, FRITZBOX_TIMEOUT, FRITZBOX_RATE_LIMITED) exist in type system"
  artifacts:
    - path: "lib/fritzbox/fritzboxClient.ts"
      provides: "FritzBoxClient class with request(), ping(), getDevices(), getBandwidth(), getWanStatus()"
      exports: ["fritzboxClient"]
    - path: "lib/fritzbox/fritzboxCache.ts"
      provides: "Generic cache-aside pattern using Firebase RTDB with 60s TTL"
      exports: ["getCachedData"]
    - path: "lib/fritzbox/fritzboxRateLimiter.ts"
      provides: "Fritz!Box-specific rate limiter wrapping checkRateLimitPersistent"
      exports: ["checkRateLimitFritzBox"]
    - path: "lib/fritzbox/fritzboxErrors.ts"
      provides: "Fritz!Box error code constants and factory methods"
      exports: ["FRITZBOX_ERROR_CODES"]
    - path: "lib/fritzbox/index.ts"
      provides: "Barrel export for all fritzbox lib modules"
    - path: "lib/devices/deviceTypes.ts"
      provides: "Updated device registry with NETWORK device type"
      contains: "NETWORK"
    - path: "types/api/errors.ts"
      provides: "Updated ErrorCode union with Fritz!Box-specific codes"
      contains: "TR064_NOT_ENABLED"
  key_links:
    - from: "lib/fritzbox/fritzboxClient.ts"
      to: "process.env.FRITZBOX_*"
      via: "environment variable reads at module scope"
      pattern: "process\\.env\\.FRITZBOX"
    - from: "lib/fritzbox/fritzboxRateLimiter.ts"
      to: "lib/rateLimiterPersistent.ts"
      via: "checkRateLimitPersistent import"
      pattern: "checkRateLimitPersistent"
    - from: "lib/fritzbox/fritzboxCache.ts"
      to: "lib/firebaseAdmin.ts"
      via: "adminDbGet and adminDbSet for Firebase RTDB caching"
      pattern: "adminDb(Get|Set)"
    - from: "lib/fritzbox/fritzboxClient.ts"
      to: "lib/core/apiErrors.ts"
      via: "throws ApiError with Fritz!Box-specific error codes"
      pattern: "new ApiError"
---

<objective>
Create the Fritz!Box integration foundation: API client with timeouts and TR-064 error detection, Firebase RTDB cache layer with 60s TTL, rate limiter adapted for 10 req/min, Fritz!Box-specific error codes, and network device type in the device registry.

Purpose: All Phase 61 API routes (Plan 02) depend on these lib/ modules. Building the foundation first ensures routes are clean one-liner proxies, not monolithic files with embedded logic.

Output: 8 new files under lib/fritzbox/, updated device registry, updated error types, and 3 test files.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/61-foundation-infrastructure/61-RESEARCH.md

@lib/devices/deviceTypes.ts
@lib/rateLimiterPersistent.ts
@lib/core/apiErrors.ts
@lib/core/index.ts
@lib/firebaseAdmin.ts
@lib/environmentHelper.ts
@types/api/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fritz!Box error codes, types, and device registry</name>
  <files>
    types/api/errors.ts
    lib/core/apiErrors.ts
    lib/devices/deviceTypes.ts
    lib/fritzbox/fritzboxErrors.ts
  </files>
  <action>
1. **Update `types/api/errors.ts`** - Add Fritz!Box-specific error codes to the ErrorCode union type:
   - `'TR064_NOT_ENABLED'` - TR-064 API disabled on router
   - `'FRITZBOX_TIMEOUT'` - Fritz!Box unreachable / timeout
   - `'FRITZBOX_NOT_CONFIGURED'` - Missing env vars
   Add them in a new `// Fritz!Box-specific` section after the Hue section, following the existing grouping pattern.

2. **Update `lib/core/apiErrors.ts`** - Add Fritz!Box entries to ERROR_CODES, ERROR_MESSAGES, and factory methods:
   - `ERROR_CODES.TR064_NOT_ENABLED = 'TR064_NOT_ENABLED'`
   - `ERROR_CODES.FRITZBOX_TIMEOUT = 'FRITZBOX_TIMEOUT'`
   - `ERROR_CODES.FRITZBOX_NOT_CONFIGURED = 'FRITZBOX_NOT_CONFIGURED'`
   - `ERROR_MESSAGES` entries (Italian): `'TR-064 non abilitato sul router'`, `'Fritz!Box non raggiungibile'`, `'Fritz!Box non configurato'`
   - Factory: `static fritzboxNotConfigured()` -> 500, `static tr064NotEnabled(details)` -> 403 with setupGuideUrl in details, `static fritzboxTimeout()` -> 504
   Follow the exact pattern of existing device-specific errors (stoveOffline, hueNotConnected, etc.).

3. **Create `lib/fritzbox/fritzboxErrors.ts`** - Fritz!Box error code constants (convenience re-exports + Fritz!Box-specific helper). Export `FRITZBOX_ERROR_CODES` object mapping to the ERROR_CODES values for Fritz!Box errors.

4. **Update `lib/devices/deviceTypes.ts`**:
   - Add `'network'` to the `DeviceTypeId` union type
   - Add `NETWORK: 'network'` to `DEVICE_TYPES`
   - Add network device config to `DEVICE_CONFIG`:
     ```
     id: 'network', name: 'Rete', icon: 'globe' (use Lucide icon name string, NOT emoji, for consistency check ‚Äî actually use emoji 'üåê' like other devices), color: 'info', enabled: true
     routes: { main: '/network' }
     features: { hasScheduler: false, hasMaintenance: false, hasErrors: false }
     ```
   - Add `'network'` to `DEFAULT_DEVICE_ORDER` array (after 'camera', before 'sonos')
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -20` to confirm zero type errors. Verify the ErrorCode union includes TR064_NOT_ENABLED. Verify DEVICE_CONFIG has 6 entries (stove, thermostat, camera, lights, sonos, network).
  </verify>
  <done>
Fritz!Box error codes exist in the type system and ApiError class. Network device type registered in device registry with correct routes and features. All existing tests still pass (`npm test -- --passWithNoTests lib/core lib/devices`).
  </done>
</task>

<task type="auto">
  <name>Task 2: Fritz!Box client, cache, rate limiter, and barrel export</name>
  <files>
    lib/fritzbox/fritzboxClient.ts
    lib/fritzbox/fritzboxCache.ts
    lib/fritzbox/fritzboxRateLimiter.ts
    lib/fritzbox/index.ts
  </files>
  <action>
1. **Create `lib/fritzbox/fritzboxClient.ts`** - FritzBoxClient class:
   - Read credentials from env at module scope: `FRITZBOX_URL`, `FRITZBOX_USER`, `FRITZBOX_PASSWORD`
   - Private `request(endpoint: string, timeout = 15000)` method:
     - If any env var missing, throw `ApiError.fritzboxNotConfigured()`
     - Use `AbortController` + `setTimeout` for timeout (pattern from research)
     - Set `Authorization: Basic {base64(user:password)}` header
     - Handle response status:
       - 403 -> throw `ApiError.tr064NotEnabled({ setupGuideUrl: '/docs/fritzbox-setup', tr064Enabled: false })`
       - Non-ok -> throw `new ApiError(ERROR_CODES.EXTERNAL_API_ERROR, 'Fritz!Box API error: {statusText}', HTTP_STATUS.BAD_GATEWAY)`
       - AbortError -> throw `ApiError.fritzboxTimeout()`
     - Return `response.json()`
   - Public methods:
     - `ping()` -> `this.request('/api/v1/health', 10000)` (10s timeout for health check)
     - `getDevices()` -> `this.request('/api/v1/devices')`
     - `getBandwidth()` -> `this.request('/api/v1/bandwidth')`
     - `getWanStatus()` -> `this.request('/api/v1/wan')`
   - Export singleton: `export const fritzboxClient = new FritzBoxClient()`
   - NOTE: The actual Fritz!Box API endpoints will be adjusted when we test against the real router. Use placeholder `/api/v1/*` paths for now ‚Äî the important thing is the client infrastructure (auth, timeout, error handling).

2. **Create `lib/fritzbox/fritzboxCache.ts`** - Generic cache-aside with Firebase RTDB:
   - `getCachedData<T>(cacheKey: string, fetchFn: () => Promise<T>): Promise<T>`
   - Use `adminDbGet` to read from `getEnvironmentPath('fritzbox/cache/{cacheKey}')`
   - Cache structure: `{ data: T, timestamp: number }`
   - If cached and `Date.now() - timestamp < CACHE_TTL_MS` (60000), return `cached.data`
   - Otherwise call `fetchFn()`, store result with `adminDbSet`, return data
   - Export `CACHE_TTL_MS = 60 * 1000` for testing
   - Export `invalidateCache(cacheKey: string)` that calls `adminDbRemove` on the cache path

3. **Create `lib/fritzbox/fritzboxRateLimiter.ts`** - Fritz!Box rate limiter wrapper:
   - Import `checkRateLimitPersistent` and `RateLimitConfig` from `@/lib/rateLimiterPersistent`
   - Define `FRITZBOX_RATE_LIMIT: RateLimitConfig = { windowMinutes: 1, maxPerWindow: 10 }`
   - Export `checkRateLimitFritzBox(userId: string, endpoint: string): Promise<RateLimitResult>`
     - Calls `checkRateLimitPersistent(userId, 'fritzbox_{endpoint}', FRITZBOX_RATE_LIMIT)`
   - Export the config constant for testing

4. **Create `lib/fritzbox/index.ts`** - Barrel export:
   ```typescript
   export { fritzboxClient } from './fritzboxClient';
   export { getCachedData, invalidateCache, CACHE_TTL_MS } from './fritzboxCache';
   export { checkRateLimitFritzBox, FRITZBOX_RATE_LIMIT } from './fritzboxRateLimiter';
   export { FRITZBOX_ERROR_CODES } from './fritzboxErrors';
   ```
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -20` to confirm zero type errors. Verify barrel exports resolve: `import { fritzboxClient, getCachedData, checkRateLimitFritzBox } from '@/lib/fritzbox'` compiles.
  </verify>
  <done>
FritzBoxClient class handles auth, timeouts, and TR-064 errors. Cache layer provides 60s TTL with Firebase RTDB. Rate limiter wraps Phase 49 persistent rate limiter with 10 req/min config. All modules compile and barrel export works.
  </done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for client, cache, and rate limiter</name>
  <files>
    lib/fritzbox/__tests__/fritzboxClient.test.ts
    lib/fritzbox/__tests__/fritzboxCache.test.ts
    lib/fritzbox/__tests__/fritzboxRateLimiter.test.ts
  </files>
  <action>
1. **Create `lib/fritzbox/__tests__/fritzboxClient.test.ts`** - Test FritzBoxClient:
   - Mock `global.fetch` with `jest.fn()`
   - Mock environment variables using `jest.replaceProperty(process, 'env', {...})`  or direct assignment in beforeEach
   - Test cases:
     - `ping()` calls correct endpoint with 10s timeout
     - `getDevices()` calls correct endpoint with Basic Auth header
     - Request with 403 status throws ApiError with code TR064_NOT_ENABLED and setupGuideUrl in details
     - Request with non-ok status throws ApiError with EXTERNAL_API_ERROR code
     - Request timeout (AbortController abort) throws ApiError with FRITZBOX_TIMEOUT code
     - Missing env vars throws ApiError with FRITZBOX_NOT_CONFIGURED code
   - Pattern: Follow existing test patterns with `jest.mocked()` and `beforeEach` cleanup
   - NOTE: The FritzBoxClient reads env vars at module scope (singleton). Use `jest.isolateModules()` or re-import to test missing env vars scenario.

2. **Create `lib/fritzbox/__tests__/fritzboxCache.test.ts`** - Test cache layer:
   - Mock `@/lib/firebaseAdmin` (`adminDbGet`, `adminDbSet`, `adminDbRemove`)
   - Mock `@/lib/environmentHelper` (`getEnvironmentPath` returns path as-is)
   - Test cases:
     - Cache miss: calls fetchFn, stores result, returns data
     - Cache hit (within TTL): returns cached data, does NOT call fetchFn
     - Cache expired (beyond TTL): calls fetchFn, updates cache
     - `invalidateCache()` calls adminDbRemove with correct path
   - Use `Date.now()` mocking via `jest.spyOn(Date, 'now')` to control timestamps

3. **Create `lib/fritzbox/__tests__/fritzboxRateLimiter.test.ts`** - Test rate limiter:
   - Mock `@/lib/rateLimiterPersistent` (`checkRateLimitPersistent`)
   - Test cases:
     - `checkRateLimitFritzBox('user1', 'devices')` calls `checkRateLimitPersistent('user1', 'fritzbox_devices', { windowMinutes: 1, maxPerWindow: 10 })`
     - Returns result from underlying rate limiter unchanged
     - Different endpoint names produce different rate limit keys (no cross-endpoint sharing)
  </action>
  <verify>
Run `npm test -- lib/fritzbox` ‚Äî all tests pass. Verify test count is 10+ (covering the listed scenarios). Run `npm test -- --passWithNoTests` to confirm no regressions in existing tests.
  </verify>
  <done>
All Fritz!Box foundation modules have unit test coverage. Tests verify: client auth/timeout/error handling, cache TTL behavior, rate limiter delegation. No existing test regressions.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` ‚Äî zero errors (type system intact)
2. `npm test -- lib/fritzbox` ‚Äî all new tests pass
3. `npm test -- lib/core lib/devices` ‚Äî existing tests still pass
4. Verify DEVICE_CONFIG.network exists with correct properties
5. Verify ErrorCode type includes TR064_NOT_ENABLED, FRITZBOX_TIMEOUT, FRITZBOX_NOT_CONFIGURED
6. Verify fritzboxClient singleton does NOT expose credentials in any public method
</verification>

<success_criteria>
- lib/fritzbox/ directory exists with 4 modules + barrel export + 3 test files
- FritzBoxClient handles auth, timeouts, and TR-064 errors correctly
- Cache layer provides 60s TTL with Firebase RTDB persistence
- Rate limiter enforces 10 req/min via Phase 49 persistent rate limiter
- Network device registered in device registry with routes.main = '/network'
- Fritz!Box error codes exist in type system and ApiError class
- Zero tsc errors, all tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/61-foundation-infrastructure/61-01-SUMMARY.md`
</output>
