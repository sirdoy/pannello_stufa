---
phase: 62-dashboard-card
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/components/devices/network/types.ts
  - app/components/devices/network/hooks/useNetworkData.ts
  - app/components/devices/network/hooks/useNetworkCommands.ts
  - app/components/devices/network/networkHealthUtils.ts
  - app/components/devices/network/__tests__/useNetworkData.test.ts
  - app/components/devices/network/__tests__/networkHealthUtils.test.ts
autonomous: true

must_haves:
  truths:
    - "useNetworkData hook fetches bandwidth, devices, and WAN data from Fritz!Box API routes"
    - "Polling runs at 30s when tab visible and 5min when hidden via useAdaptivePolling"
    - "Sparkline data buffer accumulates up to 12 bandwidth readings in component state"
    - "Health algorithm computes excellent/good/degraded/poor with 2-reading hysteresis"
    - "API errors preserve cached data and set stale flag instead of clearing state"
    - "useNetworkCommands provides navigation handler to /network page"
  artifacts:
    - path: "app/components/devices/network/types.ts"
      provides: "TypeScript interfaces for network data, API responses, health status"
      contains: "NetworkData"
    - path: "app/components/devices/network/hooks/useNetworkData.ts"
      provides: "State management hook with adaptive polling and error handling"
      exports: ["useNetworkData"]
    - path: "app/components/devices/network/hooks/useNetworkCommands.ts"
      provides: "Navigation command handler"
      exports: ["useNetworkCommands"]
    - path: "app/components/devices/network/networkHealthUtils.ts"
      provides: "Health algorithm with hysteresis"
      exports: ["computeNetworkHealth"]
    - path: "app/components/devices/network/__tests__/useNetworkData.test.ts"
      provides: "Hook unit tests"
      min_lines: 50
    - path: "app/components/devices/network/__tests__/networkHealthUtils.test.ts"
      provides: "Health algorithm unit tests"
      min_lines: 40
  key_links:
    - from: "app/components/devices/network/hooks/useNetworkData.ts"
      to: "/api/fritzbox/bandwidth, /api/fritzbox/devices, /api/fritzbox/wan"
      via: "fetch in Promise.all"
      pattern: "Promise\\.all.*fetch"
    - from: "app/components/devices/network/hooks/useNetworkData.ts"
      to: "lib/hooks/useAdaptivePolling.ts"
      via: "import useAdaptivePolling"
      pattern: "useAdaptivePolling"
    - from: "app/components/devices/network/hooks/useNetworkData.ts"
      to: "app/components/devices/network/networkHealthUtils.ts"
      via: "import computeNetworkHealth"
      pattern: "computeNetworkHealth"
---

<objective>
Create the data layer for NetworkCard: TypeScript types, useNetworkData hook (polling + state + error handling + sparkline buffer), useNetworkCommands hook (navigation), and health algorithm with hysteresis.

Purpose: Establishes all state management and data fetching before building UI components. Follows orchestrator pattern where hooks own ALL state/effects.

Output: Fully tested hooks and utilities that NetworkCard orchestrator will consume in Plan 02.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-dashboard-card/62-RESEARCH.md

# Reference patterns (read these for implementation guidance)
@app/components/devices/stove/hooks/useStoveData.ts
@app/components/devices/lights/hooks/useLightsData.ts
@app/components/devices/lights/hooks/useLightsCommands.ts
@lib/hooks/useAdaptivePolling.ts
@lib/hooks/useVisibility.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types and health algorithm</name>
  <files>
    app/components/devices/network/types.ts
    app/components/devices/network/networkHealthUtils.ts
    app/components/devices/network/__tests__/networkHealthUtils.test.ts
  </files>
  <action>
**types.ts** — Create TypeScript interfaces for network data layer:

```typescript
// API response types (matching Fritz!Box API route responses from Phase 61)
export interface BandwidthData {
  download: number;    // Mbps
  upload: number;      // Mbps
  timestamp: number;   // Unix timestamp ms
}

export interface DeviceData {
  id: string;
  name: string;
  ip: string;
  mac: string;
  active: boolean;
  type?: 'lan' | 'wlan' | 'guest';
}

export interface WanData {
  connected: boolean;
  uptime: number;       // Seconds
  externalIp?: string;
  linkSpeed?: number;   // Mbps
  timestamp: number;
}

// Sparkline data point
export interface SparklinePoint {
  time: number;   // Unix timestamp ms
  mbps: number;
}

// Health status
export type NetworkHealthStatus = 'excellent' | 'good' | 'degraded' | 'poor';

// Maps to DeviceCard healthStatus prop
export type DeviceCardHealthStatus = 'ok' | 'warning' | 'error' | 'critical';

// Error types for Fritz!Box API
export interface NetworkError {
  type: 'setup' | 'timeout' | 'rate_limited' | 'generic';
  message: string;
  retryAfter?: number;
}

// Hook return type
export interface UseNetworkDataReturn {
  // Core data
  bandwidth: BandwidthData | null;
  devices: DeviceData[];
  wan: WanData | null;

  // Sparkline buffers
  downloadHistory: SparklinePoint[];
  uploadHistory: SparklinePoint[];

  // Status
  loading: boolean;
  connected: boolean;
  stale: boolean;
  lastUpdated: number | null;

  // Health
  health: NetworkHealthStatus;
  healthMapped: DeviceCardHealthStatus;

  // Error
  error: NetworkError | null;

  // Derived
  activeDeviceCount: number;
}

// Commands return type
export interface UseNetworkCommandsReturn {
  navigateToNetwork: () => void;
}
```

**networkHealthUtils.ts** — Health algorithm with hysteresis:

```typescript
export function computeNetworkHealth(params: {
  wanConnected: boolean;
  wanUptime: number;         // seconds
  downloadMbps: number;
  uploadMbps: number;
  linkSpeedMbps?: number;    // max capacity
  previousHealth: NetworkHealthStatus;
  consecutiveReadings: number;  // how many readings at current computed level
}): { health: NetworkHealthStatus; consecutiveReadings: number }
```

Algorithm:
1. If WAN disconnected: return 'poor' immediately (no hysteresis for disconnection)
2. Calculate bandwidth saturation: `max(download, upload) / (linkSpeed || 100)` (default 100 Mbps if unknown)
3. Score matrix:
   - Uptime > 24h AND saturation < 0.7 → 'excellent'
   - Uptime > 1h AND saturation < 0.85 → 'good'
   - Uptime > 10min AND saturation < 0.95 → 'degraded'
   - Otherwise → 'poor'
4. Hysteresis: Only change health status if NEW status has been computed for 2+ consecutive readings. Exception: 'poor' due to WAN disconnect is immediate.
5. Map to DeviceCard: excellent→'ok', good→'ok', degraded→'warning', poor→'critical'

Also export `mapHealthToDeviceCard(health: NetworkHealthStatus): DeviceCardHealthStatus`

**Tests for networkHealthUtils.test.ts:**
- WAN disconnected → immediate 'poor' (no hysteresis)
- High uptime + low saturation → 'excellent'
- Medium uptime + medium saturation → 'good'
- Low uptime + high saturation → 'degraded'
- Hysteresis: single reading doesn't change status, 2 consecutive readings do
- Default linkSpeed when undefined
- mapHealthToDeviceCard mapping correctness
  </action>
  <verify>
Run `npx jest app/components/devices/network/__tests__/networkHealthUtils.test.ts --no-coverage` — all tests pass.
Run `npx tsc --noEmit app/components/devices/network/types.ts app/components/devices/network/networkHealthUtils.ts` — no type errors.
  </verify>
  <done>
types.ts exports all interfaces needed by hooks and components. networkHealthUtils.ts computes health with hysteresis and maps to DeviceCard health status. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useNetworkData and useNetworkCommands hooks with tests</name>
  <files>
    app/components/devices/network/hooks/useNetworkData.ts
    app/components/devices/network/hooks/useNetworkCommands.ts
    app/components/devices/network/__tests__/useNetworkData.test.ts
  </files>
  <action>
**useNetworkData.ts** — Main data hook following StoveCard/LightsCard orchestrator pattern:

1. **State management:**
   - `bandwidth: BandwidthData | null` (null until first fetch)
   - `devices: DeviceData[]` (empty array initially)
   - `wan: WanData | null` (null until first fetch)
   - `downloadHistory: SparklinePoint[]` (max 12 points)
   - `uploadHistory: SparklinePoint[]` (max 12 points)
   - `loading: boolean` (true until first successful fetch or first error)
   - `stale: boolean` (true when data age > 60s or after API error)
   - `lastUpdated: number | null` (timestamp of last successful fetch)
   - `error: NetworkError | null`
   - `health: NetworkHealthStatus` (from computeNetworkHealth)
   - `healthMapped: DeviceCardHealthStatus` (mapped for DeviceCard)
   - `consecutiveReadingsRef: useRef<number>` (for hysteresis tracking)

2. **fetchData callback (useCallback):**
   ```typescript
   const fetchData = useCallback(async () => {
     try {
       const [bwRes, devRes, wanRes] = await Promise.all([
         fetch('/api/fritzbox/bandwidth'),
         fetch('/api/fritzbox/devices'),
         fetch('/api/fritzbox/wan'),
       ]);

       // Handle individual response errors
       if (!bwRes.ok || !devRes.ok || !wanRes.ok) {
         // Check for specific error codes
         const errorRes = [bwRes, devRes, wanRes].find(r => !r.ok);
         if (errorRes) {
           const errorData = await errorRes.json();
           // Map RFC 9457 error codes to NetworkError
           if (errorData.code === 'TR064_NOT_ENABLED') {
             setError({ type: 'setup', message: errorData.message || 'TR-064 non abilitato' });
           } else if (errorData.code === 'FRITZBOX_TIMEOUT') {
             setStale(true);
             // DON'T clear existing data — show cached
           } else if (errorData.code === 'RATE_LIMITED') {
             setError({ type: 'rate_limited', message: errorData.message, retryAfter: errorData.retryAfter });
           } else {
             setError({ type: 'generic', message: errorData.message || 'Errore connessione Fritz!Box' });
           }
           return; // Keep previous data
         }
       }

       const [bwData, devData, wanData] = await Promise.all([
         bwRes.json(), devRes.json(), wanRes.json()
       ]);

       // Update state
       const bw = bwData.bandwidth as BandwidthData;
       setBandwidth(bw);
       setDevices((devData.devices || []) as DeviceData[]);
       setWan(wanData.wan as WanData);

       // Update sparkline buffers (max 12 points = 6 min at 30s interval)
       if (bw) {
         const now = Date.now();
         setDownloadHistory(prev => [...prev, { time: now, mbps: bw.download }].slice(-12));
         setUploadHistory(prev => [...prev, { time: now, mbps: bw.upload }].slice(-12));
       }

       // Update health
       const newHealthResult = computeNetworkHealth({
         wanConnected: wanData.wan?.connected ?? false,
         wanUptime: wanData.wan?.uptime ?? 0,
         downloadMbps: bw?.download ?? 0,
         uploadMbps: bw?.upload ?? 0,
         linkSpeedMbps: wanData.wan?.linkSpeed,
         previousHealth: healthRef.current,
         consecutiveReadings: consecutiveReadingsRef.current,
       });
       setHealth(newHealthResult.health);
       healthRef.current = newHealthResult.health;
       consecutiveReadingsRef.current = newHealthResult.consecutiveReadings;

       // Clear error and stale
       setError(null);
       setStale(false);
       setLastUpdated(Date.now());
     } catch (err) {
       // Network error — keep cached data, mark stale
       setStale(true);
       if (!bandwidth && !wan) {
         // No cached data at all — set generic error
         setError({ type: 'generic', message: 'Impossibile raggiungere Fritz!Box' });
       }
     } finally {
       setLoading(false);
     }
   }, [bandwidth, wan]);
   ```

3. **Adaptive polling:**
   Use `useAdaptivePolling` from `@/lib/hooks/useAdaptivePolling`:
   ```typescript
   const isVisible = useVisibility();
   const interval = isVisible ? 30000 : 300000; // 30s visible, 5min hidden

   useAdaptivePolling({
     callback: fetchData,
     interval,
     alwaysActive: false,  // Non-safety-critical monitoring
     immediate: true,      // Fetch on mount
   });
   ```

4. **Derived state:**
   - `connected: boolean` — `wan?.connected ?? false`
   - `activeDeviceCount: number` — `devices.filter(d => d.active).length`

5. **Return `UseNetworkDataReturn`**

**useNetworkCommands.ts** — Simple navigation hook:
```typescript
export function useNetworkCommands({ router }: { router: ReturnType<typeof useRouter> }): UseNetworkCommandsReturn {
  const navigateToNetwork = useCallback(() => {
    router.push('/network');
  }, [router]);

  return { navigateToNetwork };
}
```

**Tests for useNetworkData.test.ts:**
Use `@testing-library/react` renderHook pattern. Mock fetch globally.

Test cases:
- Initial state has loading=true, null bandwidth/wan, empty devices
- Successful fetch updates all state (bandwidth, devices, wan)
- Sparkline buffer appends data points on each fetch
- Sparkline buffer caps at 12 points (oldest removed)
- API error preserves existing cached data and sets stale=true
- TR-064 not enabled error sets error.type='setup'
- Rate limit error sets error.type='rate_limited' with retryAfter
- Timeout error sets stale=true without clearing data
- Network error (fetch throws) preserves cached data
- loading becomes false after first fetch (success or error)
- activeDeviceCount counts only active devices
- connected derives from wan.connected

Mock `useAdaptivePolling` to call callback immediately. Mock `useVisibility` to return true.
  </action>
  <verify>
Run `npx jest app/components/devices/network/__tests__/useNetworkData.test.ts --no-coverage` — all tests pass.
Run `npx tsc --noEmit app/components/devices/network/hooks/useNetworkData.ts app/components/devices/network/hooks/useNetworkCommands.ts` — no type errors.
  </verify>
  <done>
useNetworkData hook manages all network state with adaptive polling (30s/5min), error handling preserving cached data, sparkline buffer (12 points), health computation with hysteresis, and stale detection. useNetworkCommands provides /network navigation. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx jest app/components/devices/network/__tests__/ --no-coverage` — all tests pass
2. `npx tsc --noEmit` — no type errors in new files
3. Health algorithm correctly handles hysteresis (2 consecutive readings required)
4. Sparkline buffer limited to 12 points
5. API errors do NOT clear cached data
</verification>

<success_criteria>
- useNetworkData hook fetches from 3 Fritz!Box API routes in parallel
- Adaptive polling at 30s visible / 5min hidden using useAdaptivePolling
- Sparkline data buffer stores up to 12 bandwidth readings
- Health algorithm with 2-reading hysteresis
- Error handling preserves cached data (never clears state on error)
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/62-dashboard-card/62-01-SUMMARY.md`
</output>
