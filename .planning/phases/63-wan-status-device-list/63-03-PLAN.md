---
phase: 63-wan-status-device-list
plan: 03
type: execute
wave: 2
depends_on: ["63-01", "63-02"]
files_modified:
  - app/network/page.tsx
  - app/network/__tests__/page.test.tsx
autonomous: true

must_haves:
  truths:
    - "User navigates to /network and sees WAN status card on top"
    - "User sees device list table below WAN card"
    - "User can click back button to return to dashboard"
    - "User sees loading skeleton while data loads"
    - "Page uses existing useNetworkData hook from Phase 62"
  artifacts:
    - path: "app/network/page.tsx"
      provides: "Network page orchestrator"
      min_lines: 40
    - path: "app/network/__tests__/page.test.tsx"
      provides: "Page-level integration tests"
      min_lines: 30
  key_links:
    - from: "app/network/page.tsx"
      to: "app/components/devices/network/hooks/useNetworkData.ts"
      via: "hook import for all data"
      pattern: "import.*useNetworkData.*from.*hooks"
    - from: "app/network/page.tsx"
      to: "app/network/components/WanStatusCard.tsx"
      via: "component import"
      pattern: "import.*WanStatusCard"
    - from: "app/network/page.tsx"
      to: "app/network/components/DeviceListTable.tsx"
      via: "component import"
      pattern: "import.*DeviceListTable"
    - from: "app/network/page.tsx"
      to: "app/components/ui/PageLayout.tsx"
      via: "layout import"
      pattern: "import.*PageLayout.*from.*ui"
---

<objective>
Wire WanStatusCard and DeviceListTable into the /network page orchestrator using the existing useNetworkData hook from Phase 62.

Purpose: Creates the complete /network page that ties all Phase 63 components together. Uses the orchestrator pattern (consistent with /stove and /lights pages).

Output: Network page at /network + integration tests
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/63-wan-status-device-list/63-RESEARCH.md
@.planning/phases/63-wan-status-device-list/63-01-SUMMARY.md
@.planning/phases/63-wan-status-device-list/63-02-SUMMARY.md

@app/components/devices/network/hooks/useNetworkData.ts
@app/components/devices/network/types.ts
@app/stove/page.tsx
@app/components/ui/PageLayout.tsx
@app/components/ui/Skeleton.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /network page orchestrator</name>
  <files>
    app/network/page.tsx
  </files>
  <action>
**Create `app/network/page.tsx`**

'use client' directive. This is the page orchestrator — follows the same pattern as /stove/page.tsx.

Imports:
- `useRouter` from 'next/navigation'
- `PageLayout, Skeleton, Button, Heading` from '@/app/components/ui'
- `useNetworkData` from '@/app/components/devices/network/hooks/useNetworkData'
- `WanStatusCard` from './components/WanStatusCard'
- `DeviceListTable` from './components/DeviceListTable'

Implementation:

```typescript
export default function NetworkPage() {
  const router = useRouter();
  const networkData = useNetworkData();

  const handleBack = () => router.push('/');

  // Loading skeleton guard
  if (networkData.loading && !networkData.wan && networkData.devices.length === 0) {
    return (
      <div className="space-y-6">
        <Skeleton className="h-12 w-48 rounded-xl" />
        <Skeleton className="h-[280px] rounded-2xl" />
        <Skeleton className="h-[400px] rounded-2xl" />
      </div>
    );
  }

  return (
    <PageLayout
      header={
        <PageLayout.Header>
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <Button variant="ghost" size="sm" onClick={handleBack}>
                ← Indietro
              </Button>
              <div>
                <Heading level={1} size="2xl">Rete</Heading>
              </div>
            </div>
          </div>
        </PageLayout.Header>
      }
    >
      <div className="space-y-6">
        {/* WAN Status Card — always visible, top position */}
        <WanStatusCard
          wan={networkData.wan}
          isStale={networkData.stale}
          lastUpdated={networkData.lastUpdated}
        />

        {/* Device List Table — below WAN card */}
        <DeviceListTable
          devices={networkData.devices}
          isStale={networkData.stale}
        />
      </div>
    </PageLayout>
  );
}
```

Key decisions:
- Reuse useNetworkData from Phase 62 — NO new data fetching hook (avoids pitfall #1 from research)
- PageLayout.Header with custom children (includes back button + title) — follows project pattern
- Stacked sections with `space-y-6` — per locked decision
- Loading guard checks both `loading` state AND empty data — shows skeleton only on initial load, not on polling refresh
- WAN card receives `lastUpdated` (not `ageText`) — let the card component handle formatting
- The page is a thin orchestrator (~60 lines) consistent with Phase 58-59 refactoring pattern
  </action>
  <verify>
    `npx tsc --noEmit` passes with no new errors.
    Navigate to http://localhost:3000/network (if dev server is running) shows the page.
  </verify>
  <done>
    /network page renders with WAN status card on top and device list table below.
    Back button navigates to dashboard. Loading skeleton shows on initial load.
    Page uses useNetworkData hook (no duplicate data fetching).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create page-level integration tests</name>
  <files>
    app/network/__tests__/page.test.tsx
  </files>
  <action>
**Create `app/network/__tests__/page.test.tsx`**

Mock the useNetworkData hook to control data flow:
```typescript
jest.mock('@/app/components/devices/network/hooks/useNetworkData', () => ({
  useNetworkData: jest.fn(),
}));
```

Mock next/navigation:
```typescript
const mockPush = jest.fn();
jest.mock('next/navigation', () => ({
  useRouter: () => ({ push: mockPush }),
}));
```

Mock sub-components to avoid deep rendering complexity:
```typescript
jest.mock('../components/WanStatusCard', () => ({
  __esModule: true,
  default: ({ wan, isStale, lastUpdated }: any) => (
    <div data-testid="wan-status-card" data-connected={wan?.connected} data-stale={isStale} />
  ),
}));
jest.mock('../components/DeviceListTable', () => ({
  __esModule: true,
  default: ({ devices, isStale }: any) => (
    <div data-testid="device-list-table" data-count={devices.length} data-stale={isStale} />
  ),
}));
```

Import `useNetworkData` as mocked. Create helper to set mock return value.

Tests:

1. **Shows loading skeleton when loading=true and no data**
   - Mock: `{ loading: true, wan: null, devices: [], ... }`
   - Assert: skeleton elements exist, WanStatusCard NOT rendered

2. **Renders WanStatusCard with wan data**
   - Mock: `{ loading: false, wan: { connected: true, uptime: 3600, externalIp: '1.2.3.4', timestamp: Date.now() }, devices: [], stale: false, lastUpdated: Date.now(), ... }`
   - Assert: `data-testid="wan-status-card"` exists with `data-connected="true"`

3. **Renders DeviceListTable with devices data**
   - Mock: `{ loading: false, wan: wanData, devices: [device1, device2, device3], stale: false, ... }`
   - Assert: `data-testid="device-list-table"` exists with `data-count="3"`

4. **Back button navigates to home**
   - Mock: loaded state
   - Click the "Indietro" button
   - Assert: `mockPush` called with `'/'`

5. **Passes stale flag to both components**
   - Mock: `{ ...loadedState, stale: true }`
   - Assert: both WanStatusCard and DeviceListTable have `data-stale="true"`

6. **Shows page even while refreshing (loading=true but has cached data)**
   - Mock: `{ loading: true, wan: wanData, devices: [device1], stale: true, ... }`
   - Assert: WanStatusCard and DeviceListTable ARE rendered (not skeleton)
   - This verifies the loading guard only triggers on initial load, not polling refresh

Fill in all default UseNetworkDataReturn fields in the mock helper (bandwidth: null, downloadHistory: [], uploadHistory: [], connected: false, health: 'poor', healthMapped: 'error', error: null, activeDeviceCount: 0).
  </action>
  <verify>
    `npx jest app/network/__tests__/page.test.tsx --passWithNoTests` passes.
    All 6 tests pass with mocked hooks and components.
  </verify>
  <done>
    Page-level tests verify orchestrator wiring: loading state, data passing, navigation, stale propagation, and refresh-during-load behavior.
    All 6 tests passing. No deep rendering — component mocks isolate page logic.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no new TypeScript errors
2. `npx jest app/network/ --passWithNoTests` — ALL Phase 63 tests pass (Plan 01 + 02 + 03)
3. /network page renders at http://localhost:3000/network
4. Page uses useNetworkData hook (verify import, no duplicate fetch calls)
5. WanStatusCard receives wan, isStale, lastUpdated props
6. DeviceListTable receives devices and isStale props
7. Back button works (navigates to /)
8. Loading skeleton shows only on initial load
</verification>

<success_criteria>
- /network page exists and renders WAN card + device table
- Page is a thin orchestrator (~60 lines) following established pattern
- useNetworkData from Phase 62 provides all data (no new hooks)
- Back navigation to dashboard works
- Loading skeleton on initial load, cached data shown during refresh
- 6 page-level integration tests passing
- All Phase 63 tests combined: 30+ tests passing
- All 8 requirements satisfied (WAN-01 through WAN-03, DEV-01 through DEV-05)
</success_criteria>

<output>
After completion, create `.planning/phases/63-wan-status-device-list/63-03-SUMMARY.md`
</output>
