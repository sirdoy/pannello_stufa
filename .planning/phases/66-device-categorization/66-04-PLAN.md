---
phase: 66-device-categorization
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - app/api/network/vendor-lookup/route.ts
  - app/api/network/vendor-lookup/__tests__/route.test.ts
  - app/components/devices/network/hooks/useNetworkData.ts
  - app/components/devices/network/types.ts
  - app/network/page.tsx
  - app/network/__tests__/page.test.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Devices fetched from Fritz!Box API are automatically enriched with categories via vendor-lookup API"
    - "User can click category badge in DeviceListTable dropdown and new category persists to Firebase via category-override API"
    - "Categories display correct color-coded badges (not 'Sconosciuto' for all devices)"
  artifacts:
    - path: "app/components/devices/network/hooks/useNetworkData.ts"
      provides: "Category enrichment after device fetch + updateDeviceCategory function"
      contains: "vendor-lookup"
    - path: "app/components/devices/network/types.ts"
      provides: "updateDeviceCategory in UseNetworkDataReturn"
      contains: "updateDeviceCategory"
    - path: "app/network/page.tsx"
      provides: "handleCategoryChange wired to DeviceListTable onCategoryChange prop"
      contains: "onCategoryChange"
  key_links:
    - from: "app/api/network/vendor-lookup/route.ts"
      to: "lib/network/deviceCategories.ts#getCategoryOverride"
      via: "checks Firebase override before vendor lookup — ensures manual overrides survive page reload"
      pattern: "getCategoryOverride"
    - from: "app/components/devices/network/hooks/useNetworkData.ts"
      to: "/api/network/vendor-lookup"
      via: "fetch call per device MAC after devices loaded"
      pattern: "vendor-lookup"
    - from: "app/network/page.tsx"
      to: "/api/network/category-override"
      via: "handleCategoryChange calls fetch POST"
      pattern: "category-override"
    - from: "app/network/page.tsx"
      to: "DeviceListTable"
      via: "onCategoryChange prop"
      pattern: "onCategoryChange"
---

<objective>
Wire the three orphaned device categorization layers (logic, API, UI) into a working end-to-end feature.

Purpose: Plans 01-03 built isolated layers that never connect. This gap closure plan wires them together so:
1. Devices are automatically enriched with categories after fetching from Fritz!Box (CAT-01)
2. Users can override categories via the inline dropdown, persisting to Firebase (CAT-02)
3. Badges show actual categories instead of 'unknown' for all devices (CAT-03)

Output: Working device categorization feature — all 3 requirements functional.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/66-device-categorization/66-01-SUMMARY.md
@.planning/phases/66-device-categorization/66-02-SUMMARY.md
@.planning/phases/66-device-categorization/66-03-SUMMARY.md
@.planning/phases/66-device-categorization/66-VERIFICATION.md

# Key source files to read before implementing:
@app/components/devices/network/hooks/useNetworkData.ts
@app/components/devices/network/types.ts
@app/network/page.tsx
@app/network/__tests__/page.test.tsx
@app/network/components/DeviceListTable.tsx
@app/api/network/vendor-lookup/route.ts
@app/api/network/category-override/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Firebase override check to vendor-lookup API route and update tests</name>
  <files>
    app/api/network/vendor-lookup/route.ts
    app/api/network/vendor-lookup/__tests__/route.test.ts
  </files>
  <action>
    **Goal:** The vendor-lookup API currently bypasses manual Firebase overrides. Modify it to check `getCategoryOverride(mac)` FIRST, so the client (useNetworkData) always receives the correct category regardless of whether it was auto-detected or manually overridden. This ensures manual overrides survive page reloads and polling refreshes.

    **Step 1: Modify vendor-lookup route** (`app/api/network/vendor-lookup/route.ts`):

    1. Add import for `getCategoryOverride` from `@/lib/network/deviceCategories`:
       ```typescript
       import { categorizeByVendor, getCategoryOverride } from '@/lib/network/deviceCategories';
       ```

    2. After the MAC validation check but BEFORE the vendor cache check, add an override check:
       ```typescript
       // 0. Check for manual override in Firebase (highest priority)
       const override = await getCategoryOverride(mac);
       if (override) {
         return success({ vendor: '', category: override, cached: true, overridden: true });
       }

       // 1. Check vendor cache (7-day TTL)
       const cached = await getCachedVendor(mac);
       // ... rest of existing logic unchanged
       ```

    3. The `overridden: true` flag lets the client know this category came from a manual override, not vendor detection. The existing `cached: true` is set because the client can trust this value and skip re-enrichment.

    **Why this approach:** The client (useNetworkData) calls vendor-lookup per MAC. By checking overrides server-side, we keep the client simple — it just calls vendor-lookup and gets the right category. No need for a separate override-check call on every poll.

    **Step 2: Update vendor-lookup tests** (`app/api/network/vendor-lookup/__tests__/route.test.ts`):

    1. Add `getCategoryOverride` to the mock setup. The file already mocks `@/lib/network/deviceCategories` — add `getCategoryOverride` to the mocked functions:
       ```typescript
       import { categorizeByVendor, getCategoryOverride } from '@/lib/network/deviceCategories';
       const mockGetCategoryOverride = jest.mocked(getCategoryOverride);
       ```

    2. In `beforeEach`, add default: `mockGetCategoryOverride.mockResolvedValue(null);` so existing tests are unaffected.

    3. Add new test: "should return overridden category when Firebase override exists":
       ```typescript
       it('should return overridden category when Firebase override exists', async () => {
         mockGetCategoryOverride.mockResolvedValue('pc');
         const mockRequest = new Request(`http://localhost:3000/api/network/vendor-lookup?mac=${testMac}`);

         const response = await GET(mockRequest as any, {} as any);
         const data = await response.json();

         expect(response.status).toBe(200);
         expect(data).toEqual({
           success: true,
           vendor: '',
           category: 'pc',
           cached: true,
           overridden: true,
         });
         // Must NOT proceed to vendor cache or macvendors.com
         expect(mockGetCachedVendor).not.toHaveBeenCalled();
         expect(mockFetchVendorName).not.toHaveBeenCalled();
       });
       ```

    4. Add test: "should skip override check and proceed to vendor lookup when no override exists":
       ```typescript
       it('should proceed to vendor lookup when no override exists', async () => {
         mockGetCategoryOverride.mockResolvedValue(null);
         mockGetCachedVendor.mockResolvedValue(null);
         mockFetchVendorName.mockResolvedValue('Dell Inc.');
         mockCategorizeByVendor.mockReturnValue('pc');
         const mockRequest = new Request(`http://localhost:3000/api/network/vendor-lookup?mac=${testMac}`);

         const response = await GET(mockRequest as any, {} as any);
         const data = await response.json();

         expect(response.status).toBe(200);
         expect(data.category).toBe('pc');
         expect(data.overridden).toBeUndefined();
         expect(mockGetCategoryOverride).toHaveBeenCalledWith(testMac);
         expect(mockFetchVendorName).toHaveBeenCalledWith(testMac);
       });
       ```

    **What NOT to do:**
    - Do NOT change the existing test expectations — just add `mockGetCategoryOverride.mockResolvedValue(null)` in `beforeEach` so existing flows are unchanged
    - Do NOT remove the vendor cache logic — it still applies when there's no override
  </action>
  <verify>
    1. `npx tsc --noEmit --pretty 2>&1 | head -30` shows no new TypeScript errors
    2. `npx jest app/api/network/vendor-lookup/__tests__/route.test.ts --verbose` — all existing tests pass + 2 new tests pass
    3. Read route.ts and confirm:
       - `getCategoryOverride` is imported
       - Override check happens BEFORE vendor cache check
       - Returns `overridden: true` flag when override found
  </verify>
  <done>
    - vendor-lookup API checks Firebase overrides first (priority 1)
    - If override exists, returns immediately with `overridden: true` flag
    - If no override, proceeds with existing vendor cache + macvendors.com flow
    - All existing tests pass (no regressions from adding default null mock)
    - 2 new tests verify override priority and fallback behavior
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire category enrichment in useNetworkData hook and expose updateDeviceCategory</name>
  <files>
    app/components/devices/network/hooks/useNetworkData.ts
    app/components/devices/network/types.ts
  </files>
  <action>
    **Goal:** After devices are fetched from Fritz!Box, enrich each device with its category by calling the vendor-lookup API (which now respects Firebase overrides from Task 1). Also expose an `updateDeviceCategory` function for manual override support.

    **Step 1: Update UseNetworkDataReturn type** in `app/components/devices/network/types.ts`:
    - Add `updateDeviceCategory: (mac: string, category: DeviceCategory) => void` to the `UseNetworkDataReturn` interface
    - Import `DeviceCategory` is already present in this file

    **Step 2: Add category enrichment to useNetworkData** in `app/components/devices/network/hooks/useNetworkData.ts`:

    After `setDevices(devData.devices || [])` on line 126, add a fire-and-forget category enrichment call. The enrichment should:

    1. Create an `enrichDevicesWithCategories` async function inside the hook (or as a separate helper). This function:
       - Takes `DeviceData[]` as input
       - For each device that has a MAC address and whose MAC is NOT already in `enrichedMacsRef`, call `fetch('/api/network/vendor-lookup?mac=' + encodeURIComponent(device.mac))`
       - Parse response JSON: `{ vendor, category, cached, overridden? }`
       - Return a new array with category fields populated
       - Use `Promise.allSettled()` to handle individual failures gracefully (if one MAC fails, others still enrich)
       - Wrap the whole thing in try/catch — on any error, silently keep devices without categories

    2. **Silent failure rationale:** Category enrichment is a non-critical enhancement (fire-and-forget pattern). If vendor-lookup fails for any device, that device simply keeps its current category (or 'unknown'). The system self-heals on the next poll cycle when enrichment retries automatically for unenriched MACs.

    3. Call this enrichment function after setting devices. Use a pattern like:
       ```typescript
       const rawDevices = devData.devices || [];
       setDevices(rawDevices);

       // Fire-and-forget category enrichment (non-blocking, self-heals on next poll)
       enrichDevicesWithCategories(rawDevices).then(enrichedDevices => {
         setDevices(enrichedDevices);
       }).catch(() => {
         // Intentional silent failure: category enrichment is non-critical.
         // Self-heals on next poll — unenriched MACs will be retried.
       });
       ```

    4. **Ref management for enrichedMacsRef (`useRef<Set<string>>`):**
       - **Purpose:** Prevents re-enrichment of already-categorized devices on every poll cycle
       - **Populated:** After successful vendor-lookup response, add MAC to the Set
       - **Checked:** Before calling vendor-lookup, skip MACs already in the Set
       - **Persists:** Across poll cycles (ref survives re-renders)
       - **Enrichment trigger:** Only enrich on initial load + when new MACs are detected. Compute the diff: `newMacs = deviceMacs.filter(mac => !enrichedMacsRef.current.has(mac))`. If `newMacs.length === 0`, skip enrichment entirely — this is the normal poll case.
       - **Never cleared:** The ref only grows (MACs are added, never removed). If a device disappears and reappears, it's already enriched. Manual overrides also add to this set (via `updateDeviceCategory`), preventing vendor-lookup from overwriting them.

    5. **Performance:** Batch vendor lookups — don't call 30+ API requests simultaneously. Use a simple sequential loop or limit concurrency to 5 at a time. A simple approach: chunk the devices array into groups of 5 and await each group with `Promise.allSettled()`.

    **Step 3: Add updateDeviceCategory function:**

    Add a `useCallback` function `updateDeviceCategory(mac: string, category: DeviceCategory)`:
    - Updates the `devices` state by mapping over the array and setting the category for the matching MAC
    - Also update the enriched MACs ref to include this MAC (so polling doesn't overwrite)
    - This is called by the parent (network page) after a successful category override API call

    ```typescript
    const updateDeviceCategory = useCallback((mac: string, category: DeviceCategory) => {
      setDevices(prev => prev.map(d =>
        d.mac === mac ? { ...d, category } : d
      ));
      // Mark as enriched so polling doesn't overwrite manual override
      enrichedMacsRef.current.add(mac);
    }, []);
    ```

    **Step 4: Return updateDeviceCategory** from the hook in the return object.

    **What NOT to do:**
    - Do NOT modify the Fritz!Box devices API route (`app/api/fritzbox/devices/route.ts`) — it's a cached proxy and should stay lean
    - Do NOT make vendor-lookup calls blocking for the initial device render — show devices immediately, enrich async
    - Do NOT re-enrich on every poll cycle — use the enrichedMacsRef Set diff to skip already-categorized devices
    - Do NOT throw errors from enrichment — it's non-critical, fire-and-forget (self-heals on next poll)
  </action>
  <verify>
    1. `npx tsc --noEmit --pretty 2>&1 | head -30` shows no new TypeScript errors in modified files
    2. Read the modified useNetworkData.ts and confirm:
       - `enrichDevicesWithCategories` function exists
       - It calls `/api/network/vendor-lookup` endpoint
       - `updateDeviceCategory` function exists and is returned
       - enrichedMacsRef prevents re-enrichment via Set diff check
       - Enrichment only triggers for new/unenriched MACs, not on every poll
    3. Read types.ts and confirm `updateDeviceCategory` is in `UseNetworkDataReturn`
  </verify>
  <done>
    - useNetworkData hook enriches devices with categories via vendor-lookup API after each fetch
    - Enrichment only triggers for new MACs not in enrichedMacsRef (Set diff), skipping normal poll cycles
    - Silent failure is intentional fire-and-forget — self-heals on next poll for unenriched MACs
    - updateDeviceCategory function updates a single device's category in state and adds MAC to enrichedMacsRef
    - UseNetworkDataReturn type includes updateDeviceCategory
    - No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire category override in network page and update tests</name>
  <files>
    app/network/page.tsx
    app/network/__tests__/page.test.tsx
  </files>
  <action>
    **Goal:** Create `handleCategoryChange` callback in network page that calls the category-override API and passes it to DeviceListTable's `onCategoryChange` prop. Update tests to verify the wiring.

    **Step 1: Modify network page** (`app/network/page.tsx`):

    1. Add a `handleCategoryChange` callback using `useCallback`:
       ```typescript
       const handleCategoryChange = useCallback(async (mac: string, category: DeviceCategory) => {
         try {
           const response = await fetch('/api/network/category-override', {
             method: 'POST',
             headers: { 'Content-Type': 'application/json' },
             body: JSON.stringify({ mac, category }),
           });

           if (response.ok) {
             // Optimistic update: immediately reflect in UI
             networkData.updateDeviceCategory(mac, category);
           }
         } catch {
           // Override failed — dropdown already closed, no action needed
           // Category will be re-fetched on next poll (fire-and-forget, self-heals)
         }
       }, [networkData.updateDeviceCategory]);
       ```

    2. Import `DeviceCategory` type: `import type { DeviceCategory } from '@/types/firebase/network';`

    3. Wire it to DeviceListTable — change line 82-85 from:
       ```tsx
       <DeviceListTable
         devices={networkData.devices}
         isStale={networkData.stale}
       />
       ```
       To:
       ```tsx
       <DeviceListTable
         devices={networkData.devices}
         isStale={networkData.stale}
         onCategoryChange={handleCategoryChange}
       />
       ```

    **Step 2: Update page tests** (`app/network/__tests__/page.test.tsx`):

    1. Update the `createMockNetworkData` helper to include `updateDeviceCategory`:
       ```typescript
       function createMockNetworkData(overrides: Partial<UseNetworkDataReturn> = {}): UseNetworkDataReturn {
         return {
           // ... existing fields ...
           updateDeviceCategory: jest.fn(),
           ...overrides,
         };
       }
       ```

    2. Update the DeviceListTable mock to capture `onCategoryChange` prop:
       ```typescript
       jest.mock('../components/DeviceListTable', () => ({
         __esModule: true,
         default: ({ devices, isStale, onCategoryChange }: any) => (
           <div
             data-testid="device-list-table"
             data-count={devices.length}
             data-stale={isStale}
             data-has-on-category-change={!!onCategoryChange}
           />
         ),
       }));
       ```

    3. Add test: "passes onCategoryChange callback to DeviceListTable"
       - Render the page with non-loading state
       - Assert `data-has-on-category-change` attribute is `"true"` on the DeviceListTable mock

    4. Ensure all existing tests still pass (they should — the mock just gains an extra attribute).

    **What NOT to do:**
    - Do NOT add error toasts or UI feedback for failed overrides — keep it simple, override will self-correct on next poll
    - Do NOT add loading states for the override — it's a quick fire-and-forget call
    - Do NOT wrap handleCategoryChange in useCallback with empty deps — it needs `networkData.updateDeviceCategory` in deps
  </action>
  <verify>
    1. `npx tsc --noEmit --pretty 2>&1 | head -30` shows no new TypeScript errors
    2. `npx jest app/network/__tests__/page.test.tsx --verbose` — all existing tests pass + new test passes
    3. Read page.tsx and confirm:
       - `handleCategoryChange` function exists
       - It calls `/api/network/category-override` via fetch POST
       - It calls `networkData.updateDeviceCategory` on success
       - DeviceListTable receives `onCategoryChange={handleCategoryChange}` prop
  </verify>
  <done>
    - Network page creates handleCategoryChange that calls category-override API
    - On success, calls updateDeviceCategory for optimistic UI update
    - DeviceListTable receives onCategoryChange prop (enables inline dropdown)
    - All page tests pass including new wiring test
    - No TypeScript errors
  </done>
</task>

</tasks>

<verification>
After all three tasks complete, verify end-to-end wiring:

1. **Override priority (Task 1):**
   - `vendor-lookup/route.ts` calls `getCategoryOverride(mac)` BEFORE checking vendor cache — MUST be present
   - If override exists, returns immediately with `overridden: true`, skipping macvendors.com
   - If no override, falls through to existing vendor cache + macvendors.com flow
   - `npx jest app/api/network/vendor-lookup/__tests__/route.test.ts --verbose` — all pass including 2 new override tests

2. **CAT-01 (Auto-categorization with override respect):**
   - `useNetworkData.ts` contains `fetch('/api/network/vendor-lookup` — MUST be present
   - The enrichment function calls vendor-lookup for each device MAC
   - vendor-lookup now returns overridden categories when they exist, so client is override-aware transparently
   - Devices state is updated with categories after enrichment

3. **CAT-02 (Manual override):**
   - `page.tsx` contains `fetch('/api/network/category-override` — MUST be present
   - `page.tsx` passes `onCategoryChange` prop to DeviceListTable — MUST be present
   - `handleCategoryChange` calls `updateDeviceCategory` on success

4. **CAT-03 (Visual badges):**
   - Since devices now have `category` field populated, DeviceCategoryBadge renders correct colors
   - This is automatically satisfied when CAT-01 works

5. **Tests:**
   - `npx jest app/api/network/vendor-lookup/__tests__/route.test.ts --verbose` — all pass
   - `npx jest app/network/__tests__/page.test.tsx --verbose` — all pass
   - `npx tsc --noEmit` — no new errors

6. **No regressions:**
   - Fritz!Box devices route untouched (stays lean)
   - DeviceListTable untouched (already has onCategoryChange prop support)
   - Existing 74 phase 66 tests still pass
</verification>

<success_criteria>
1. vendor-lookup API checks Firebase overrides first, ensuring manual overrides survive page reload/polling
2. useNetworkData enriches devices with categories by calling /api/network/vendor-lookup per MAC (which now respects overrides)
3. Network page wires handleCategoryChange → DeviceListTable.onCategoryChange → /api/network/category-override
4. UseNetworkDataReturn type includes updateDeviceCategory function
5. All existing tests pass with no regressions + new override tests pass
6. New test confirms onCategoryChange is wired to DeviceListTable
7. No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/66-device-categorization/66-04-SUMMARY.md`
</output>
