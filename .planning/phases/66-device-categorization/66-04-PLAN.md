---
phase: 66-device-categorization
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - app/components/devices/network/hooks/useNetworkData.ts
  - app/components/devices/network/types.ts
  - app/network/page.tsx
  - app/network/__tests__/page.test.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Devices fetched from Fritz!Box API are automatically enriched with categories via vendor-lookup API"
    - "User can click category badge in DeviceListTable dropdown and new category persists to Firebase via category-override API"
    - "Categories display correct color-coded badges (not 'Sconosciuto' for all devices)"
  artifacts:
    - path: "app/components/devices/network/hooks/useNetworkData.ts"
      provides: "Category enrichment after device fetch + updateDeviceCategory function"
      contains: "vendor-lookup"
    - path: "app/components/devices/network/types.ts"
      provides: "updateDeviceCategory in UseNetworkDataReturn"
      contains: "updateDeviceCategory"
    - path: "app/network/page.tsx"
      provides: "handleCategoryChange wired to DeviceListTable onCategoryChange prop"
      contains: "onCategoryChange"
  key_links:
    - from: "app/components/devices/network/hooks/useNetworkData.ts"
      to: "/api/network/vendor-lookup"
      via: "fetch call per device MAC after devices loaded"
      pattern: "vendor-lookup"
    - from: "app/network/page.tsx"
      to: "/api/network/category-override"
      via: "handleCategoryChange calls fetch POST"
      pattern: "category-override"
    - from: "app/network/page.tsx"
      to: "DeviceListTable"
      via: "onCategoryChange prop"
      pattern: "onCategoryChange"
---

<objective>
Wire the three orphaned device categorization layers (logic, API, UI) into a working end-to-end feature.

Purpose: Plans 01-03 built isolated layers that never connect. This gap closure plan wires them together so:
1. Devices are automatically enriched with categories after fetching from Fritz!Box (CAT-01)
2. Users can override categories via the inline dropdown, persisting to Firebase (CAT-02)
3. Badges show actual categories instead of 'unknown' for all devices (CAT-03)

Output: Working device categorization feature — all 3 requirements functional.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/66-device-categorization/66-01-SUMMARY.md
@.planning/phases/66-device-categorization/66-02-SUMMARY.md
@.planning/phases/66-device-categorization/66-03-SUMMARY.md
@.planning/phases/66-device-categorization/66-VERIFICATION.md

# Key source files to read before implementing:
@app/components/devices/network/hooks/useNetworkData.ts
@app/components/devices/network/types.ts
@app/network/page.tsx
@app/network/__tests__/page.test.tsx
@app/network/components/DeviceListTable.tsx
@app/api/network/vendor-lookup/route.ts
@app/api/network/category-override/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire category enrichment in useNetworkData hook and expose updateDeviceCategory</name>
  <files>
    app/components/devices/network/hooks/useNetworkData.ts
    app/components/devices/network/types.ts
  </files>
  <action>
    **Goal:** After devices are fetched from Fritz!Box, enrich each device with its category by calling the vendor-lookup API. Also expose an `updateDeviceCategory` function for manual override support.

    **Step 1: Update UseNetworkDataReturn type** in `app/components/devices/network/types.ts`:
    - Add `updateDeviceCategory: (mac: string, category: DeviceCategory) => void` to the `UseNetworkDataReturn` interface
    - Import `DeviceCategory` is already present in this file

    **Step 2: Add category enrichment to useNetworkData** in `app/components/devices/network/hooks/useNetworkData.ts`:

    After `setDevices(devData.devices || [])` on line 126, add a fire-and-forget category enrichment call. The enrichment should:

    1. Create an `enrichDevicesWithCategories` async function inside the hook (or as a separate helper). This function:
       - Takes `DeviceData[]` as input
       - For each device that has a MAC address and does NOT already have a `category` set (to avoid re-fetching), call `fetch('/api/network/vendor-lookup?mac=' + encodeURIComponent(device.mac))`
       - Parse response JSON: `{ vendor, category, cached }`
       - Return a new array with category fields populated
       - Use `Promise.allSettled()` to handle individual failures gracefully (if one MAC fails, others still enrich)
       - Wrap the whole thing in try/catch — on any error, silently keep devices without categories (non-critical feature)

    2. Call this enrichment function after setting devices. Use a pattern like:
       ```typescript
       const rawDevices = devData.devices || [];
       setDevices(rawDevices);

       // Fire-and-forget category enrichment (non-blocking)
       enrichDevicesWithCategories(rawDevices).then(enrichedDevices => {
         setDevices(enrichedDevices);
       }).catch(() => {
         // Category enrichment is non-critical — keep raw devices
       });
       ```

    3. **Important:** To avoid infinite re-enrichment loops, use a `useRef<Set<string>>` to track which MACs have already been enriched. Only enrich MACs not in the set. After enrichment, add them to the set. Reset the set when devices list changes significantly (e.g., different device count).

    4. **Performance:** Batch vendor lookups — don't call 30+ API requests simultaneously. Use a simple sequential loop or limit concurrency to 5 at a time. A simple approach: chunk the devices array into groups of 5 and await each group with `Promise.allSettled()`.

    **Step 3: Add updateDeviceCategory function:**

    Add a `useCallback` function `updateDeviceCategory(mac: string, category: DeviceCategory)`:
    - Updates the `devices` state by mapping over the array and setting the category for the matching MAC
    - Also update the enriched MACs ref to include this MAC (so polling doesn't overwrite)
    - This is called by the parent (network page) after a successful category override API call

    ```typescript
    const updateDeviceCategory = useCallback((mac: string, category: DeviceCategory) => {
      setDevices(prev => prev.map(d =>
        d.mac === mac ? { ...d, category } : d
      ));
      // Mark as enriched so polling doesn't overwrite manual override
      enrichedMacsRef.current.add(mac);
    }, []);
    ```

    **Step 4: Return updateDeviceCategory** from the hook in the return object.

    **What NOT to do:**
    - Do NOT modify the Fritz!Box devices API route (`app/api/fritzbox/devices/route.ts`) — it's a cached proxy and should stay lean
    - Do NOT make vendor-lookup calls blocking for the initial device render — show devices immediately, enrich async
    - Do NOT re-enrich on every poll cycle — use the enrichedMacsRef to skip already-categorized devices
    - Do NOT throw errors from enrichment — it's non-critical enhancement
  </action>
  <verify>
    1. `npx tsc --noEmit --pretty 2>&1 | head -30` shows no new TypeScript errors in modified files
    2. Read the modified useNetworkData.ts and confirm:
       - `enrichDevicesWithCategories` function exists
       - It calls `/api/network/vendor-lookup` endpoint
       - `updateDeviceCategory` function exists and is returned
       - enrichedMacsRef prevents re-enrichment
    3. Read types.ts and confirm `updateDeviceCategory` is in `UseNetworkDataReturn`
  </verify>
  <done>
    - useNetworkData hook enriches devices with categories via vendor-lookup API after each fetch
    - Already-enriched MACs are skipped on subsequent polls (ref-based tracking)
    - updateDeviceCategory function updates a single device's category in state
    - UseNetworkDataReturn type includes updateDeviceCategory
    - No TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire category override in network page and update tests</name>
  <files>
    app/network/page.tsx
    app/network/__tests__/page.test.tsx
  </files>
  <action>
    **Goal:** Create `handleCategoryChange` callback in network page that calls the category-override API and passes it to DeviceListTable's `onCategoryChange` prop. Update tests to verify the wiring.

    **Step 1: Modify network page** (`app/network/page.tsx`):

    1. Add a `handleCategoryChange` callback using `useCallback`:
       ```typescript
       const handleCategoryChange = useCallback(async (mac: string, category: DeviceCategory) => {
         try {
           const response = await fetch('/api/network/category-override', {
             method: 'POST',
             headers: { 'Content-Type': 'application/json' },
             body: JSON.stringify({ mac, category }),
           });

           if (response.ok) {
             // Optimistic update: immediately reflect in UI
             networkData.updateDeviceCategory(mac, category);
           }
         } catch {
           // Override failed — dropdown already closed, no action needed
           // Category will be re-fetched on next poll
         }
       }, [networkData.updateDeviceCategory]);
       ```

    2. Import `DeviceCategory` type: `import type { DeviceCategory } from '@/types/firebase/network';`

    3. Wire it to DeviceListTable — change line 82-85 from:
       ```tsx
       <DeviceListTable
         devices={networkData.devices}
         isStale={networkData.stale}
       />
       ```
       To:
       ```tsx
       <DeviceListTable
         devices={networkData.devices}
         isStale={networkData.stale}
         onCategoryChange={handleCategoryChange}
       />
       ```

    **Step 2: Update page tests** (`app/network/__tests__/page.test.tsx`):

    1. Update the `createMockNetworkData` helper to include `updateDeviceCategory`:
       ```typescript
       function createMockNetworkData(overrides: Partial<UseNetworkDataReturn> = {}): UseNetworkDataReturn {
         return {
           // ... existing fields ...
           updateDeviceCategory: jest.fn(),
           ...overrides,
         };
       }
       ```

    2. Update the DeviceListTable mock to capture `onCategoryChange` prop:
       ```typescript
       jest.mock('../components/DeviceListTable', () => ({
         __esModule: true,
         default: ({ devices, isStale, onCategoryChange }: any) => (
           <div
             data-testid="device-list-table"
             data-count={devices.length}
             data-stale={isStale}
             data-has-on-category-change={!!onCategoryChange}
           />
         ),
       }));
       ```

    3. Add test: "passes onCategoryChange callback to DeviceListTable"
       - Render the page with non-loading state
       - Assert `data-has-on-category-change` attribute is `"true"` on the DeviceListTable mock

    4. Ensure all existing tests still pass (they should — the mock just gains an extra attribute).

    **What NOT to do:**
    - Do NOT add error toasts or UI feedback for failed overrides — keep it simple, override will self-correct on next poll
    - Do NOT add loading states for the override — it's a quick fire-and-forget call
    - Do NOT wrap handleCategoryChange in useCallback with empty deps — it needs `networkData.updateDeviceCategory` in deps
  </action>
  <verify>
    1. `npx tsc --noEmit --pretty 2>&1 | head -30` shows no new TypeScript errors
    2. `npx jest app/network/__tests__/page.test.tsx --verbose` — all existing tests pass + new test passes
    3. Read page.tsx and confirm:
       - `handleCategoryChange` function exists
       - It calls `/api/network/category-override` via fetch POST
       - It calls `networkData.updateDeviceCategory` on success
       - DeviceListTable receives `onCategoryChange={handleCategoryChange}` prop
  </verify>
  <done>
    - Network page creates handleCategoryChange that calls category-override API
    - On success, calls updateDeviceCategory for optimistic UI update
    - DeviceListTable receives onCategoryChange prop (enables inline dropdown)
    - All page tests pass including new wiring test
    - No TypeScript errors
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify end-to-end wiring:

1. **CAT-01 (Auto-categorization):**
   - `useNetworkData.ts` contains `fetch('/api/network/vendor-lookup` — MUST be present
   - The enrichment function calls vendor-lookup for each device MAC
   - Devices state is updated with categories after enrichment

2. **CAT-02 (Manual override):**
   - `page.tsx` contains `fetch('/api/network/category-override` — MUST be present
   - `page.tsx` passes `onCategoryChange` prop to DeviceListTable — MUST be present
   - `handleCategoryChange` calls `updateDeviceCategory` on success

3. **CAT-03 (Visual badges):**
   - Since devices now have `category` field populated, DeviceCategoryBadge renders correct colors
   - This is automatically satisfied when CAT-01 works

4. **Tests:**
   - `npx jest app/network/__tests__/page.test.tsx --verbose` — all pass
   - `npx tsc --noEmit` — no new errors

5. **No regressions:**
   - Fritz!Box devices route untouched (stays lean)
   - DeviceListTable untouched (already has onCategoryChange prop support)
   - Existing 74 phase 66 tests still pass
</verification>

<success_criteria>
1. useNetworkData enriches devices with categories by calling /api/network/vendor-lookup per MAC
2. Network page wires handleCategoryChange → DeviceListTable.onCategoryChange → /api/network/category-override
3. UseNetworkDataReturn type includes updateDeviceCategory function
4. All existing tests pass with no regressions
5. New test confirms onCategoryChange is wired to DeviceListTable
6. No TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/66-device-categorization/66-04-SUMMARY.md`
</output>
