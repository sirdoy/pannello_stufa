---
phase: 67-bandwidth-correlation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - app/components/devices/network/types.ts
  - app/network/hooks/useBandwidthCorrelation.ts
  - app/network/hooks/__tests__/useBandwidthCorrelation.test.ts
  - lib/utils/pearsonCorrelation.ts
  - lib/utils/__tests__/pearsonCorrelation.test.ts
autonomous: true

must_haves:
  truths:
    - "Pearson correlation returns value between -1 and +1 for valid paired data"
    - "Correlation hook buffers paired bandwidth+power data points aligned by minute"
    - "Hook returns 'insufficient' status when fewer than 30 paired points exist"
    - "Null/undefined power levels are filtered out (stove off = no correlation point)"
    - "Insight text maps correlation coefficient to human-readable Italian description"
  artifacts:
    - path: "lib/utils/pearsonCorrelation.ts"
      provides: "Pearson correlation calculation"
      exports: ["calculatePearsonCorrelation"]
    - path: "app/network/hooks/useBandwidthCorrelation.ts"
      provides: "Correlation hook with data buffering, Pearson calc, insight generation"
      exports: ["useBandwidthCorrelation"]
    - path: "app/components/devices/network/types.ts"
      provides: "CorrelationDataPoint, CorrelationInsightLevel, UseBandwidthCorrelationReturn types"
      contains: "CorrelationDataPoint"
  key_links:
    - from: "app/network/hooks/useBandwidthCorrelation.ts"
      to: "lib/utils/pearsonCorrelation.ts"
      via: "import calculatePearsonCorrelation"
      pattern: "import.*calculatePearsonCorrelation.*from.*pearsonCorrelation"
    - from: "app/network/hooks/useBandwidthCorrelation.ts"
      to: "app/components/devices/network/types.ts"
      via: "import types"
      pattern: "import.*CorrelationDataPoint.*from.*types"
---

<objective>
Create the data layer for bandwidth-stove power correlation: Pearson correlation algorithm utility, correlation data types, and useBandwidthCorrelation hook that buffers paired data points, computes correlation coefficient, and generates human-readable insight text.

Purpose: Provides the computation and state management layer that the chart and insight components (Plan 02) will consume.
Output: Tested Pearson utility + useBandwidthCorrelation hook with TDD coverage.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-bandwidth-correlation/67-RESEARCH.md

# Existing patterns to follow
@app/network/hooks/useBandwidthHistory.ts
@app/components/devices/network/types.ts
@lib/utils/decimateLTTB.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pearson correlation utility + types (TDD)</name>
  <files>
    lib/utils/pearsonCorrelation.ts
    lib/utils/__tests__/pearsonCorrelation.test.ts
    app/components/devices/network/types.ts
  </files>
  <action>
**RED phase first.** Create test file `lib/utils/__tests__/pearsonCorrelation.test.ts` with these test cases:
- Empty arrays return 0
- Mismatched array lengths return 0
- Single element returns 0 (denominator is 0)
- Perfect positive correlation (x=[1,2,3,4,5], y=[2,4,6,8,10]) returns 1.0
- Perfect negative correlation (x=[1,2,3,4,5], y=[10,8,6,4,2]) returns -1.0
- No correlation (constant y values like y=[5,5,5,5,5]) returns 0
- Moderate correlation returns value between 0.3 and 0.7 (use known dataset)
- All identical x values returns 0 (division by zero guard)

Then create `lib/utils/pearsonCorrelation.ts`:
```typescript
export function calculatePearsonCorrelation(xValues: number[], yValues: number[]): number
```
Formula: r = [nSumXY - (SumX)(SumY)] / sqrt[(nSumX2 - (SumX)^2)(nSumY2 - (SumY)^2)]
Return 0 when denominator is 0 (prevents NaN). Use `!` for noUncheckedIndexedAccess on `yValues[i]` inside reduce.

**GREEN phase:** Implement until tests pass.

Add correlation types to `app/components/devices/network/types.ts` (append to end of file):

```typescript
// Bandwidth correlation types (Phase 67)

export interface CorrelationDataPoint {
  time: number;          // Unix timestamp ms (rounded to nearest minute)
  bandwidth: number;     // Download Mbps
  powerLevel: number;    // Stove power level (1-5)
}

export type CorrelationInsightLevel = 'strong-positive' | 'moderate-positive' | 'none' | 'moderate-negative' | 'strong-negative';

export interface CorrelationInsight {
  coefficient: number;           // Raw Pearson r (-1 to +1)
  level: CorrelationInsightLevel;
  description: string;           // Italian human-readable text
  dataPointCount: number;        // Number of paired points used
  activeHours: number;           // Approximate hours of stove activity
}

export type CorrelationStatus = 'ready' | 'collecting' | 'insufficient' | 'stove-off';

export interface UseBandwidthCorrelationReturn {
  chartData: CorrelationDataPoint[];
  insight: CorrelationInsight | null;
  status: CorrelationStatus;
  addDataPoint: (bandwidth: number, powerLevel: number | null, timestamp: number) => void;
  pointCount: number;
  minPoints: number;
}
```
  </action>
  <verify>
Run `npm test -- --testPathPattern="pearsonCorrelation" --watchAll=false` — all 8+ tests pass.
Verify types compile: `npx tsc --noEmit app/components/devices/network/types.ts` has no errors.
  </verify>
  <done>
Pearson correlation utility passes all edge case tests (empty, mismatched, perfect positive/negative, no correlation, division by zero). Correlation types are exported from network types file.
  </done>
</task>

<task type="auto">
  <name>Task 2: useBandwidthCorrelation hook (TDD)</name>
  <files>
    app/network/hooks/useBandwidthCorrelation.ts
    app/network/hooks/__tests__/useBandwidthCorrelation.test.ts
  </files>
  <action>
**RED phase first.** Create test file `app/network/hooks/__tests__/useBandwidthCorrelation.test.ts` using `@testing-library/react` renderHook pattern. Test cases:

1. **Initial state**: status='stove-off', chartData=[], insight=null, pointCount=0
2. **Stove off (null powerLevel)**: addDataPoint(50, null, Date.now()) does NOT add point, status stays 'stove-off'
3. **Collecting state**: add 15 points (less than 30 threshold), status='collecting', pointCount=15
4. **Ready state**: add 30+ points, status='ready', insight is not null
5. **Timestamp alignment**: two points within same minute (e.g., t and t+15000) produce single averaged data point
6. **Insight text mapping**: coefficient > 0.7 produces 'strong-positive' level, coefficient < -0.7 produces 'strong-negative'
7. **Active hours calculation**: 30 points at ~30s intervals = ~0.25 hours of active stove time
8. **Buffer cap**: adding more than MAX_CORRELATION_POINTS (2000) drops oldest points

**GREEN phase:** Create `app/network/hooks/useBandwidthCorrelation.ts`:

```typescript
'use client';

import { useState, useCallback, useMemo } from 'react';
import { calculatePearsonCorrelation } from '@/lib/utils/pearsonCorrelation';
import type {
  CorrelationDataPoint,
  CorrelationInsight,
  CorrelationInsightLevel,
  CorrelationStatus,
  UseBandwidthCorrelationReturn,
} from '@/app/components/devices/network/types';
```

Key implementation details:
- `MIN_CORRELATION_POINTS = 30` (minimum for meaningful Pearson)
- `MAX_CORRELATION_POINTS = 2000` (buffer cap)
- Round timestamps to nearest minute: `Math.round(timestamp / 60000) * 60000`
- When same minute already exists, average the bandwidth and powerLevel values (prevents duplicates from fast polling)
- Compute Pearson on `chartData` bandwidth vs powerLevel arrays
- Map coefficient to insight level using thresholds from research:
  - r > 0.7: 'strong-positive', "Correlazione forte positiva: la banda aumenta con la potenza della stufa"
  - r > 0.3: 'moderate-positive', "Correlazione moderata: la banda tende ad aumentare con il riscaldamento"
  - r > -0.3: 'none', "Nessuna correlazione significativa tra banda e riscaldamento"
  - r > -0.7: 'moderate-negative', "Correlazione moderata: la banda tende a diminuire durante il riscaldamento"
  - r <= -0.7: 'strong-negative', "Correlazione forte negativa: la banda diminuisce con l'aumento della potenza"
- `activeHours = pointCount * 30 / 3600` (assumes ~30s between measurements)
- Status logic: no points with non-null power = 'stove-off', points < 30 = 'collecting', else 'ready'
- BUT if pointCount > 0 and recent addDataPoint had null powerLevel, keep status as last non-stove-off state

Use `useMemo` for insight computation (depends on chartData). Use `useCallback` for addDataPoint.
  </action>
  <verify>
Run `npm test -- --testPathPattern="useBandwidthCorrelation" --watchAll=false` — all 8 tests pass.
Run `npm test -- --testPathPattern="(pearsonCorrelation|useBandwidthCorrelation)" --watchAll=false` — all tests pass together.
  </verify>
  <done>
useBandwidthCorrelation hook:
- Buffers paired data points with minute-level timestamp alignment
- Filters null power levels (stove off)
- Returns 'stove-off', 'collecting', 'insufficient', or 'ready' status
- Computes Pearson coefficient and maps to Italian insight text with 5 levels
- Caps buffer at 2000 points
- All tests passing
  </done>
</task>

</tasks>

<verification>
```bash
# All data layer tests pass
npm test -- --testPathPattern="(pearsonCorrelation|useBandwidthCorrelation)" --watchAll=false

# TypeScript compiles without errors
npx tsc --noEmit
```
</verification>

<success_criteria>
- Pearson correlation utility returns accurate coefficients for all edge cases
- useBandwidthCorrelation hook manages correlation data buffer with minute alignment
- Hook status transitions correctly: stove-off -> collecting -> ready
- Insight text is Italian and maps coefficient to 5 human-readable levels
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/67-bandwidth-correlation/67-01-SUMMARY.md`
</output>
