---
phase: 68-core-masonry-layout
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/page.tsx
autonomous: false
requirements:
  - LAYOUT-01
  - LAYOUT-02
  - LAYOUT-03
  - ANIM-01
  - ANIM-02

must_haves:
  truths:
    - "On desktop (>= 640px), dashboard cards render in two side-by-side columns where shorter cards do NOT leave vertical gaps — the next card in that column sits immediately below"
    - "Card order matches Firebase settings: card 0 top-left, card 1 top-right, card 2 below card 0, card 3 below card 1, etc."
    - "On mobile (< 640px), cards appear in a single column in flat order: 0, 1, 2, 3, 4, 5 — identical to the previous Grid behavior"
    - "Each card animates with spring-in entrance using stagger delay = flatIndex * 100ms (not intra-column index)"
    - "Card wrappers have transition-all duration-300 ease-out for smooth height transitions on content changes"
  artifacts:
    - path: "app/page.tsx"
      provides: "Masonry flexbox dashboard layout with mobile fallback"
      contains: "flex-col sm:flex-row"
  key_links:
    - from: "app/page.tsx"
      to: "visibleCards array"
      via: "parity split into left/right columns for desktop, flat render for mobile"
      pattern: "i % 2"
    - from: "app/page.tsx"
      to: "DeviceCardErrorBoundary"
      via: "wraps each CardComponent in both mobile and desktop renders"
      pattern: "DeviceCardErrorBoundary"
---

<objective>
Replace the CSS Grid layout (`<Grid cols={2} gap="lg">`) in `app/page.tsx` with a two-column flexbox masonry layout on desktop, and a flat single-column list on mobile, satisfying all five LAYOUT and ANIM requirements.

Purpose: Eliminate vertical gaps between cards of different heights on desktop while preserving Firebase card order and mobile single-column linear order.
Output: Updated `app/page.tsx` with masonry flexbox layout.
</objective>

<execution_context>
@/Users/federicomanfredi/.claude/get-shit-done/workflows/execute-plan.md
@/Users/federicomanfredi/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/68-core-masonry-layout/68-RESEARCH.md
@app/page.tsx
@app/components/ui/Grid.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace Grid with masonry flexbox layout and mobile fallback</name>
  <files>app/page.tsx</files>
  <action>
In `app/page.tsx`, replace the `<Grid cols={2} gap="lg">...</Grid>` block (lines 65-85) with a masonry layout. The approach has two parts: a mobile-only flat list and a desktop-only two-column masonry layout. This solves Pitfall 1 (mobile card order [0,2,4,1,3,5] instead of [0,1,2,3,4,5]).

**Step 1: Remove Grid import.** In the import line `import { Grid, EmptyState } from './components/ui';`, remove `Grid` so it becomes `import { EmptyState } from './components/ui';`. Grid is no longer used on this page.

**Step 2: Create a `renderCard` helper** above the return statement (inside the `Home` function, after `visibleCards`). This avoids JSX duplication between mobile and desktop renders:

```tsx
const renderCard = (card: typeof visibleCards[number], flatIndex: number) => {
  const CardComponent = CARD_COMPONENTS[card.id];
  if (!CardComponent) return null;
  return (
    <div
      key={card.id}
      className="animate-spring-in transition-all duration-300 ease-out"
      style={{ animationDelay: `${flatIndex * 100}ms` }}
    >
      <DeviceCardErrorBoundary
        deviceName={DEVICE_META[card.id]?.name ?? card.id}
        deviceIcon={DEVICE_META[card.id]?.icon ?? '⚠️'}
      >
        <CardComponent />
      </DeviceCardErrorBoundary>
    </div>
  );
};
```

Key details:
- `transition-all duration-300 ease-out` satisfies ANIM-02 (smooth height transitions on content changes)
- `animate-spring-in` with `animationDelay: flatIndex * 100ms` satisfies ANIM-01 (stagger uses flat index, not column index)
- CSS animations take precedence over transitions on same property, so spring-in and transition-all coexist without conflict

**Step 3: Precompute columns** in one pass (avoids O(n^2) `indexOf` calls):

```tsx
const leftColumn: Array<{ card: typeof visibleCards[number]; flatIndex: number }> = [];
const rightColumn: Array<{ card: typeof visibleCards[number]; flatIndex: number }> = [];
visibleCards.forEach((card, i) => {
  if (i % 2 === 0) {
    leftColumn.push({ card, flatIndex: i });
  } else {
    rightColumn.push({ card, flatIndex: i });
  }
});
```

**Step 4: Replace the `<Grid>` JSX** with two blocks — mobile flat list and desktop masonry:

```tsx
{/* Mobile: single column, flat order (LAYOUT-03) */}
<div className="flex flex-col gap-6 sm:hidden">
  {visibleCards.map((card, index) => renderCard(card, index))}
</div>

{/* Desktop: two-column masonry (LAYOUT-01, LAYOUT-02) */}
<div className="hidden sm:flex sm:flex-row gap-8 lg:gap-10">
  <div className="flex flex-col gap-8 lg:gap-10 flex-1 min-w-0">
    {leftColumn.map(({ card, flatIndex }) => renderCard(card, flatIndex))}
  </div>
  <div className="flex flex-col gap-8 lg:gap-10 flex-1 min-w-0">
    {rightColumn.map(({ card, flatIndex }) => renderCard(card, flatIndex))}
  </div>
</div>
```

Gap values: The current `Grid gap="lg"` produces `gap-6 sm:gap-8 lg:gap-10`. For mobile (`< sm`), use `gap-6`. For desktop (`>= sm`), use `gap-8` (the `sm` breakpoint value) and `lg:gap-10` (the `lg` breakpoint value). This matches the existing Grid gap progression exactly.

**Step 5: Keep the EmptyState** block as-is (lines 87-94). It remains outside the layout blocks and only renders when `visibleCards.length === 0`.

**Step 6: Keep the comment** above the layout block updated from "Devices grid using new Grid component" to "Devices masonry layout".

**What NOT to do:**
- Do NOT add `'use client'` — page.tsx remains a server component
- Do NOT modify Grid.tsx — it is used elsewhere
- Do NOT install any new dependencies
- Do NOT change the SandboxPanel or EmptyState blocks
- Do NOT change imports other than removing Grid from the ui import
  </action>
  <verify>
1. Run `npx tsc --noEmit` — no type errors in app/page.tsx
2. Run `npm run dev` and visually confirm:
   - Desktop (>= 640px): cards in two columns, no vertical gaps below shorter cards
   - Mobile (< 640px): cards in single column, order is 0,1,2,3,4,5
   - Cards animate with staggered spring-in on page load
3. Grep for `Grid` in app/page.tsx — should not appear (import removed)
  </verify>
  <done>
- Grid import removed, replaced by raw flexbox divs
- Mobile renders flat single-column list with linear card order (sm:hidden)
- Desktop renders two-column masonry with parity split (hidden sm:flex)
- renderCard helper used by both renders (no JSX duplication for card internals)
- transition-all duration-300 ease-out on each card wrapper
- animate-spring-in with flatIndex * 100ms delay on each card wrapper
- Gap values match previous Grid gap="lg" at each breakpoint
- No type errors, page.tsx still a server component
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Visual verification of masonry layout</name>
  <files>app/page.tsx</files>
  <action>
Verify the masonry flexbox dashboard layout replacing the uniform CSS Grid. Desktop shows two columns with no vertical gaps between cards of different heights. Mobile shows single column in flat order.

1. Open http://localhost:3000 in a browser (run `npm run dev` if not running)
2. **Desktop check (LAYOUT-01, LAYOUT-02):**
   - Resize browser to >= 640px width
   - Verify cards appear in two columns
   - Verify the shorter card in a pair does NOT have blank space below it — the next card in that column starts immediately
   - Verify card order: first configured card is top-left, second is top-right, third is below the first, etc.
3. **Mobile check (LAYOUT-03):**
   - Resize browser to < 640px width (or use DevTools mobile view)
   - Verify cards stack in a single column
   - Verify order is sequential: 0, 1, 2, 3, 4, 5 (matching Firebase settings order)
4. **Animation check (ANIM-01):**
   - Refresh the page
   - Verify cards animate in one by one with staggered spring-in (first card appears first, each subsequent card slightly delayed)
5. **Transition check (ANIM-02):**
   - If any card has expandable content (e.g., NetworkCard, StoveCard), expand/collapse it
   - Observe whether the height change transitions smoothly (note: height:auto limitation means this may not animate height itself, but transform/opacity changes should transition)
  </action>
  <verify>User confirms layout looks correct at both desktop and mobile breakpoints</verify>
  <done>User types "approved" confirming masonry layout works correctly, or describes issues to fix</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `grep -c "Grid" app/page.tsx` returns 0 (Grid import removed)
3. `grep -c "flex-col sm:hidden" app/page.tsx` returns 1 (mobile layout present)
4. `grep -c "hidden sm:flex" app/page.tsx` returns 1 (desktop masonry layout present)
5. `grep -c "transition-all duration-300" app/page.tsx` returns 1+ (ANIM-02 classes present)
6. `grep -c "animate-spring-in" app/page.tsx` returns 1+ (ANIM-01 classes preserved)
7. `grep -c "i % 2" app/page.tsx` returns 1 (parity split logic present)
</verification>

<success_criteria>
- Desktop: two-column masonry layout with no vertical gaps below shorter cards
- Mobile: single-column flat-order layout matching previous Grid behavior
- Card order matches Firebase settings at both breakpoints
- Spring-in stagger animation plays with flat index delay
- Card wrappers have transition-all for smooth content height changes
- No type errors, no new dependencies, page.tsx remains a server component
</success_criteria>

<output>
After completion, create `.planning/phases/68-core-masonry-layout/68-01-SUMMARY.md`
</output>
